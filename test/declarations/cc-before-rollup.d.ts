/// <reference types="./@types/globals" />
/// <reference types="./@types/webGL.extras" />
/// <reference types="./@types/webGL2.extras" />
/// <reference types="./node_modules/@cocos/ammo/Ammo" />
/// <reference types="./node_modules/@cocos/cannon/CANNON" />
declare module "cocos/core/global-exports" {
    /**
     * !#en
     * The main namespace of Cocos2d-JS, all engine core classes, functions, properties and constants are defined in this namespace.
     * !#zh
     * Cocos 引擎的主要命名空间，引擎代码中所有的类，函数，属性和常量都在这个命名空间中定义。
     * @deprecated
     */
    export const legacyCC: Record<string, any> & {
        _global: typeof globalThis;
    };
}
declare module "cocos/core/platform/debug" {
    /**
     * @en Outputs a message to the Cocos Creator Console (editor) or Web Console (runtime).
     * @zh 输出一条消息到 Cocos Creator 编辑器的 Console 或运行时 Web 端的 Console 中。
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function log(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Outputs a warning message to the Cocos Creator Console (editor) or Web Console (runtime).
     * - In Cocos Creator, warning is yellow.
     * - In Chrome, warning have a yellow warning icon with the message text.
     * @zh
     * 输出警告消息到 Cocos Creator 编辑器的 Console 或运行时 Web 端的 Console 中。<br/>
     * - 在 Cocos Creator 中，警告信息显示是黄色的。<br/>
     * - 在 Chrome 中，警告信息有着黄色的图标以及黄色的消息文本。<br/>
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function warn(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Outputs an error message to the Cocos Creator Console (editor) or Web Console (runtime).<br/>
     * - In Cocos Creator, error is red.<br/>
     * - In Chrome, error have a red icon along with red message text.<br/>
     * @zh
     * 输出错误消息到 Cocos Creator 编辑器的 Console 或运行时页面端的 Console 中。<br/>
     * - 在 Cocos Creator 中，错误信息显示是红色的。<br/>
     * - 在 Chrome 中，错误信息有红色的图标以及红色的消息文本。<br/>
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function error(message?: any, ...optionalParams: any[]): void;
    /**
     * @en
     * Assert the condition and output error messages if the condition is not true.
     * @zh
     * 对检查测试条件进行检查，如果条件不为 true 则输出错误消息
     * @param value - The condition to check on
     * @param message - A JavaScript string containing zero or more substitution strings.
     * @param optionalParams - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     */
    export function assert(value: any, message?: string, ...optionalParams: any[]): void;
    export function _resetDebugSetting(mode: DebugMode): void;
    export function _throw(error_: any): void;
    export function logID(id: number, ...optionalParams: any[]): void;
    export function warnID(id: number, ...optionalParams: any[]): void;
    export function errorID(id: number, ...optionalParams: any[]): void;
    export function assertID(condition: any, id: number, ...optionalParams: any[]): void;
    /**
     * @en Enum for debug modes.
     * @zh 调试模式
     */
    export enum DebugMode {
        /**
         * @en The debug mode none.
         * @zh 禁止模式，禁止显示任何日志信息。
         */
        NONE = 0,
        /**
         * @en The debug mode info.
         * @zh 信息模式，在 console 中显示所有日志。
         */
        INFO = 1,
        /**
         * @en The debug mode warn.
         * @zh 警告模式，在 console 中只显示 warn 级别以上的（包含 error）日志。
         */
        WARN = 2,
        /**
         * @en The debug mode error.
         * @zh 错误模式，在 console 中只显示 error 日志。
         */
        ERROR = 3,
        /**
         * @en The debug mode info for web page.
         * @zh 信息模式（仅 WEB 端有效），在画面上输出所有信息。
         */
        INFO_FOR_WEB_PAGE = 4,
        /**
         * @en The debug mode warn for web page.
         * @zh 警告模式（仅 WEB 端有效），在画面上输出 warn 级别以上的（包含 error）信息。
         */
        WARN_FOR_WEB_PAGE = 5,
        /**
         * @en The debug mode error for web page.
         * @zh 错误模式（仅 WEB 端有效），在画面上输出 error 信息。
         */
        ERROR_FOR_WEB_PAGE = 6
    }
    /**
     * @en Gets error message with the error id and possible parameters.
     * @zh 通过 error id 和必要的参数来获取错误信息。
     */
    export function getError(errorId: any, ...param: any[]): string;
    /**
     * @en Returns whether or not to display the FPS and debug information.
     * @zh 是否显示 FPS 信息和部分调试信息。
     */
    export function isDisplayStats(): boolean;
    /**
     * @en Sets whether display the FPS and debug informations on the bottom-left corner.
     * @zh 设置是否在左下角显示 FPS 和部分调试。
     */
    export function setDisplayStats(displayStats: boolean): void;
}
declare module "cocos/core/utils/mutable-forward-iterator" {
    /**
     * @class js.array.MutableForwardIterator
     * @example
     * ```
     * import { js } from 'cc';
     * var array = [0, 1, 2, 3, 4];
     * var iterator = new js.array.MutableForwardIterator(array);
     * for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
     *     var item = array[iterator.i];
     *     ...
     * }
     * ```
     */
    export default class MutableForwardIterator<T> {
        array: T[];
        i: number;
        constructor(array: T[]);
        get length(): number;
        set length(value: number);
        remove(value: T): void;
        removeAt(i: number): void;
        fastRemove(value: T): void;
        fastRemoveAt(i: number): void;
        push(item: T): void;
    }
}
declare module "cocos/core/utils/array" {
    export { default as MutableForwardIterator } from "cocos/core/utils/mutable-forward-iterator";
    /**
     * @zh
     * 移除指定索引的数组元素。
     * @en
     * Removes the array item at the specified index.
     * @param array 数组。
     * @param index 待移除元素的索引。
     */
    export function removeAt<T>(array: T[], index: number): void;
    /**
     * @zh
     * 移除指定索引的数组元素。
     * 此函数十分高效，但会改变数组的元素次序。
     * @en
     * Removes the array item at the specified index.
     * It's faster but the order of the array will be changed.
     * @param array 数组。
     * @param index 待移除元素的索引。
     */
    export function fastRemoveAt<T>(array: T[], index: number): void;
    /**
     * @zh
     * 移除首个指定的数组元素。判定元素相等时相当于于使用了 `Array.prototype.indexOf`。
     * @en
     * Removes the first occurrence of a specific object from the array.
     * Decision of the equality of elements is similar to `Array.prototype.indexOf`.
     * @param array 数组。
     * @param value 待移除元素。
     */
    export function remove<T>(array: T[], value: T): boolean;
    /**
     * @zh
     * 移除首个指定的数组元素。判定元素相等时相当于于使用了 `Array.prototype.indexOf`。
     * 此函数十分高效，但会改变数组的元素次序。
     * @en
     * Removes the first occurrence of a specific object from the array.
     * Decision of the equality of elements is similar to `Array.prototype.indexOf`.
     * It's faster but the order of the array will be changed.
     * @param array 数组。
     * @param value 待移除元素。
     */
    export function fastRemove<T>(array: T[], value: T): void;
    /**
     * @zh
     * 移除首个使谓词满足的数组元素。
     * @en
     * Removes the first occurrence of a specific object from the array where `predicate` is `true`.
     * @param array 数组。
     * @param predicate 谓词。
     */
    export function removeIf<T>(array: T[], predicate: (value: T) => boolean): T | undefined;
    /**
     * @zh
     * 验证数组的类型。
     * 此函数将用 `instanceof` 操作符验证每一个元素。
     * @en
     * Verify array's Type.
     * This function tests each element using `instanceof` operator.
     * @param array 数组。
     * @param type 类型。
     * @returns 当每一个元素都是指定类型时返回 `true`，否则返回 `false`。
     */
    export function verifyType<T extends Function>(array: any[], type: T): array is T[];
    /**
     * @zh
     * 移除多个数组元素。
     * @en
     * Removes multiple array elements.
     * @param array 源数组。
     * @param removals 所有待移除的元素。此数组的每个元素所对应的首个源数组的元素都会被移除。
     */
    export function removeArray<T>(array: T[], removals: T[]): void;
    /**
     * @zh
     * 在数组的指定索引上插入对象。
     * @en
     * Inserts some objects at specified index.
     * @param array 数组。
     * @param objects 插入的所有对象。
     * @param index 插入的索引。
     * @returns `array`。
     */
    export function appendObjectsAt<T>(array: T[], objects: T[], index: number): T[];
    /**
     * @zh
     * 返回数组是否包含指定的元素。
     * @en
     * Determines whether the array contains a specific element.
     * @returns 返回数组是否包含指定的元素。
     */
    export function contains<T>(array: T[], value: T): boolean;
    /**
     * @zh
     * 拷贝数组。
     * @en
     * Copy an array.
     * @param 源数组。
     * @returns 数组的副本。
     */
    export function copy<T>(array: T[]): any[];
}
declare module "cocos/core/utils/id-generator" {
    /**
     * ID generator for runtime.
     */
    export default class IDGenerator {
        static global: IDGenerator;
        id: number;
        prefix: string;
        /**
         * @param [category] You can specify a unique category to avoid id collision with other instance of IdGenerator.
         */
        constructor(category?: string);
        getNewId(): string;
    }
}
declare module "cocos/core/utils/js-typed" {
    /**
     * Check the object whether is number or not
     * If a number is created by using 'new Number(10086)', the typeof it will be "object"...
     * Then you can use this function if you care about this case.
     */
    export function isNumber(object: any): boolean;
    /**
     * Check the object whether is string or not.
     * If a string is created by using 'new String("blabla")', the typeof it will be "object"...
     * Then you can use this function if you care about this case.
     */
    export function isString(object: any): boolean;
    /**
     * Define value, just help to call Object.defineProperty.<br>
     * The configurable will be true.
     * @param [writable=false]
     * @param [enumerable=false]
     */
    export const value: (object: Object, propertyName: string, value_: any, writable?: boolean | undefined, enumerable?: boolean | undefined) => void;
    /**
     * Define get set accessor, just help to call Object.defineProperty(...).
     * @param [setter=null]
     * @param [enumerable=false]
     * @param [configurable=false]
     */
    export const getset: (object: {}, propertyName: string, getter: Getter, setter?: boolean | Setter | undefined, enumerable?: boolean, configurable?: boolean) => void;
    /**
     * Define get accessor, just help to call Object.defineProperty(...).
     * @param [enumerable=false]
     * @param [configurable=false]
     */
    export const get: (object: Object, propertyName: string, getter: Getter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
    /**
     * Define set accessor, just help to call Object.defineProperty(...).
     * @param [enumerable=false]
     * @param [configurable=false]
     */
    export const set: (object: Object, propertyName: string, setter: Setter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
    /**
     * @en
     * A simple wrapper of `Object.create(null)` which ensures the return object have no prototype (and thus no inherited members).
     * So we can skip `hasOwnProperty` calls on property lookups.
     * It is a worthwhile optimization than the `{}` literal when `hasOwnProperty` calls are necessary.
     * @zh
     * 该方法是对 `Object.create(null)` 的简单封装。
     * `Object.create(null)` 用于创建无 prototype （也就无继承）的空对象。
     * 这样我们在该对象上查找属性时，就不用进行 `hasOwnProperty` 判断。
     * 在需要频繁判断 `hasOwnProperty` 时，使用这个方法性能会比 `{}` 更高。
     *
     * @param [forceDictMode=false] Apply the delete operator to newly created map object.
     * This causes V8 to put the object in "dictionary mode" and disables creation of hidden classes
     * which are very expensive for objects that are constantly changing shape.
     */
    export function createMap(forceDictMode?: boolean): any;
    /**
     * Get class name of the object, if object is just a {} (and which class named 'Object'), it will return "".
     * (modified from <a href="http://stackoverflow.com/questions/1249531/how-to-get-a-javascript-objects-class">the code from this stackoverflow post</a>)
     * @param objOrCtor instance or constructor
     */
    export function getClassName(objOrCtor: Object | Function): string;
    /**
     * Defines a polyfill field for obsoleted codes.
     * @param object - YourObject or YourClass.prototype
     * @param obsoleted - "OldParam" or "YourClass.OldParam"
     * @param newExpr - "NewParam" or "YourClass.NewParam"
     * @param  [writable=false]
     */
    export function obsolete(object: any, obsoleted: string, newExpr: string, writable?: boolean): void;
    /**
     * Defines all polyfill fields for obsoleted codes corresponding to the enumerable properties of props.
     * @method obsoletes
     * @param {any} obj - YourObject or YourClass.prototype
     * @param {any} objName - "YourObject" or "YourClass"
     * @param {Object} props
     * @param {Boolean} [writable=false]
     */
    export function obsoletes(obj: any, objName: any, props: any, writable: any): void;
    /**
     * A string tool to construct a string with format string.
     * @param msg - A JavaScript string containing zero or more substitution strings (%s).
     * @param subst - JavaScript objects with which to replace substitution strings within msg.
     * This gives you additional control over the format of the output.
     * @example
     * ```
     * import { js } from 'cc';
     * js.formatStr("a: %s, b: %s", a, b);
     * js.formatStr(a, b, c);
     * ```
     */
    export function formatStr(msg: string | any, ...subst: any[]): any;
    export function shiftArguments(): any[];
    /**
     * Get property descriptor in object and all its ancestors.
     */
    export function getPropertyDescriptor(object: any, propertyName: string): PropertyDescriptor | null;
    /**
     * Copy all properties not defined in object from arguments[1...n].
     * @param object Object to extend its properties.
     * @param sources Source object to copy properties from.
     * @return The result object.
     */
    export function addon(object?: any, ...sources: any[]): any;
    /**
     * Copy all properties from arguments[1...n] to object.
     * @return The result object.
     */
    export function mixin(object?: any, ...sources: any[]): any;
    /**
     * Derive the class from the supplied base class.
     * Both classes are just native javascript constructors, not created by `Class`, so
     * usually you will want to inherit using [[Class]] instead.
     * @param base The baseclass to inherit.
     * @return The result class.
     */
    export function extend(cls: Function, base: Function): Function | undefined;
    /**
     * Get super class.
     * @param constructor The constructor of subclass.
     */
    export function getSuper(constructor: Function): any;
    /**
     * Checks whether subclass is child of superclass or equals to superclass.
     */
    export function isChildClassOf(subclass: Function, superclass: Function): boolean;
    /**
     * Removes all enumerable properties from object.
     */
    export function clear(object: {}): void;
    export const _idToClass: {};
    export const _nameToClass: {};
    /**
     * Register the class by specified id, if its classname is not defined, the class name will also be set.
     * @method _setClassId
     * @param {String} classId
     * @param {Function} constructor
     * @private
     */
    export function _setClassId(id: any, constructor: any): void;
    /**
     * Register the class by specified name manually
     * @method setClassName
     * @param {String} className
     * @param {Function} constructor
     */
    export function setClassName(className: any, constructor: any): void;
    /**
     * @en
     * @zh
     * 为类设置别名。
     * 当 `setClassAlias(target, alias)` 后，
     * `alias` 将作为类 `target`的“单向 ID” 和“单向名称”。
     * 因此，`_getClassById(alias)` 和 `getClassByName(alias)` 都会得到 `target`。
     * 这种映射是单向的，意味着 `getClassName(target)` 和 `_getClassId(target)` 将不会是 `alias`。
     * @param target Constructor of target class.
     * @param alias Alias to set. The name shall not have been set as class name or alias of another class.
     */
    export function setClassAlias(target: Function, alias: string): void;
    /**
     * Unregister a class from fireball.
     *
     * If you dont need a registered class anymore, you should unregister the class so that Fireball will not keep its reference anymore.
     * Please note that its still your responsibility to free other references to the class.
     *
     * @method unregisterClass
     * @param {Function} ...constructor - the class you will want to unregister, any number of classes can be added
     */
    export function unregisterClass(...constructors: Function[]): void;
    /**
     * Get the registered class by id
     * @method _getClassById
     * @param {String} classId
     * @return {Function} constructor
     * @private
     */
    export function _getClassById(classId: any): any;
    /**
     * Get the registered class by name
     * @method getClassByName
     * @param {String} classname
     * @return {Function} constructor
     */
    export function getClassByName(classname: any): any;
    /**
     * Get class id of the object
     * @method _getClassId
     * @param {Object|Function} obj - instance or constructor
     * @param {Boolean} [allowTempId = true]   - can return temp id in editor
     * @return {String}
     * @private
     */
    export function _getClassId(obj: any, allowTempId?: Boolean): any;
}
declare module "cocos/core/utils/pool" {
    type CleanUpFunction<T> = (value: T) => boolean | void;
    /**
     * @en
     * A fixed-length object pool designed for general type.<br>
     * The implementation of this object pool is very simple,
     * it can helps you to improve your game performance for objects which need frequent release and recreate operations<br/>
     * @zh
     * 长度固定的对象缓存池，可以用来缓存各种对象类型。<br/>
     * 这个对象池的实现非常精简，它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁。
     * @class js.Pool
     * @example
     * ```
     *
     * Example 1:
     *
     * function Details () {
     *     this.uuidList = [];
     * };
     * Details.prototype.reset = function () {
     *     this.uuidList.length = 0;
     * };
     * Details.pool = new js.Pool(function (obj) {
     *     obj.reset();
     * }, 5);
     * Details.pool.get = function () {
     *     return this._get() || new Details();
     * };
     *
     * var detail = Details.pool.get();
     * ...
     * Details.pool.put(detail);
     *
     * Example 2:
     *
     * function Details (buffer) {
     *    this.uuidList = buffer;
     * };
     * ...
     * Details.pool.get = function (buffer) {
     *     var cached = this._get();
     *     if (cached) {
     *         cached.uuidList = buffer;
     *         return cached;
     *     }
     *     else {
     *         return new Details(buffer);
     *     }
     * };
     *
     * var detail = Details.pool.get( [] );
     * ...
     * ```
     */
    export default class Pool<T> {
        /**
         * @en
         * The current number of available objects, the default is 0, it will gradually increase with the recycle of the object,
         * the maximum will not exceed the size specified when the constructor is called.
         * @zh
         * 当前可用对象数量，一开始默认是 0，随着对象的回收会逐渐增大，最大不会超过调用构造函数时指定的 size。
         * @default 0
         */
        count: number;
        /**
         * @en
         * Get and initialize an object from pool. This method defaults to null and requires the user to implement it.
         * @zh
         * 获取并初始化对象池中的对象。这个方法默认为空，需要用户自己实现。
         * @param args - parameters to used to initialize the object
         */
        get(): T | null;
        private _pool;
        private _cleanup;
        /**
         * 使用构造函数来创建一个指定对象类型的对象池，您可以传递一个回调函数，用于处理对象回收时的清理逻辑。
         * @method constructor
         * @param {Function} [cleanupFunc] - the callback method used to process the cleanup logic when the object is recycled.
         * @param {Object} cleanupFunc.obj
         * @param {Number} size - initializes the length of the array
         */
        constructor(cleanup: CleanUpFunction<T>, size: number);
        /**
         * 使用构造函数来创建一个指定对象类型的对象池，您可以传递一个回调函数，用于处理对象回收时的清理逻辑。
         * @method constructor
         * @param {Function} [cleanupFunc] - the callback method used to process the cleanup logic when the object is recycled.
         * @param {Object} cleanupFunc.obj
         * @param {Number} size - initializes the length of the array
         */
        constructor(size: number);
        /**
         * @en
         * Get an object from pool, if no available object in the pool, null will be returned.
         * @zh
         * 获取对象池中的对象，如果对象池没有可用对象，则返回空。
         */
        _get(): T | null;
        /**
         * @en Put an object into the pool.
         * @zh 向对象池返还一个不再需要的对象。
         */
        put(obj: T): void;
        /**
         * @en Resize the pool.
         * @zh 设置对象池容量。
         */
        resize(length: number): void;
    }
}
declare module "cocos/core/utils/js" {
    import * as jsarray from "cocos/core/utils/array";
    import IDGenerator from "cocos/core/utils/id-generator";
    import { _getClassById, _getClassId, _setClassId, addon, clear, createMap, extend, formatStr, getClassByName, getClassName, getPropertyDescriptor, getSuper, isChildClassOf, isNumber, isString, mixin, obsolete, obsoletes, setClassName, setClassAlias, shiftArguments, unregisterClass } from "cocos/core/utils/js-typed";
    import Pool from "cocos/core/utils/pool";
    export * from "cocos/core/utils/js-typed";
    export { default as IDGenerator } from "cocos/core/utils/id-generator";
    export { default as Pool } from "cocos/core/utils/pool";
    export const array: typeof jsarray;
    export const js: {
        IDGenerator: typeof IDGenerator;
        Pool: typeof Pool;
        array: typeof jsarray;
        isNumber: typeof isNumber;
        isString: typeof isString;
        getPropertyDescriptor: typeof getPropertyDescriptor;
        addon: typeof addon;
        mixin: typeof mixin;
        extend: typeof extend;
        getSuper: typeof getSuper;
        isChildClassOf: typeof isChildClassOf;
        clear: typeof clear;
        value: (object: Object, propertyName: string, value_: any, writable?: boolean | undefined, enumerable?: boolean | undefined) => void;
        getset: (object: {}, propertyName: string, getter: Getter, setter?: boolean | Setter | undefined, enumerable?: boolean, configurable?: boolean) => void;
        get: (object: Object, propertyName: string, getter: Getter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
        set: (object: Object, propertyName: string, setter: Setter, enumerable?: boolean | undefined, configurable?: boolean | undefined) => void;
        unregisterClass: typeof unregisterClass;
        getClassName: typeof getClassName;
        setClassName: typeof setClassName;
        setClassAlias: typeof setClassAlias;
        getClassByName: typeof getClassByName;
        _getClassId: typeof _getClassId;
        _setClassId: typeof _setClassId;
        _getClassById: typeof _getClassById;
        obsolete: typeof obsolete;
        obsoletes: typeof obsoletes;
        formatStr: typeof formatStr;
        shiftArguments: typeof shiftArguments;
        createMap: typeof createMap;
    };
}
declare module "cocos/core/utils/misc" {
    export const BUILTIN_CLASSID_RE: RegExp;
    export const BASE64_VALUES: any[];
    /**
     * misc utilities
     * @class misc
     * @static
     */
    /**
     * @method propertyDefine
     * @param {Function} ctor
     * @param {Array} sameNameGetSets
     * @param {Object} diffNameGetSets
     */
    export function propertyDefine(ctor: any, sameNameGetSets: any, diffNameGetSets: any): void;
    export function pushToMap(map: any, key: any, value: any, pushFront: any): void;
    export function contains(refNode: any, otherNode: any): any;
    export function isDomNode(obj: any): boolean;
    export function callInNextTick(callback: any, p1?: any, p2?: any): void;
    export function tryCatchFunctor_EDITOR(funcName: any): Function;
    export function isPlainEmptyObj_DEV(obj: any): boolean;
    export function cloneable_DEV(obj: any): any;
}
declare module "cocos/core/value-types/bitmask" {
    export function BitMask<T>(obj: T): T;
    export namespace BitMask {
        var isBitMask: (BitMaskType: any) => any;
        var getList: (BitMaskDef: any) => any;
    }
    export function ccbitmask(bitmaskx: any): void;
}
declare module "cocos/core/data/utils/asserts" {
    /**
     * Asserts that the expression is non-nullable, i.e. is neither `null` nor `undefined`.
     * @param expr Testing expression.
     * @param message Optional message.
     */
    export function assertIsNonNullable<T>(expr: T, message?: string): asserts expr is NonNullable<T>;
    /**
     * Asserts that the expression evaluated to `true`.
     * @param expr Testing expression.
     * @param message Optional message.
     */
    export function assertIsTrue(expr: boolean, message?: string): void;
}
declare module "cocos/core/value-types/enum" {
    /**
     * @en
     * Define an enum type. <br/>
     * If a enum item has a value of -1, it will be given an Integer number according to it's order in the list.<br/>
     * Otherwise it will use the value specified by user who writes the enum definition.
     *
     * @zh
     * 定义一个枚举类型。<br/>
     * 用户可以把枚举值设为任意的整数，如果设为 -1，系统将会分配为上一个枚举值 + 1。
     *
     * @param obj - a JavaScript literal object containing enum names and values, or a TypeScript enum type
     * @return the defined enum type
     */
    export function Enum<T>(obj: T): T;
    /**
     * @en
     * Define an enum type. <br/>
     * If a enum item has a value of -1, it will be given an Integer number according to it's order in the list.<br/>
     * Otherwise it will use the value specified by user who writes the enum definition.
     *
     * @zh
     * 定义一个枚举类型。<br/>
     * 用户可以把枚举值设为任意的整数，如果设为 -1，系统将会分配为上一个枚举值 + 1。
     *
     * @param obj - a JavaScript literal object containing enum names and values, or a TypeScript enum type
     * @return the defined enum type
     */
    export namespace Enum {
        var update: <T>(obj: T) => T;
        var isEnum: <EnumT extends {}>(enumType: EnumT) => boolean;
        var getList: <EnumT extends {}>(enumType: EnumT) => readonly Enum.Enumerator<EnumT>[];
    }
    namespace Enum {
        interface Enumerator<EnumT> {
            /**
             * The name of the enumerator.
             */
            name: keyof EnumT;
            /**
             * The value of the numerator.
             */
            value: EnumT[typeof name];
        }
    }
    /**
     * Make the enum type `enumType` as enumeration so that Creator may identify, operate on it.
     * Formally, as a result of invocation on this function with enum type `enumType`:
     * - `Enum.isEnum(enumType)` returns `true`;
     * - `Enum.getList(enumType)` returns the enumerators of `enumType`.
     * @param enumType An enum type, eg, a kind of type with similar semantic defined by TypeScript.
     */
    export function ccenum<EnumT extends {}>(enumType: EnumT): void;
}
declare module "cocos/core/value-types/value-type" {
    /**
     * 所有值类型的基类。
     */
    export class ValueType {
        /**
         * 克隆当前值。克隆的结果值应与当前值相等，即满足 `this.equals(this, value.clone())`。
         *
         * 本方法的基类版本简单地返回 `this`；
         * 派生类**必须**重写本方法，并且返回的对象不应当为 `this`，即满足 `this !== this.clone()`。
         * @returns 克隆结果值。
         */
        clone(): ValueType;
        /**
         * 判断当前值是否与指定值相等。此判断应当具有交换性，即满足 `this.equals(other) === other.equals(this)`。
         * 本方法的基类版本简单地返回 `false`。
         * @param other 相比较的值。
         * @returns 相等则返回 `true`，否则返回 `false`。
         */
        equals(other: this): boolean;
        /**
         * 赋值当前值使其与指定值相等，即在 `this.set(other)` 之后应有 `this.equals(other)`。
         * 本方法的基类版本简单地返回 `this`，派生类**必须**重写本方法。
         * @param other 相比较的值。
         */
        set(other: this): void;
        /**
         * 返回当前值的字符串表示。
         * 本方法的基类版本返回空字符串。
         * @returns 当前值的字符串表示。
         */
        toString(): string;
    }
}
declare module "cocos/core/value-types/index" {
    /**
     * @hidden
     */
    export { BitMask } from "cocos/core/value-types/bitmask";
    export { Enum, ccenum } from "cocos/core/value-types/enum";
    export { ValueType } from "cocos/core/value-types/value-type";
}
declare module "cocos/core/data/utils/attribute" {
    export const DELIMETER = "$_$";
    export function createAttrsSingle(owner: Object, ownerConstructor: Function, superAttrs?: any): any;
    /**
     * @param subclass Should not have '__attrs__'.
     */
    export function createAttrs(subclass: any): any;
    /**
     * Tag the class with any meta attributes, then return all current attributes assigned to it.
     * This function holds only the attributes, not their implementations.
     * @param constructor The class or instance. If instance, the attribute will be dynamic and only available for the specified instance.
     * @param propertyName The name of property or function, used to retrieve the attributes.
     * @param [newAttributes] The attribute table to mark, new attributes will merged with existed attributes.
     * Attribute whose key starts with '_' will be ignored.
     * @private
     */
    export function attr(constructor: any, propertyName: string): {
        [propertyName: string]: any;
    };
    export function attr(constructor: any, propertyName: string, newAttributes: Object): void;
    /**
     * Returns a readonly meta object.
     */
    export function getClassAttrs(constructor: any): any;
    /**
     * Returns a writable meta object, used to set multi attributes.
     */
    export function getClassAttrsProto(constructor: Function): any;
    export function setClassAttr(ctor: any, propName: any, key: any, value: any): void;
    export class PrimitiveType<T> {
        name: string;
        default: T;
        constructor(name: string, defaultValue: T);
        toString(): string;
    }
    /**
     * 指定编辑器以整数形式对待该属性或数组元素。
     * 例如：
     * ```ts
     * import { CCInteger, _decorator } from "Cocos3D";
     *
     * // 在 cc 类定义中:
     *
     * \@_decorator.property({type: CCInteger})
     * count = 0;
     *
     * \@_decorator.property({type: [CCInteger]})
     * array = [];
     * ```
     */
    export const CCInteger: PrimitiveType<number>;
    /**
     * 指定编辑器以浮点数形式对待该属性或数组元素。
     * 例如：
     * ```ts
     * import { CCFloat, _decorator } from "Cocos3D";
     *
     * // 在 cc 类定义中:
     *
     * \@_decorator.property({type: CCFloat})
     * x = 0;
     *
     * \@_decorator.property({type: [CCFloat]})
     * array = [];
     * ```
     */
    export const CCFloat: PrimitiveType<number>;
    /**
     * 指定编辑器以布尔值形式对待该属性或数组元素。
     * 例如：
     * ```ts
     * import { CCBoolean, _decorator } from "Cocos3D";
     *
     * // 在 cc 类定义中:
     *
     * \@_decorator.property({type: CCBoolean})
     * isTrue = false;
     *
     * \@_decorator.property({type: [CCBoolean]})
     * array = [];
     * ```
     */
    export const CCBoolean: PrimitiveType<boolean>;
    /**
     * 指定编辑器以字符串形式对待该属性或数组元素。
     * 例如：
     * ```ts
     * import { CCString, _decorator } from "Cocos3D";
     *
     * // 在 cc 类定义中:
     *
     * \@_decorator.property({type: CCString})
     * name = '';
     *
     * \@_decorator.property({type: [CCString]})
     * array = [];
     * ```
     */
    export const CCString: PrimitiveType<string>;
    export function getTypeChecker(type: string, attributeName: string): (constructor: Function, mainPropertyName: string) => void;
    export function getObjTypeChecker(typeCtor: any): (classCtor: any, mainPropName: any) => void;
}
declare module "cocos/core/data/utils/attribute-defines" {
    export interface IExposedAttributes {
        /**
         * 指定属性的类型。
         */
        type?: any;
        /**
         *
         */
        url?: string;
        /**
         * 控制是否在编辑器中显示该属性。
         */
        visible?: boolean | (() => boolean);
        /**
         * 该属性在编辑器中的显示名称。
         */
        displayName?: string;
        /**
         *
         */
        displayOrder?: number;
        /**
         * 该属性在编辑器中的工具提示内容。
         */
        tooltip?: string;
        /**
         *
         */
        multiline?: boolean;
        /**
         * 指定该属性是否为可读的。
         */
        readonly?: boolean;
        /**
         * 当该属性为数值类型时，指定了该属性允许的最小值。
         */
        min?: number;
        /**
         * 当该属性为数值类型时，指定了该属性允许的最大值。
         */
        max?: number;
        /**
         * 当该属性为数值类型时并在编辑器中提供了滑动条时，指定了滑动条的步长。
         */
        step?: number;
        /**
         * 当该属性为数值类型时，指定了该属性允许的范围。
         */
        range?: number[];
        /**
         * 当该属性为数值类型时，是否在编辑器中提供滑动条来调节值。
         */
        slide?: boolean;
        /**
         * 该属性是否参与序列化和反序列化。
         */
        serializable?: boolean;
        /**
         * 该属性的曾用名。
         */
        formerlySerializedAs?: string;
        /**
         * 该属性是否仅仅在编辑器环境中生效。
         */
        editorOnly?: boolean;
        /**
         * 是否覆盖基类中的同名属性。
         */
        override?: boolean;
        /**
         *
         */
        animatable?: boolean;
        /**
         *
         */
        unit?: string;
        /**
         * 转换为弧度
         */
        radian?: boolean;
        /**
         * 注意：这是一个内部选项。
         * 此选项是为了在 `@property` 的基础上精确实现 `@serializable`、`@editable`以及所有新增的独立装饰器的行为。
         *
         * 当此字段为 `true` 时。以下规则将不再生效：
         * - 只要 `@property` 未显式指定选项 `.serializable === false`，就开启序列化；
         * - 只要 `@property` 未显式指定选项 `.visible === false` 且目标属性的名称不以下划线开头，就开启编辑器交互。
         * 反之，由以下规则取代：
         * - 当且仅当 `@property` 显式指定了 `.serializable === true` 时才开启序列化；
         * - 当且仅当 `@property` 显式指定了 `.visible === true` 时才开启编辑器交互。
         */
        __noImplicit?: boolean;
    }
    export interface IAcceptableAttributes extends IExposedAttributes {
        _short?: boolean;
    }
}
declare module "cocos/core/data/utils/preprocess-class" {
    export function getFullFormOfProperty(options: any, propname_dev?: any, classname_dev?: any): {
        default: any;
        type: any;
        _short: boolean;
        url?: undefined;
    } | {
        default: string;
        url: any;
        _short: boolean;
        type?: undefined;
    } | {
        default: any;
        _short: boolean;
        type?: undefined;
        url?: undefined;
    } | null;
    export function preprocessAttrs(properties: any, className: any, cls: any, es6: any): void;
    export function doValidateMethodWithProps_DEV(func: any, funcName: any, className: any, cls: any, base: any): false | undefined;
    export function validateMethodWithProps(func: any, funcName: any, className: any, cls: any, base: any): boolean;
}
declare module "cocos/core/data/utils/requiring-frame" {
    export function push(module: any, uuid: string, script: any, importMeta?: any): void;
    export function pop(): void;
    export function peek(): any;
}
declare module "cocos/core/data/class" {
    import * as attributeUtils from "cocos/core/data/utils/attribute";
    export function CCClass(options: any): any;
    export namespace CCClass {
        var _isCCClass: (constructor: any) => any;
        var fastDefine: (className: any, constructor: any, serializableFields: any) => void;
        var Attr: typeof attributeUtils;
        var attr: typeof attributeUtils.attr;
        var getInheritanceChain: (constructor: any) => any[];
        var isArray: (defaultVal: any) => boolean;
        var getDefault: (defaultVal: any) => any;
        var escapeForJS: (s: any) => string;
        var IDENTIFIER_RE: RegExp;
        var getNewValueTypeCode: (value: any) => string;
    }
}
declare module "cocos/core/data/decorators/utils" {
    export type BabelPropertyDecoratorDescriptor = PropertyDescriptor & {
        initializer?: any;
    };
    /**
     * @en
     * The signature compatible with both TypeScript legacy decorator and Babel legacy decorator.
     * The `descriptor` argument will only appear in Babel case.
     * @zh
     * 该签名同时兼容 TypeScript legacy 装饰器以及 Babel legacy 装饰器。
     * `descriptor` 参数只会在 Babel 情况下出现。
     */
    export type LegacyPropertyDecorator = (target: Object, propertyKey: string | symbol, descriptor?: BabelPropertyDecoratorDescriptor) => void;
    /**
     * @en
     * A class(or property) decorator which does nothing.
     * @zh
     * 一个什么也不做的类（或属性）装饰器。
     */
    export const emptyDecorator: ClassDecorator & LegacyPropertyDecorator;
    /**
     * @en
     * A function which ignore all arguments and return the `emptyDecorator`.
     * @zh
     * 一个忽略所有参数并且返回 `emptyDecorator` 的函数。
     */
    export const emptyDecoratorFn: () => ClassDecorator & LegacyPropertyDecorator;
    /**
     * @en
     * Acts like `emptyDecorator` if called in form of `@x`;
     * acts like `emptyDecoratorFn` if called in form of `@x(...args)`.
     * @zh
     * 当以 `@x` 形式调用时表现如同 `emptyDecorator`，当以 `@x(...args)` 形式调用时表现如同 `emptyDecoratorFn`。
     */
    export const emptySmartClassDecorator: ClassDecorator & ((arg?: unknown) => ClassDecorator);
    /**
     * @en
     * Make a smart class decorator which can properly handle the following form decorator syntax:
     * - `@x`
     * - `@x(arg0)`
     *
     * and forward both the decorated class and the `arg0` (in first form, `arg0` is forward as `undefined`) to
     * `decorate`.
     * @zh
     * 创建一个智能类装饰器，它能正确地处理以下形式的装饰器语法：
     * - `@x`
     * - `@x(arg0)`
     *
     * 并且，将被装饰的类和 `arg0`（若是第一种形式，`arg0` 就是 `undefined`）一起转发给 `decorate`。
     * @param decorate
     */
    export function makeSmartClassDecorator<TArg>(decorate: <TFunction extends Function>(constructor: TFunction, arg?: TArg) => ReturnType<ClassDecorator>): ClassDecorator & ((arg?: TArg) => ClassDecorator);
    /**
     * @en
     * Make a function which accept an argument value and return a class decorator.
     * The decorator sets the editor property `propertyName`, on the decorated class, into that argument value.
     * @zh
     * 创建一个函数，该函数接受一个参数值并返回一个类装饰器。
     * 该装饰器将被装饰类的编辑器属性 `propertyName` 设置为该参数的值。
     * @param propertyName The editor property.
     */
    export function makeEditorClassDecoratorFn<TValue>(propertyName: string): (value: TValue) => ClassDecorator;
    /**
     * Make a smart class decorator.
     * The smart decorator sets the editor property `propertyName`, on the decorated class, into:
     * - `defaultValue` if the decorator is called with `@x` form, or
     * - the argument if the decorator is called with an argument, eg, the `@x(arg0)` form.
     * @zh
     * 创建一个智能类装饰器。
     * 该智能类装饰器将根据以下情况来设置被装饰类的编辑器属性 `propertyName`：
     * - 如果该装饰器是以 `@x` 形式调用的，该属性将被设置为 `defaultValue`。
     * - 如果该装饰器是以一个参数的形式，即 `@x(arg0)` 的形式调用的，该属性将被设置为传入的参数值。
     * @param propertyName The editor property.
     */
    export function makeSmartEditorClassDecorator<TValue>(propertyName: string, defaultValue?: TValue): ClassDecorator & ((arg?: TValue | undefined) => ClassDecorator);
    export const CACHE_KEY = "__ccclassCache__";
    export function getClassCache(ctor: any, decoratorName?: any): any;
    export function getSubDict(obj: any, key: any): any;
}
declare module "cocos/core/data/decorators/ccclass" {
    /**
     * @en Declare a standard ES6 or TS Class as a CCClass, please refer to the [document](https://docs.cocos.com/creator3d/manual/zh/scripting/ccclass.html)
     * @zh 将标准写法的 ES6 或者 TS Class 声明为 CCClass，具体用法请参阅[类型定义](https://docs.cocos.com/creator3d/manual/zh/scripting/ccclass.html)。
     * @param name - The class name used for serialization.
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass} = _decorator;
     *
     * // define a CCClass, omit the name
     *  @ccclass
     * class NewScript extends Component {
     *     // ...
     * }
     *
     * // define a CCClass with a name
     *  @ccclass('LoginData')
     * class LoginData {
     *     // ...
     * }
     * ```
     */
    export const ccclass: ((name?: string) => ClassDecorator) & ClassDecorator;
}
declare module "cocos/core/data/decorators/component" {
    /**
     * @en Declare that the current component relies on another type of component.
     * If the required component doesn't exist, the engine will create a new empty instance of the required component and add to the node.
     * @zh 为声明为 CCClass 的组件添加依赖的其它组件。当组件添加到节点上时，如果依赖的组件不存在，引擎将会自动将依赖组件添加到同一个节点，防止脚本出错。该设置在运行时同样有效。
     * @param requiredComponent The required component type
     * @example
     * ```ts
     * import {_decorator, Sprite, Component} from cc;
     * import {ccclass, requireComponent} from _decorator;
     *
     * @ccclass
     * @requireComponent(Sprite)
     * class SpriteCtrl extends Component {
     *     // ...
     * }
     * ```
     */
    export const requireComponent: (requiredComponent: Function) => ClassDecorator;
    /**
     * @en Set the component priority, it decides at which order the life cycle functions of components will be invoked. Smaller priority get invoked before larger priority.
     * This will affect `onLoad`, `onEnable`, `start`, `update` and `lateUpdate`, but `onDisable` and `onDestroy` won't be affected.
     * @zh 设置脚本生命周期方法调用的优先级。优先级小于 0 的组件将会优先执行，优先级大于 0 的组件将会延后执行。优先级仅会影响 onLoad, onEnable, start, update 和 lateUpdate，而 onDisable 和 onDestroy 不受影响。
     * @param priority - The execution order of life cycle methods for Component. Smaller priority get invoked before larger priority.
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, executionOrder} = _decorator;
     *
     * @ccclass
     * @executionOrder(1)
     * class CameraCtrl extends Component {
     *     // ...
     * }
     * ```
     */
    export const executionOrder: (priority: number) => ClassDecorator;
    /**
     * @en Forbid add multiple instances of the component to the same node.
     * @zh 防止多个相同类型（或子类型）的组件被添加到同一个节点。
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, disallowMultiple} = _decorator;
     *
     * @ccclass
     * @disallowMultiple
     * class CameraCtrl extends Component {
     *     // ...
     * }
     * ```
     */
    export const disallowMultiple: ClassDecorator & ((yes?: boolean) => ClassDecorator);
}
declare module "cocos/core/data/decorators/property" {
    /**
     * @category decorator
     */
    import { CCString, CCInteger, CCFloat, CCBoolean } from "cocos/core/data/utils/attribute";
    import { IExposedAttributes } from "cocos/core/data/utils/attribute-defines";
    import { LegacyPropertyDecorator } from "cocos/core/data/decorators/utils";
    export type SimplePropertyType = Function | string | typeof CCString | typeof CCInteger | typeof CCFloat | typeof CCBoolean;
    export type PropertyType = SimplePropertyType | SimplePropertyType[];
    /**
     * @zh CCClass 属性选项。
     * @en CCClass property options
     */
    export interface IPropertyOptions extends IExposedAttributes {
    }
    /**
     * @en Declare as a CCClass property with options
     * @zh 声明属性为 CCClass 属性。
     * @param options property options
     */
    export function property(options?: IPropertyOptions): LegacyPropertyDecorator;
    /**
     * @en Declare as a CCClass property with the property type
     * @zh 标注属性为 cc 属性。<br/>
     * 等价于`@property({type})`。
     * @param type A {{ccclass}} type or a {{ValueType}}
     */
    export function property(type: PropertyType): LegacyPropertyDecorator;
    /**
     * @en Declare as a CCClass property
     * @zh 标注属性为 cc 属性。<br/>
     * 等价于`@property()`。
     */
    export function property(...args: Parameters<LegacyPropertyDecorator>): void;
}
declare module "cocos/core/data/decorators/serializable" {
    /**
     * @category decorator
     */
    import { LegacyPropertyDecorator } from "cocos/core/data/decorators/utils";
    export const serializable: LegacyPropertyDecorator;
    export function formerlySerializedAs(name: string): LegacyPropertyDecorator;
    /**
     * @en
     * Marks the property as editor only.
     * @zh
     * 设置该属性仅在编辑器中生效。
     */
    export const editorOnly: LegacyPropertyDecorator;
}
declare module "cocos/core/data/decorators/editable" {
    import { LegacyPropertyDecorator } from "cocos/core/data/decorators/utils";
    /**
     * @en Makes a CCClass that inherit from component execute in edit mode.<br/>
     * By default, all components are only executed in play mode,<br/>
     * which means they will not have their callback functions executed while the Editor is in edit mode.<br/>
     * @zh 允许继承自 Component 的 CCClass 在编辑器里执行。<br/>
     * 默认情况下，所有 Component 都只会在运行时才会执行，也就是说它们的生命周期回调不会在编辑器里触发。
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, executeInEditMode} = _decorator;
     *
     *  @ccclass
     *  @executeInEditMode
     * class NewScript extends Component {
     *     // ...
     * }
     * ```
     */
    export const executeInEditMode: ClassDecorator & ((yes?: boolean) => ClassDecorator);
    /**
     * @en Add the current component to the specific menu path in `Add Component` selector of the inspector panel
     * @zh 将当前组件添加到组件菜单中，方便用户查找。例如 "Rendering/CameraCtrl"。
     * @param path - The path is the menu represented like a pathname. For example the menu could be "Rendering/CameraCtrl".
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, menu} = _decorator;
     *
     * @ccclass
     * @menu("Rendering/CameraCtrl")
     * class NewScript extends Component {
     *     // ...
     * }
     * ```
     */
    export const menu: (path: string) => ClassDecorator;
    /**
     * @en When {{executeInEditMode}} is set, this decorator will decide when a node with the component is on focus whether the editor should running in high FPS mode.
     * @zh 当指定了 "executeInEditMode" 以后，playOnFocus 可以在选中当前组件所在的节点时，提高编辑器的场景刷新频率到 60 FPS，否则场景就只会在必要的时候进行重绘。
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, playOnFocus, executeInEditMode} = _decorator;
     *
     * @ccclass
     * @executeInEditMode
     * @playOnFocus
     * class CameraCtrl extends Component {
     *     // ...
     * }
     * ```
     */
    export const playOnFocus: ClassDecorator & ((yes?: boolean) => ClassDecorator);
    /**
     * @en Use a customized inspector page in the **inspector**
     * @zh 自定义当前组件在 **属性检查器** 中渲染时所用的 UI 页面描述。
     * @param url The url of the page definition in js
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, inspector} = _decorator;
     *
     * @ccclass
     * @inspector("packages://inspector/inspectors/comps/camera-ctrl.js")
     * class NewScript extends Component {
     *     // ...
     * }
     * ```
     */
    export const inspector: (url: string) => ClassDecorator;
    /**
     * @en Define the icon of the component.
     * @zh 自定义当前组件在编辑器中显示的图标 url。
     * @param url
     * @private
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, icon} = _decorator;
     *
     *  @ccclass
     *  @icon("xxxx.png")
     * class NewScript extends Component {
     *     // ...
     * }
     * ```
     */
    export const icon: (url: string) => ClassDecorator;
    /**
     * @en Define the help documentation url, if given, the component section in the **inspector** will have a help documentation icon reference to the web page given.
     * @zh 指定当前组件的帮助文档的 url，设置过后，在 **属性检查器** 中就会出现一个帮助图标，用户点击将打开指定的网页。
     * @param url The url of the help documentation
     * @example
     * ```ts
     * import { _decorator, Component } from 'cc';
     * const {ccclass, help} = _decorator;
     *
     * @ccclass
     * @help("app://docs/html/components/spine.html")
     * class NewScript extends Component {
     *     // ...
     * }
     * ```
     */
    export const help: (url: string) => ClassDecorator;
    /**
     * @en
     * Enables the editor interoperability of the property.
     * @zh
     * 允许该属性与编辑器交互。
     */
    export const editable: LegacyPropertyDecorator;
    /**
     * @en
     * Sets the condition to show the property.
     * @zh
     * 设置在编辑器展示该属性的条件。
     * @param condition 展示条件，当返回 `true` 时展示；否则不展示。
     */
    export const visible: (condition: boolean | (() => boolean)) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the property to be read only in editor.
     * @zh
     * 设置该属性在编辑器中仅是可读的。
     */
    export const readOnly: LegacyPropertyDecorator;
    /**
     * @en
     * Sets the display name of the property in editor.
     * @zh
     * 设置该属性在编辑器中的显示名称。
     * @param text 显示名称。
     */
    export const displayName: (text: string) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the tooltip content of the property in editor.
     * @zh
     * 设置该属性在编辑器中的工具提示内容。
     * @param text 工具提示。
     */
    export const tooltip: (text: string) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the allowed range of the property in editor.
     * @zh
     * 设置该属性在编辑器中允许设置的范围。
     * @param values 范围。
     */
    export const range: (values: [number, number, number] | [number, number]) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the allowed min value of the property in editor.
     * @zh
     * 设置该属性在编辑器中允许的最小值。
     * @param value 最小值。
     */
    export const rangeMin: (value: number) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the allowed max value of the property in editor.
     * @zh
     * 设置该属性在编辑器中允许的最大值。
     * @param value 最大值。
     */
    export const rangeMax: (value: number) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the step of the property in editor.
     * @zh
     * 设置该属性在编辑器中的步进值。
     * @param value 步进值。
     */
    export const rangeStep: (value: number) => LegacyPropertyDecorator;
    /**
     * @en
     * Enable a slider be given to coordinate the property in editor.
     * @zh
     * 允许在编辑器中提供滑动条来调节值
     */
    export const slide: LegacyPropertyDecorator;
    /**
     * @en
     * Sets the display order of the property in editor.
     * @zh
     * 设置该属性在编辑器中的显示顺序。
     * @param order 显示顺序。
     */
    export const displayOrder: (order: number) => LegacyPropertyDecorator;
    /**
     * @en
     * Sets the unit of the property in editor.
     * @zh
     * 设置该属性在编辑器中的计量单位。
     * @param name 计量单位的名称。
     */
    export const unit: (name: 'lm' | 'lx' | 'cd/m²') => LegacyPropertyDecorator;
    /**
     * @en
     * Sets to convert the value into radian before feed it to the property in editor.
     * @zh
     * 设置在编辑器中赋值该属性前将值先转换为弧度制。
     */
    export const radian: LegacyPropertyDecorator;
    /**
     * @en
     * Enable multi-line display of the property in editor.
     * @zh
     * 允许在编辑器中对该属性进行多行显示。
     */
    export const multiline: LegacyPropertyDecorator;
    /**
     * @en
     * Sets the property so that it does not interop with the animation parts in editor.
     * @zh
     * 设置该属性不参与编辑器中动画相关的交互。
     */
    export const disallowAnimation: LegacyPropertyDecorator;
}
declare module "cocos/core/data/decorators/type" {
    import { PrimitiveType } from "cocos/core/data/utils/attribute";
    /**
     * @en Declare the property as integer
     * @zh 将该属性标记为整数。
     */
    export const integer: PropertyDecorator;
    /**
     * @en Declare the property as float
     * @zh 将该属性标记为浮点数。
     */
    export const float: PropertyDecorator;
    /**
     * @en Declare the property as boolean
     * @zh 将该属性标记为布尔值。
     */
    export const boolean: PropertyDecorator;
    /**
     * @en Declare the property as string
     * @zh 将该属性标记为字符串。
     */
    export const string: PropertyDecorator;
    /**
     * @en Declare the property as the given type
     * @zh 标记该属性的类型。
     * @param type
     */
    export function type(type: Function | [Function] | any): PropertyDecorator;
    export function type<T>(type: PrimitiveType<T> | [PrimitiveType<T>]): PropertyDecorator;
}
declare module "cocos/core/data/decorators/override" {
    /**
     * @category decorator
     */
    import { LegacyPropertyDecorator } from "cocos/core/data/decorators/utils";
    export const override: LegacyPropertyDecorator;
}
declare module "cocos/core/data/decorators/index" {
    export { ccclass } from "cocos/core/data/decorators/ccclass";
    export * from "cocos/core/data/decorators/component";
    export * from "cocos/core/data/decorators/serializable";
    export * from "cocos/core/data/decorators/editable";
    export * from "cocos/core/data/decorators/type";
    export { override } from "cocos/core/data/decorators/override";
}
declare module "cocos/core/event/event" {
    /**
     * 事件相关
     * @category event
     */
    /**
     * @en
     * Base class of all kinds of events.
     *
     * @zh
     * 所有事件对象的基类，包含事件相关基本信息。
     */
    export default class Event {
        /**
         * @en
         * Code for event without type.
         *
         * @zh
         * 没有类型的事件。
         */
        static NO_TYPE: string;
        /**
         * @en
         * The type code of Touch event.
         *
         * @zh
         * 触摸事件类型。
         */
        static TOUCH: string;
        /**
         * @en
         * The type code of Mouse event.
         *
         * @zh
         * 鼠标事件类型。
         */
        static MOUSE: string;
        /**
         * @en
         * The type code of Keyboard event.
         *
         * @zh
         * 键盘事件类型。
         */
        static KEYBOARD: string;
        /**
         * @en
         * The type code of Acceleration event.
         *
         * @zh
         * 加速器事件类型。
         */
        static ACCELERATION: string;
        /**
         * @en
         * Events not currently dispatched are in this phase.
         *
         * @zh
         * 尚未派发事件阶段。
         */
        static NONE: number;
        /**
         * @en
         * The capturing phase comprises the journey from the root to the last node before the event target's node
         * [markdown](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 捕获阶段，包括事件目标节点之前从根节点到最后一个节点的过程。
         */
        static CAPTURING_PHASE: number;
        /**
         * @en
         * The target phase comprises only the event target node
         * [markdown] (http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 目标阶段仅包括事件目标节点。
         */
        static AT_TARGET: number;
        /**
         * @en
         * The bubbling phase comprises any subsequent nodes encountered on the return trip to the root of the hierarchy
         * [markdown] (http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
         *
         * @zh
         * 冒泡阶段， 包括回程遇到到层次根节点的任何后续节点。
         */
        static BUBBLING_PHASE: number;
        /**
         * @en
         * The name of the event (case-sensitive), e.g. "click", "fire", or "submit".
         *
         * @zh
         * 事件类型。
         */
        type: string;
        /**
         * @en
         * Indicate whether the event bubbles up through the hierarchy or not.
         *
         * @zh
         * 表示该事件是否进行冒泡。
         */
        bubbles: boolean;
        /**
         * @en
         * A reference to the target to which the event was originally dispatched.
         *
         * @zh
         * 最初事件触发的目标。
         */
        target: Object | null;
        /**
         * @en
         * A reference to the currently registered target for the event.
         *
         * @zh
         * 当前目标。
         */
        currentTarget: Object | null;
        /**
         * @en
         * Indicates which phase of the event flow is currently being evaluated.
         * Returns an integer value represented by 4 constants:
         *  - Event.NONE = 0
         *  - Event.CAPTURING_PHASE = 1
         *  - Event.AT_TARGET = 2
         *  - Event.BUBBLING_PHASE = 3
         * The phases are explained in the [section 3.1, Event dispatch and DOM event flow]
         * [markdown](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow), of the DOM Level 3 Events specification.
         *
         * @zh
         * 事件阶段。
         */
        eventPhase: number;
        /**
         * @en
         * Stops propagation for current event.
         *
         * @zh
         * 停止传递当前事件。
         */
        propagationStopped: boolean;
        /**
         * @en
         * Stops propagation for current event immediately,
         * the event won't even be dispatched to the listeners attached in the current target.
         *
         * @zh
         * 立即停止当前事件的传递，事件甚至不会被分派到所连接的当前目标。
         */
        propagationImmediateStopped: boolean;
        /**
         * @param type - The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
         * @param bubbles - A boolean indicating whether the event bubbles up through the tree or not
         */
        constructor(type: string, bubbles?: boolean);
        /**
         * @en
         * Reset the event for being stored in the object pool.
         *
         * @zh
         * 重置事件对象以便在对象池中存储。
         */
        unuse(): void;
        /**
         * @en
         * Reinitialize the event for being used again after retrieved from the object pool.
         * @zh
         * 重新初始化让对象池中取出的事件可再次使用。
         * @param type - The name of the event (case-sensitive), e.g. "click", "fire", or "submit"
         * @param bubbles - A boolean indicating whether the event bubbles up through the tree or not
         */
        reuse(type: string, bubbles?: boolean): void;
        /**
         * @en
         * Checks whether the event has been stopped.
         *
         * @zh
         * 检查该事件是否已经停止传递。
         */
        isStopped(): boolean;
        /**
         * @en
         * Gets current target of the event                                                            <br/>
         * note: It only be available when the event listener is associated with node.                <br/>
         * It returns 0 when the listener is associated with fixed priority.
         * @zh
         * 获取当前目标节点
         * @returns - The target with which the event associates.
         */
        getCurrentTarget(): Object | null;
        /**
         * @en
         * Gets the event type.
         * @zh
         * 获取事件类型。
         */
        getType(): string;
    }
}
declare module "cocos/core/memop/pool" {
    /**
     * 可以自动分配内存的数据结构
     * @category memop
     */
    /**
     * @zh 对象池。
     */
    export class Pool<T> {
        private _ctor;
        private _elementsPerBatch;
        private _nextAvail;
        private _freepool;
        /**
         * 构造函数。
         * @param ctor 元素构造函数。
         * @param size 初始大小。
         */
        constructor(ctor: () => T, elementsPerBatch: number);
        /**
         * @zh 从对象池中取出一个对象。
         */
        alloc(): T;
        /**
         * @zh 将一个对象放回对象池中。
         * @param obj 释放的对象。
         */
        free(obj: T): void;
        /**
         * @zh 将一组对象放回对象池中。
         * @param objs 一组要释放的对象。
         */
        freeArray(objs: T[]): void;
        /**
         * 释放对象池中所有资源。
         * @param dtor 销毁回调，对每个释放的对象调用一次。
         */
        destroy(dtor?: (obj: T) => void): void;
    }
}
declare module "cocos/core/memop/recycle-pool" {
    /**
     * @category memop
     */
    /**
     * @zh 循环对象池。
     */
    export class RecyclePool<T = any> {
        private _fn;
        private _count;
        private _data;
        /**
         * 构造函数。
         * @param fn 对象构造函数。
         * @param size 初始大小。
         */
        constructor(fn: () => T, size: number);
        /**
         * @zh 对象池大小。
         */
        get length(): number;
        /**
         * @zh 对象池数组。
         */
        get data(): T[];
        /**
         * @zh 清空对象池。
         */
        reset(): void;
        /**
         * @zh 设置对象池大小。
         * @param size 对象池大小。
         */
        resize(size: number): void;
        /**
         * @zh 从对象池中取出一个对象。
         */
        add(): T;
        /**
         * @zh 释放对象池中的一个元素。
         * @param idx 释放对象的索引。
         */
        removeAt(idx: number): void;
    }
}
declare module "cocos/core/memop/cached-array" {
    /**
     * @category memop
     */
    /**
     * @zh
     * 缓存数组
     * 该数据结构内存只增不减，适用于处理内存常驻递增的分配策略
     */
    export class CachedArray<T> {
        /**
         * @zh
         * 实际存储的数据内容
         */
        array: T[];
        /**
         * @zh
         * 数组长度
         */
        length: number;
        /**
         * @zh
         * 比较函数
         */
        private _compareFn;
        /**
         * 构造函数
         * @param length 数组初始化长度
         * @param compareFn 比较函数
         */
        constructor(length: number, compareFn?: (a: T, b: T) => number);
        /**
         * @zh
         * 向数组中添加一个元素
         * @param item 数组元素
         */
        push(item: T): void;
        /**
         * @zh
         * 弹出数组最后一个元素
         * @param item 数组元素
         */
        pop(): T | undefined;
        /**
         * @zh
         * 得到数组中指定索引的元素
         * @param item 数组元素
         */
        get(idx: number): T;
        /**
         * @zh
         * 清空数组所有元素
         */
        clear(): void;
        /**
         * @zh
         * 排序数组
         */
        sort(): void;
        /**
         * @zh
         * 连接一个指定数组中的所有元素到当前数组末尾
         */
        concat(array: T[]): void;
        /**
         * @zh 删除指定位置的元素并将最后一个元素移动至该位置。
         * @param idx 数组索引。
         */
        fastRemove(idx: number): void;
        /**
         * @zh 返回某个数组元素对应的下标。
         * @param val 数组元素。
         */
        indexOf(val: T): number;
    }
}
declare module "cocos/core/memop/index" {
    /**
     * @hidden
     */
    export * from "cocos/core/memop/pool";
    export * from "cocos/core/memop/recycle-pool";
    export * from "cocos/core/memop/cached-array";
}
declare module "cocos/core/data/object" {
    /**
     * @en
     * The base class of most of all the objects in Fireball.
     * @zh
     * 大部分对象的基类。
     * @private
     */
    class CCObject {
        static _deferredDestroy(): void;
        _objFlags: number;
        protected _name: string;
        constructor(name?: string);
        /**
         * @en The name of the object.
         * @zh 该对象的名称。
         * @default ""
         * @example
         * ```
         * obj.name = "New Obj";
         * ```
         */
        get name(): string;
        set name(value: string);
        /**
         * @en
         * Indicates whether the object is not yet destroyed. (It will not be available after being destroyed)<br>
         * When an object's `destroy` is called, it is actually destroyed after the end of this frame.
         * So `isValid` will return false from the next frame, while `isValid` in the current frame will still be true.
         * If you want to determine whether the current frame has called `destroy`, use `isValid(obj, true)`,
         * but this is often caused by a particular logical requirements, which is not normally required.
         *
         * @zh
         * 表示该对象是否可用（被 destroy 后将不可用）。<br>
         * 当一个对象的 `destroy` 调用以后，会在这一帧结束后才真正销毁。<br>
         * 因此从下一帧开始 `isValid` 就会返回 false，而当前帧内 `isValid` 仍然会是 true。<br>
         * 如果希望判断当前帧是否调用过 `destroy`，请使用 `isValid(obj, true)`，不过这往往是特殊的业务需求引起的，通常情况下不需要这样。
         * @default true
         * @readOnly
         * @example
         * ```ts
         * import { Node, log } from 'cc';
         * const node = new Node();
         * log(node.isValid);    // true
         * node.destroy();
         * log(node.isValid);    // true, still valid in this frame
         * // after a frame...
         * log(node.isValid);    // false, destroyed in the end of last frame
         * ```
         */
        get isValid(): boolean;
        /**
         * @en
         * Destroy this Object, and release all its own references to other objects.<br/>
         * Actual object destruction will delayed until before rendering.
         * From the next frame, this object is not usable any more.
         * You can use `isValid(obj)` to check whether the object is destroyed before accessing it.
         * @zh
         * 销毁该对象，并释放所有它对其它对象的引用。<br/>
         * 实际销毁操作会延迟到当前帧渲染前执行。从下一帧开始，该对象将不再可用。
         * 您可以在访问对象之前使用 `isValid(obj)` 来检查对象是否已被销毁。
         * @return whether it is the first time the destroy being called
         * @example
         * ```
         * obj.destroy();
         * ```
         */
        destroy(): boolean;
        /**
         * Clear all references in the instance.
         *
         * NOTE: this method will not clear the getter or setter functions which defined in the instance of CCObject.
         *       You can override the _destruct method if you need, for example:
         *       _destruct: function () {
         *           for (var key in this) {
         *               if (this.hasOwnProperty(key)) {
         *                   switch (typeof this[key]) {
         *                       case 'string':
         *                           this[key] = '';
         *                           break;
         *                       case 'object':
         *                       case 'function':
         *                           this[key] = null;
         *                           break;
         *               }
         *           }
         *       }
         *
         */
        _destruct(): void;
        _destroyImmediate(): void;
    }
    namespace CCObject {
        enum Flags {
            Destroyed,
            /**
             * @en The object will not be saved.
             * @zh 该对象将不会被保存。
             */
            DontSave,
            /**
             * @en The object will not be saved when building a player.
             * @zh 构建项目时，该对象将不会被保存。
             */
            EditorOnly,
            Dirty,
            /**
             * @en Dont destroy automatically when loading a new scene.
             * @zh 加载一个新场景时，不自动删除该对象
             * @private
             */
            DontDestroy,
            PersistentMask,
            Destroying,
            /**
             * @en The node is deactivating.
             * @zh 节点正在反激活的过程中。
             * @private
             */
            Deactivating,
            /**
             * @en The lock node, when the node is locked, cannot be clicked in the scene.
             * @zh 锁定节点，锁定后场景内不能点击
             * @private
             */
            LockedInEditor,
            HideInHierarchy,
            IsPreloadStarted,
            IsOnLoadStarted,
            IsOnLoadCalled,
            IsOnEnableCalled,
            IsStartCalled,
            IsEditorOnEnableCalled,
            IsPositionLocked,
            IsRotationLocked,
            IsScaleLocked,
            IsAnchorLocked,
            IsSizeLocked
        }
    }
    export function isValid(value: any, strictMode?: boolean): boolean;
    export { CCObject };
}
declare module "cocos/core/event/callbacks-invoker" {
    class CallbackInfo {
        callback: Function;
        target: Object | undefined;
        once: boolean;
        set(callback: Function, target?: Object, once?: boolean): void;
        reset(): void;
        check(): boolean;
    }
    /**
     * @zh 事件监听器列表的简单封装。
     * @en A simple list of event callbacks
     */
    export class CallbackList {
        callbackInfos: Array<CallbackInfo | null>;
        isInvoking: boolean;
        containCanceled: boolean;
        /**
         * @zh 从列表中移除与指定目标相同回调函数的事件。
         * @en Remove the event listeners with the given callback from the list
         *
         * @param cb - The callback to be removed
         */
        removeByCallback(cb: Function): void;
        /**
         * @zh 从列表中移除与指定目标相同调用者的事件。
         * @en Remove the event listeners with the given target from the list
         * @param target
         */
        removeByTarget(target: Object): void;
        /**
         * @zh 移除指定编号事件。
         * @en Remove the event listener at the given index
         * @param index
         */
        cancel(index: number): void;
        /**
         * @zh 注销所有事件。
         * @en Cancel all event listeners
         */
        cancelAll(): void;
        /**
         * @zh 立即删除所有取消的回调。（在移除过程中会更加紧凑的排列数组）
         * @en Delete all canceled callbacks and compact array
         */
        purgeCanceled(): void;
        /**
         * @zh 清除并重置所有数据。
         * @en Clear all data
         */
        clear(): void;
    }
    export interface ICallbackTable {
        [x: string]: CallbackList | undefined;
    }
    /**
     * @zh CallbacksInvoker 用来根据事件名（Key）管理事件监听器列表并调用回调方法。
     * @en CallbacksInvoker is used to manager and invoke event listeners with different event keys,
     * each key is mapped to a CallbackList.
     */
    export class CallbacksInvoker {
        _callbackTable: ICallbackTable;
        /**
         * @zh 向一个事件名注册一个新的事件监听器，包含回调函数和调用者
         * @en Register an event listener to a given event key with callback and target.
         *
         * @param key - Event type
         * @param callback - Callback function when event triggered
         * @param target - Callback callee
         * @param once - Whether invoke the callback only once (and remove it)
         */
        on(key: string, callback: Function, target?: Object, once?: boolean): Function;
        /**
         * @zh 检查指定事件是否已注册回调。
         * @en Checks whether there is correspond event listener registered on the given event
         * @param key - Event type
         * @param callback - Callback function when event triggered
         * @param target - Callback callee
         */
        hasEventListener(key: string, callback?: Function, target?: Object): boolean;
        /**
         * @zh 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
         * @en Removes all callbacks registered in a certain event type or all callbacks registered with a certain target
         * @param keyOrTarget - The event type or target with which the listeners will be removed
         */
        removeAll(keyOrTarget: string | Object): void;
        /**
         * @zh 删除以指定事件，回调函数，目标注册的回调。
         * @en Remove event listeners registered with the given event key, callback and target
         * @param key - Event type
         * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
         * @param target - The callback callee of the event listener
         */
        off(key: string, callback?: Function, target?: Object): void;
        /**
         * @zh 派发一个指定事件，并传递需要的参数
         * @en Trigger an event directly with the event name and necessary arguments.
         * @param key - event type
         * @param arg0 - The first argument to be passed to the callback
         * @param arg1 - The second argument to be passed to the callback
         * @param arg2 - The third argument to be passed to the callback
         * @param arg3 - The fourth argument to be passed to the callback
         * @param arg4 - The fifth argument to be passed to the callback
         */
        emit(key: string, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        /**
         * 移除所有回调。
         */
        clear(): void;
    }
}
declare module "cocos/core/event/eventify" {
    type Constructor<T = {}> = new (...args: any[]) => T;
    type EventType = string;
    /**
     * @zh
     * 实现该接口的对象具有处理事件的能力。
     * @en
     * Objects those implement this interface have essentially the capability to process events.
     */
    export interface IEventified {
        /**
         * @zh 检查指定事件是否已注册回调。
         * @en Checks whether there is correspond event listener registered on the given event.
         * @param type - Event type.
         * @param callback - Callback function when event triggered.
         * @param target - Callback callee.
         */
        hasEventListener(type: string, callback?: Function, target?: object): boolean;
        /**
         * @en
         * Register an callback of a specific event type on the EventTarget.
         * This type of event should be triggered via `emit`.
         * @zh
         * 注册事件目标的特定事件类型回调。这种类型的事件应该被 `emit` 触发。
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param thisArg - The target (this object) to invoke the callback, can be null
         * @return - Just returns the incoming callback so you can save the anonymous function easier.
         * @example
         * import { log } from 'cc';
         * eventTarget.on('fire', function () {
         *     log("fire in the hole");
         * }, node);
         */
        on<TFunction extends Function>(type: EventType, callback: TFunction, thisArg?: any, once?: boolean): typeof callback;
        /**
         * @en
         * Register an callback of a specific event type on the EventTarget,
         * the callback will remove itself after the first time it is triggered.
         * @zh
         * 注册事件目标的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         * @example
         * import { log } from 'cc';
         * eventTarget.once('fire', function () {
         *     log("this is the callback and will be invoked only once");
         * }, node);
         */
        once<TFunction extends Function>(type: EventType, callback: TFunction, thisArg?: any): typeof callback;
        /**
         * @en
         * Removes the listeners previously registered with the same type, callback, target and or useCapture,
         * if only type is passed as parameter, all listeners registered with that type will be removed.
         * @zh
         * 删除之前用同类型，回调，目标或 useCapture 注册的事件监听器，如果只传递 type，将会删除 type 类型的所有事件监听器。
         *
         * @param type - A string representing the event type being removed.
         * @param callback - The callback to remove.
         * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
         * @example
         * import { log } from 'cc';
         * // register fire eventListener
         * var callback = eventTarget.on('fire', function () {
         *     log("fire in the hole");
         * }, target);
         * // remove fire event listener
         * eventTarget.off('fire', callback, target);
         * // remove all fire event listeners
         * eventTarget.off('fire');
         */
        off<TFunction extends Function>(type: EventType, callback?: TFunction, thisArg?: any): void;
        /**
         * @en Removes all callbacks previously registered with the same target (passed as parameter).
         * This is not for removing all listeners in the current event target,
         * and this is not for removing all listeners the target parameter have registered.
         * It's only for removing all listeners (callback and target couple) registered on the current event target by the target parameter.
         * @zh 在当前 EventTarget 上删除指定目标（target 参数）注册的所有事件监听器。
         * 这个函数无法删除当前 EventTarget 的所有事件监听器，也无法删除 target 参数所注册的所有事件监听器。
         * 这个函数只能删除 target 参数在当前 EventTarget 上注册的所有事件监听器。
         * @param typeOrTarget - The target to be searched for all related listeners
         */
        targetOff(typeOrTarget: string | object): void;
        /**
         * @zh 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
         * @en Removes all callbacks registered in a certain event type or all callbacks registered with a certain target
         * @param typeOrTarget - The event type or target with which the listeners will be removed
         */
        removeAll(typeOrTarget: string | object): void;
        /**
         * @zh 派发一个指定事件，并传递需要的参数
         * @en Trigger an event directly with the event name and necessary arguments.
         * @param type - event type
         * @param args - Arguments when the event triggered
         */
        emit(type: EventType, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
    }
    /**
     * @en Generate a new class from the given base class, after polyfill all functionalities in [[IEventified]] as if it's extended from [[EventTarget]]
     * @zh 生成一个类，该类继承自指定的基类，并以和 [[EventTarget]] 等同的方式实现了 [[IEventified]] 的所有接口。
     * @param base The base class
     * @example
     * ```ts
     * class Base { say() { console.log('Hello!'); } }
     * class MyClass extends Eventify(Base) { }
     * function (o: MyClass) {
     *     o.say(); // Ok: Extend from `Base`
     *     o.emit('sing', 'The ghost'); // Ok: `MyClass` implements IEventified
     * }
     * ```
     */
    export function Eventify<TBase>(base: Constructor<TBase>): Constructor<TBase & IEventified>;
}
declare module "cocos/core/event/event-target" {
    class Empty {
    }
    /**
     * @en
     * EventTarget is an object to which an event is dispatched when something has occurred.
     * [[Node]]s are the most common event targets, but other objects can be event targets too.
     * If a class cannot extend from EventTarget, it can consider using [[Eventify]].
     *
     * @zh
     * 事件目标是具有注册监听器、派发事件能力的类，[[Node]] 是最常见的事件目标，
     * 但是其他类也可以继承自事件目标以获得管理监听器和派发事件的能力。
     * 如果无法继承自 EventTarget，也可以使用 [[Eventify]]
     */
    export const EventTarget: new (...args: any[]) => Empty & import("cocos/core/event/eventify").IEventified;
    export type EventTarget = InstanceType<typeof EventTarget>;
}
declare module "cocos/core/event/index" {
    /**
     * @hidden
     */
    export { default as Event } from "cocos/core/event/event";
    export { EventTarget } from "cocos/core/event/event-target";
    export { Eventify } from "cocos/core/event/eventify";
}
declare module "cocos/core/assets/raw-asset" {
    import { CCObject } from "cocos/core/data/object";
    /**
     * 原生资源的基类。内部使用。
     * @private
     */
    export class RawAsset extends CCObject {
        /**
         * 内部使用。
         */
        static isRawAssetType(ctor: Function): boolean;
        /**
         * 内部使用。
         */
        _uuid: string;
        constructor(...args: ConstructorParameters<typeof CCObject>);
    }
}
declare module "cocos/core/math/type-define" {
    /**
     * @category core/math
     */
    /**
     * @hidden
     */
    export interface IColorLike {
        r: number;
        g: number;
        b: number;
        a: number;
        _val: number;
    }
    export interface IMat3Like {
        m00: number;
        m01: number;
        m02: number;
        m03: number;
        m04: number;
        m05: number;
        m06: number;
        m07: number;
        m08: number;
    }
    export interface IMat4Like {
        m00: number;
        m01: number;
        m02: number;
        m03: number;
        m04: number;
        m05: number;
        m06: number;
        m07: number;
        m08: number;
        m09: number;
        m10: number;
        m11: number;
        m12: number;
        m13: number;
        m14: number;
        m15: number;
    }
    export interface IQuatLike {
        x: number;
        y: number;
        z: number;
        w: number;
    }
    export interface IRectLike {
        x: number;
        y: number;
        width: number;
        height: number;
    }
    export interface ISizeLike {
        width: number;
        height: number;
    }
    export interface IVec2Like {
        x: number;
        y: number;
    }
    export interface IVec3Like {
        x: number;
        y: number;
        z: number;
    }
    export interface IVec4Like {
        x: number;
        y: number;
        z: number;
        w: number;
    }
}
declare module "cocos/core/math/utils" {
    /**
     * @category core/math
     */
    import { IVec3Like } from "cocos/core/math/type-define";
    export const EPSILON = 0.000001;
    /**
     * @en Tests whether or not the arguments have approximately the same value, within an absolute<br/>
     * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less<br/>
     * than or equal to 1.0, and a relative tolerance is used for larger values)
     * @zh 在glMatrix的绝对或相对容差范围内，测试参数是否具有近似相同的值。<br/>
     * EPSILON(小于等于1.0的值采用绝对公差，大于1.0的值采用相对公差)
     * @param a The first number to test.
     * @param b The second number to test.
     * @return True if the numbers are approximately equal, false otherwise.
     */
    export function equals(a: number, b: number): boolean;
    /**
     * @en Tests whether or not the arguments have approximately the same value by given maxDiff<br/>
     * @zh 通过给定的最大差异，测试参数是否具有近似相同的值。
     * @param a The first number to test.
     * @param b The second number to test.
     * @param maxDiff Maximum difference.
     * @return True if the numbers are approximately equal, false otherwise.
     */
    export function approx(a: number, b: number, maxDiff: number): boolean;
    /**
     * @en Clamps a value between a minimum float and maximum float value.<br/>
     * @zh 返回最小浮点数和最大浮点数之间的一个数值。可以使用 clamp 函数将不断变化的数值限制在范围内。
     * @param val
     * @param min
     * @param max
     */
    export function clamp(val: number, min: number, max: number): number;
    /**
     * @en Clamps a value between 0 and 1.<br/>
     * @zh 将值限制在0和1之间。
     * @param val
     */
    export function clamp01(val: number): number;
    /**
     * @param from
     * @param to
     * @param ratio - The interpolation coefficient.
     */
    export function lerp(from: number, to: number, ratio: number): number;
    /**
     * @en Convert Degree To Radian<br/>
     * @zh 把角度换算成弧度。
     * @param {Number} a Angle in Degrees
     */
    export function toRadian(a: number): number;
    /**
     * @en Convert Radian To Degree<br/>
     * @zh 把弧度换算成角度。
     * @param {Number} a Angle in Radian
     */
    export function toDegree(a: number): number;
    /**
     * @method random
     */
    export const random: () => number;
    /**
     * @en Returns a floating-point random number between min (inclusive) and max (exclusive).<br/>
     * @zh 返回最小(包含)和最大(不包含)之间的浮点随机数。
     * @method randomRange
     * @param min
     * @param max
     * @return The random number.
     */
    export function randomRange(min: number, max: number): number;
    /**
     * @en Returns a random integer between min (inclusive) and max (exclusive).<br/>
     * @zh 返回最小(包含)和最大(不包含)之间的随机整数。
     * @param min
     * @param max
     * @return The random integer.
     */
    export function randomRangeInt(min: number, max: number): number;
    /**
     * Linear congruential generator using Hull-Dobell Theorem.
     *
     * @param seed The random seed.
     * @return The pseudo random.
     */
    export function pseudoRandom(seed: number): number;
    /**
     * Returns a floating-point pseudo-random number between min (inclusive) and max (exclusive).
     *
     * @param seed
     * @param min
     * @param max
     * @return The random number.
     */
    export function pseudoRandomRange(seed: number, min: number, max: number): number;
    /**
     * @en Returns a pseudo-random integer between min (inclusive) and max (exclusive).<br/>
     * @zh 返回最小(包含)和最大(不包含)之间的浮点伪随机数。
     * @param seed
     * @param min
     * @param max
     * @return The random integer.
     */
    export function pseudoRandomRangeInt(seed: number, min: number, max: number): number;
    /**
     * Returns the next power of two for the value.<br/>
     *
     * @param val
     * @return The the next power of two.
     */
    export function nextPow2(val: number): number;
    /**
     * @en Returns float remainder for t / length.<br/>
     * @zh 返回t / length的浮点余数。
     * @param t Time start at 0.
     * @param length Time of one cycle.
     * @return The Time wrapped in the first cycle.
     */
    export function repeat(t: number, length: number): number;
    /**
     * Returns time wrapped in ping-pong mode.
     *
     * @param t Time start at 0.
     * @param length Time of one cycle.
     * @return The time wrapped in the first cycle.
     */
    export function pingPong(t: number, length: number): number;
    /**
     * @en Returns ratio of a value within a given range.<br/>
     * @zh 返回给定范围内的值的比率。
     * @param from Start value.
     * @param to End value.
     * @param value Given value.
     * @return The ratio between [from, to].
     */
    export function inverseLerp(from: number, to: number, value: number): number;
    /**
     * @zh 对所有分量的绝对值进行比较大小，返回绝对值最大的分量。
     * @param v 类 Vec3 结构
     * @returns 绝对值最大的分量
     */
    export function absMaxComponent(v: IVec3Like): number;
    /**
     * @zh 对 a b 的绝对值进行比较大小，返回绝对值最大的值。
     * @param a number
     * @param b number
     */
    export function absMax(a: number, b: number): number;
}
declare module "cocos/core/math/vec3" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Mat4 } from "cocos/core/math/mat4";
    import { IMat3Like, IMat4Like, IQuatLike, IVec3Like } from "cocos/core/math/type-define";
    /**
     * 三维向量。
     */
    export class Vec3 extends ValueType {
        static UNIT_X: Readonly<Vec3>;
        static UNIT_Y: Readonly<Vec3>;
        static UNIT_Z: Readonly<Vec3>;
        static RIGHT: Readonly<Vec3>;
        static UP: Readonly<Vec3>;
        static FORWARD: Readonly<Vec3>;
        static ZERO: Readonly<Vec3>;
        static ONE: Readonly<Vec3>;
        static NEG_ONE: Readonly<Vec3>;
        /**
         * @zh 将目标赋值为零向量
         */
        static zero<Out extends IVec3Like>(out: Out): Out;
        /**
         * @zh 获得指定向量的拷贝
         */
        static clone<Out extends IVec3Like>(a: Out): Vec3;
        /**
         * @zh 复制目标向量
         */
        static copy<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like): Out;
        /**
         * @zh 设置向量值
         */
        static set<Out extends IVec3Like>(out: Out, x: number, y: number, z: number): Out;
        /**
         * @zh 逐元素向量加法
         */
        static add<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量减法
         */
        static subtract<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量乘法 (分量积)
         */
        static multiply<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量除法
         */
        static divide<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量向上取整
         */
        static ceil<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 逐元素向量向下取整
         */
        static floor<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 逐元素向量最小值
         */
        static min<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量最大值
         */
        static max<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量四舍五入取整
         */
        static round<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 向量标量乘法
         */
        static multiplyScalar<Out extends IVec3Like, Vec3Like extends IVec3Like>(out: Out, a: Vec3Like, b: number): Out;
        /**
         * @zh 逐元素向量乘加: A + B * scale
         */
        static scaleAndAdd<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, scale: number): Out;
        /**
         * @zh 求两向量的欧氏距离
         */
        static distance(a: IVec3Like, b: IVec3Like): number;
        /**
         * @zh 求两向量的欧氏距离平方
         */
        static squaredDistance(a: IVec3Like, b: IVec3Like): number;
        /**
         * @zh 求向量长度
         */
        static len(a: IVec3Like): number;
        /**
         * @zh 求向量长度平方
         */
        static lengthSqr(a: IVec3Like): number;
        /**
         * @zh 逐元素向量取负
         */
        static negate<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
         */
        static invert<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 0
         */
        static invertSafe<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 归一化向量
         */
        static normalize<Out extends IVec3Like>(out: Out, a: IVec3Like): Out;
        /**
         * @zh 向量点积（数量积）
         */
        static dot<Out extends IVec3Like>(a: Out, b: IVec3Like): number;
        /**
         * @zh 向量叉积（向量积）
         */
        static cross<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * @zh 逐元素向量线性插值： A + t * (B - A)
         */
        static lerp<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like, t: number): Out;
        /**
         * @zh 生成一个在单位球体上均匀分布的随机向量
         * @param scale 生成的向量长度
         */
        static random<Out extends IVec3Like>(out: Out, scale?: number): Out;
        /**
         * @zh 向量与四维矩阵乘法，默认向量第四位为 1。
         */
        static transformMat4<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
        /**
         * @zh 向量与四维矩阵乘法，默认向量第四位为 0。
         */
        static transformMat4Normal<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat4Like): Out;
        /**
         * @zh 向量与三维矩阵乘法
         */
        static transformMat3<Out extends IVec3Like>(out: Out, a: IVec3Like, m: IMat3Like): Out;
        /**
         * @zh 向量仿射变换
         */
        static transformAffine<Out extends IVec3Like>(out: Out, v: IVec3Like, m: IMat4Like): Out;
        /**
         * @zh 向量四元数乘法
         */
        static transformQuat<Out extends IVec3Like>(out: Out, a: IVec3Like, q: IQuatLike): Out;
        /**
         * @zh 以缩放 -> 旋转 -> 平移顺序变换向量
         */
        static transformRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
        /**
         * @zh 以平移 -> 旋转 -> 缩放顺序逆变换向量
         */
        static transformInverseRTS<Out extends IVec3Like>(out: Out, a: IVec3Like, r: IQuatLike, t: IVec3Like, s: IVec3Like): Out;
        /**
         * @zh 绕 X 轴旋转向量指定弧度
         * @param v 待旋转向量
         * @param o 旋转中心
         * @param a 旋转弧度
         */
        static rotateX<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
        /**
         * @zh 绕 Y 轴旋转向量指定弧度
         * @param v 待旋转向量
         * @param o 旋转中心
         * @param a 旋转弧度
         */
        static rotateY<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
        /**
         * @zh 绕 Z 轴旋转向量指定弧度
         * @param v 待旋转向量
         * @param o 旋转中心
         * @param a 旋转弧度
         */
        static rotateZ<Out extends IVec3Like>(out: Out, v: IVec3Like, o: IVec3Like, a: number): Out;
        /**
         * @zh 向量转数组
         * @param ofs 数组起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, v: IVec3Like, ofs?: number): Out;
        /**
         * @zh 数组转向量
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IVec3Like>(out: Out, arr: IWritableArrayLike<number>, ofs?: number): Out;
        /**
         * @zh 向量等价判断
         */
        static strictEquals(a: IVec3Like, b: IVec3Like): boolean;
        /**
         * @zh 排除浮点数误差的向量近似等价判断
         */
        static equals(a: IVec3Like, b: IVec3Like, epsilon?: number): boolean;
        /**
         * @zh 求两向量夹角弧度
         */
        static angle(a: IVec3Like, b: IVec3Like): number;
        /**
         * @zh 计算向量在指定平面上的投影
         * @param a 待投影向量
         * @param n 指定平面的法线
         */
        static projectOnPlane<Out extends IVec3Like>(out: Out, a: IVec3Like, n: IVec3Like): Out;
        /**
         * @zh 计算向量在指定向量上的投影
         * @param a 待投影向量
         * @param n 目标向量
         */
        static project<Out extends IVec3Like>(out: Out, a: IVec3Like, b: IVec3Like): Out;
        /**
         * x 分量。
         */
        x: number;
        /**
         * y 分量。
         */
        y: number;
        /**
         * z 分量。
         */
        z: number;
        constructor(v: Vec3);
        constructor(x?: number, y?: number, z?: number);
        /**
         * @zh 克隆当前向量。
         */
        clone(): Vec3;
        /**
         * @zh 设置当前向量使其与指定向量相等。
         * @param other 相比较的向量。
         * @returns `this`
         */
        set(other: Vec3): any;
        /**
         * @zh 设置当前向量的具体分量值。
         * @param x 要设置的 x 分量的值
         * @param y 要设置的 y 分量的值
         * @param z 要设置的 z 分量的值
         * @returns `this`
         */
        set(x?: number, y?: number, z?: number): any;
        /**
         * @zh 判断当前向量是否在误差范围内与指定向量相等。
         * @param other 相比较的向量。
         * @param epsilon 允许的误差，应为非负数。
         * @returns 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals(other: Vec3, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
         * @param x 相比较的向量的 x 分量。
         * @param y 相比较的向量的 y 分量。
         * @param z 相比较的向量的 z 分量。
         * @param epsilon 允许的误差，应为非负数。
         * @returns 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals3f(x: number, y: number, z: number, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否与指定向量相等。
         * @param other 相比较的向量。
         * @returns 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Vec3): boolean;
        /**
         * @zh 判断当前向量是否与指定分量的向量相等。
         * @param x 指定向量的 x 分量。
         * @param y 指定向量的 y 分量。
         * @param z 指定向量的 z 分量。
         * @returns 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals3f(x: number, y: number, z: number): boolean;
        /**
         * @zh 返回当前向量的字符串表示。
         * @returns 当前向量的字符串表示。
         */
        toString(): string;
        /**
         * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
         * @param to 目标向量。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Vec3, ratio: number): this;
        /**
         * @zh 向量加法。将当前向量与指定向量的相加
         * @param other 指定的向量。
         */
        add(other: Vec3): this;
        /**
         * @zh 向量加法。将当前向量与指定分量的向量相加
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         */
        add3f(x: number, y: number, z: number): this;
        /**
         * @zh 向量减法。将当前向量减去指定向量的结果。
         * @param other 减数向量。
         */
        subtract(other: Vec3): this;
        /**
         * @zh 向量减法。将当前向量减去指定分量的向量
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         */
        subtract3f(x: number, y: number, z: number): this;
        /**
         * @zh 向量数乘。将当前向量数乘指定标量
         * @param scalar 标量乘数。
         */
        multiplyScalar(scalar: number): this;
        /**
         * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
         * @param other 指定的向量。
         */
        multiply(other: Vec3): this;
        /**
         * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         */
        multiply3f(x: number, y: number, z: number): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param other 指定的向量
         */
        divide(other: Vec3): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         */
        divide3f(x: number, y: number, z: number): this;
        /**
         * @zh 将当前向量的各个分量取反
         */
        negative(): this;
        /**
         * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
         * @param minInclusive 每个分量都代表了对应分量允许的最小值。
         * @param maxInclusive 每个分量都代表了对应分量允许的最大值。
         * @returns `this`
         */
        clampf(minInclusive: Vec3, maxInclusive: Vec3): this;
        /**
         * @zh 向量点乘。
         * @param other 指定的向量。
         * @returns 当前向量与指定向量点乘的结果。
         */
        dot(other: Vec3): number;
        /**
         * @zh 向量叉乘。将当前向量左叉乘指定向量
         * @param other 指定的向量。
         */
        cross(other: Vec3): this;
        /**
         * @zh 计算向量的长度（模）。
         * @returns 向量的长度（模）。
         */
        length(): number;
        /**
         * @zh 计算向量长度（模）的平方。
         * @returns 向量长度（模）的平方。
         */
        lengthSqr(): number;
        /**
         * @zh 将当前向量归一化
         */
        normalize(): this;
        /**
         * @zh 将当前向量视为 w 分量为 1 的四维向量，应用四维矩阵变换到当前矩阵
         * @param matrix 变换矩阵。
         */
        transformMat4(matrix: Mat4): this;
    }
    export function v3(other: Vec3): Vec3;
    export function v3(x?: number, y?: number, z?: number): Vec3;
}
declare module "cocos/core/math/quat" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Mat3 } from "cocos/core/math/mat3";
    import { IQuatLike, IVec3Like } from "cocos/core/math/type-define";
    import { Vec3 } from "cocos/core/math/vec3";
    /**
     * 四元数。
     */
    export class Quat extends ValueType {
        static IDENTITY: Readonly<Quat>;
        /**
         * @zh 获得指定四元数的拷贝
         */
        static clone<Out extends IQuatLike>(a: Out): Quat;
        /**
         * @zh 复制目标四元数
         */
        static copy<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
        /**
         * @zh 设置四元数值
         */
        static set<Out extends IQuatLike>(out: Out, x: number, y: number, z: number, w: number): Out;
        /**
         * @zh 将目标赋值为单位四元数
         */
        static identity<Out extends IQuatLike>(out: Out): Out;
        /**
         * @zh 设置四元数为两向量间的最短路径旋转，默认两向量都已归一化
         */
        static rotationTo<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, a: VecLike, b: VecLike): Out;
        /**
         * @zh 获取四元数的旋转轴和旋转弧度
         * @param outAxis 旋转轴输出
         * @param q 源四元数
         * @return 旋转弧度
         */
        static getAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(outAxis: VecLike, q: Out): number;
        /**
         * @zh 四元数乘法
         */
        static multiply<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2): Out;
        /**
         * @zh 四元数标量乘法
         */
        static multiplyScalar<Out extends IQuatLike>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 四元数乘加：A + B * scale
         */
        static scaleAndAdd<Out extends IQuatLike>(out: Out, a: Out, b: Out, scale: number): Out;
        /**
         * @zh 绕 X 轴旋转指定四元数
         * @param rad 旋转弧度
         */
        static rotateX<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 绕 Y 轴旋转指定四元数
         * @param rad 旋转弧度
         */
        static rotateY<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 绕 Z 轴旋转指定四元数
         * @param rad 旋转弧度
         */
        static rotateZ<Out extends IQuatLike>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 绕世界空间下指定轴旋转四元数
         * @param axis 旋转轴，默认已归一化
         * @param rad 旋转弧度
         */
        static rotateAround<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
        /**
         * @zh 绕本地空间下指定轴旋转四元数
         * @param axis 旋转轴
         * @param rad 旋转弧度
         */
        static rotateAroundLocal<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, rot: Out, axis: VecLike, rad: number): Out;
        /**
         * @zh 根据 xyz 分量计算 w 分量，默认已归一化
         */
        static calculateW<Out extends IQuatLike>(out: Out, a: Out): Out;
        /**
         * @zh 四元数点积（数量积）
         */
        static dot<Out extends IQuatLike>(a: Out, b: Out): number;
        /**
         * @zh 逐元素线性插值： A + t * (B - A)
         */
        static lerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, t: number): Out;
        /**
         * @zh 四元数球面插值
         */
        static slerp<Out extends IQuatLike, QuatLike_1 extends IQuatLike, QuatLike_2 extends IQuatLike>(out: Out, a: QuatLike_1, b: QuatLike_2, t: number): Out;
        /**
         * @zh 带两个控制点的四元数球面插值
         */
        static sqlerp<Out extends IQuatLike>(out: Out, a: Out, b: Out, c: Out, d: Out, t: number): Out;
        /**
         * @zh 四元数求逆
         */
        static invert<Out extends IQuatLike, QuatLike extends IQuatLike>(out: Out, a: QuatLike): Out;
        /**
         * @zh 求共轭四元数，对单位四元数与求逆等价，但更高效
         */
        static conjugate<Out extends IQuatLike>(out: Out, a: Out): Out;
        /**
         * @zh 求四元数长度
         */
        static len<Out extends IQuatLike>(a: Out): number;
        /**
         * @zh 求四元数长度平方
         */
        static lengthSqr<Out extends IQuatLike>(a: Out): number;
        /**
         * @zh 归一化四元数
         */
        static normalize<Out extends IQuatLike>(out: Out, a: Out): Out;
        /**
         * @zh 根据本地坐标轴朝向计算四元数，默认三向量都已归一化且相互垂直
         */
        static fromAxes<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, xAxis: VecLike, yAxis: VecLike, zAxis: VecLike): Out;
        /**
         * @zh 根据视口的前方向和上方向计算四元数
         * @param view 视口面向的前方向，必须归一化
         * @param up 视口的上方向，必须归一化，默认为 (0, 1, 0)
         */
        static fromViewUp<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
        /**
         * @zh 根据旋转轴和旋转弧度计算四元数
         */
        static fromAxisAngle<Out extends IQuatLike, VecLike extends IVec3Like>(out: Out, axis: VecLike, rad: number): Out;
        /**
         * @zh 根据三维矩阵信息计算四元数，默认输入矩阵不含有缩放信息
         */
        static fromMat3<Out extends IQuatLike>(out: Out, m: Mat3): Out;
        /**
         * @zh 根据欧拉角信息计算四元数，旋转顺序为 YZX
         */
        static fromEuler<Out extends IQuatLike>(out: Out, x: number, y: number, z: number): Out;
        /**
         * @zh 返回定义此四元数的坐标系 X 轴向量
         */
        static toAxisX(out: IVec3Like, q: IQuatLike): IVec3Like;
        /**
         * @zh 返回定义此四元数的坐标系 Y 轴向量
         */
        static toAxisY(out: IVec3Like, q: IQuatLike): IVec3Like;
        /**
         * @zh 返回定义此四元数的坐标系 Z 轴向量
         */
        static toAxisZ(out: IVec3Like, q: IQuatLike): IVec3Like;
        /**
         * @zh 根据四元数计算欧拉角，返回角度 x, y 在 [-180, 180] 区间内, z 默认在 [-90, 90] 区间内，旋转顺序为 YZX
         * @param outerZ z 取值范围区间改为 [-180, -90] U [90, 180]
         */
        static toEuler(out: IVec3Like, q: IQuatLike, outerZ?: boolean): IVec3Like;
        /**
         * @zh 四元数转数组
         * @param ofs 数组内的起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, q: IQuatLike, ofs?: number): Out;
        /**
         * @zh 数组转四元数
         * @param ofs 数组起始偏移量
         */
        static fromArray(out: IQuatLike, arr: IWritableArrayLike<number>, ofs?: number): IQuatLike;
        /**
         * @zh 四元数等价判断
         */
        static strictEquals(a: IQuatLike, b: IQuatLike): boolean;
        /**
         * @zh 排除浮点数误差的四元数近似等价判断
         */
        static equals(a: IQuatLike, b: IQuatLike, epsilon?: number): boolean;
        /**
         * x 分量。
         */
        x: number;
        /**
         * y 分量。
         */
        y: number;
        /**
         * z 分量。
         */
        z: number;
        /**
         * w 分量。
         */
        w: number;
        constructor(other: Quat);
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @zh 克隆当前四元数。
         */
        clone(): Quat;
        /**
         * @zh 设置当前四元数使其与指定四元数相等。
         * @param other 相比较的四元数。
         * @returns `this`
         */
        set(other: Quat): Quat;
        /**
         * @zh 设置当前四元数指定元素值。
         * @param x 四元数 x 元素值
         * @param y 四元数 y 元素值
         * @param z 四元数 z 元素值
         * @param w 四元数 w 元素值
         * @returns `this`
         */
        set(x?: number, y?: number, z?: number, w?: number): Quat;
        /**
         * @zh 判断当前向量是否在误差范围内与指定向量相等。
         * @param other 相比较的向量。
         * @param epsilon 允许的误差，应为非负数。
         * @returns 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals(other: Quat, epsilon?: number): boolean;
        /**
         * @zh 判断当前四元数是否与指定四元数相等。
         * @param other 相比较的四元数。
         * @returns 两四元数的各分量都相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Quat): boolean;
        /**
         * @zh 将当前四元数转化为欧拉角（x-y-z）并赋值给出口向量。
         * @param out 出口向量。
         */
        getEulerAngles(out: Vec3): IVec3Like;
        /**
         * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做线性插值。
         * @param to 目标四元数。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Quat, ratio: number): this;
        /**
         * @zh 根据指定的插值比率，从当前四元数到目标四元数之间做球面插值。
         * @param to 目标四元数。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        slerp(to: Quat, ratio: number): this;
        /**
         * @zh 求四元数长度
         */
        length(): number;
        /**
         * @zh 求四元数长度平方
         */
        lengthSqr(): number;
    }
    export function quat(other: Quat): Quat;
    export function quat(x?: number, y?: number, z?: number, w?: number): Quat;
}
declare module "cocos/core/math/mat3" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Quat } from "cocos/core/math/quat";
    import { IMat3Like, IMat4Like, IQuatLike, IVec2Like, IVec3Like } from "cocos/core/math/type-define";
    import { Vec3 } from "cocos/core/math/vec3";
    /**
     * 表示三维（3x3）矩阵。
     */
    export class Mat3 extends ValueType {
        static IDENTITY: Readonly<Mat3>;
        /**
         * @zh 获得指定矩阵的拷贝
         */
        static clone<Out extends IMat3Like>(a: Out): Mat3;
        /**
         * @zh 复制目标矩阵
         */
        static copy<Out extends IMat3Like>(out: Out, a: Out): Out;
        /**
         * @zh 设置矩阵值
         */
        static set<Out extends IMat3Like>(out: Out, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): Out;
        /**
         * @zh 将目标赋值为单位矩阵
         */
        static identity<Out extends IMat3Like>(out: Out): Out;
        /**
         * @zh 转置矩阵
         */
        static transpose<Out extends IMat3Like>(out: Out, a: Out): Out;
        /**
         * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
         */
        static invert<Out extends IMat3Like>(out: Out, a: Out): Out;
        /**
         * @zh 矩阵行列式
         */
        static determinant<Out extends IMat3Like>(a: Out): number;
        /**
         * @zh 矩阵乘法
         */
        static multiply<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 取四阶矩阵的前三阶，与三阶矩阵相乘
         */
        static multiplyMat4<Out extends IMat3Like>(out: Out, a: Out, b: IMat4Like): Out;
        /**
         * @zh 在给定矩阵变换基础上加入变换
         * @deprecated 将在 1.2 移除，请转用 `Mat3.transform` 方法。
         */
        static transfrom<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): void;
        /**
         * @zh 在给定矩阵变换基础上加入变换
         */
        static transform<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
        /**
         * @zh 在给定矩阵变换基础上加入新缩放变换
         */
        static scale<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
        /**
         * @zh 在给定矩阵变换基础上加入新旋转变换
         * @param rad 旋转弧度
         */
        static rotate<Out extends IMat3Like>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 取四阶矩阵的前三阶
         */
        static fromMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out;
        /**
         * @zh 根据视口前方向和上方向计算矩阵
         * @param view 视口面向的前方向，必须归一化
         * @param up 视口的上方向，必须归一化，默认为 (0, 1, 0)
         */
        static fromViewUp<Out extends IMat3Like, VecLike extends IVec3Like>(out: Out, view: VecLike, up?: Vec3): Out;
        /**
         * @zh 计算位移矩阵
         */
        static fromTranslation<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
        /**
         * @zh 计算缩放矩阵
         */
        static fromScaling<Out extends IMat3Like, VecLike extends IVec2Like>(out: Out, v: VecLike): Out;
        /**
         * @zh 计算旋转矩阵
         */
        static fromRotation<Out extends IMat3Like>(out: Out, rad: number): Out;
        /**
         * @zh 根据四元数旋转信息计算矩阵
         */
        static fromQuat<Out extends IMat3Like>(out: Out, q: IQuatLike): Out;
        /**
         * @zh 计算指定四维矩阵的逆转置三维矩阵
         */
        static inverseTransposeMat4<Out extends IMat3Like>(out: Out, a: IMat4Like): Out | null;
        /**
         * @zh 矩阵转数组
         * @param ofs 数组内的起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, m: IMat3Like, ofs?: number): Out;
        /**
         * @zh 数组转矩阵
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IMat3Like>(out: Out, arr: IWritableArrayLike<number>, ofs?: number): Out;
        /**
         * @zh 逐元素矩阵加法
         */
        static add<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素矩阵减法
         */
        static subtract<Out extends IMat3Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 矩阵标量乘法
         */
        static multiplyScalar<Out extends IMat3Like>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 逐元素矩阵标量乘加: A + B * scale
         */
        static multiplyScalarAndAdd<Out extends IMat3Like>(out: Out, a: Out, b: Out, scale: number): Out;
        /**
         * @zh 矩阵等价判断
         */
        static strictEquals<Out extends IMat3Like>(a: Out, b: Out): boolean;
        /**
         * @zh 排除浮点数误差的矩阵近似等价判断
         */
        static equals<Out extends IMat3Like>(a: Out, b: Out, epsilon?: number): boolean;
        /**
         * 矩阵第 0 列第 0 行的元素。
         */
        m00: number;
        /**
         * 矩阵第 0 列第 1 行的元素。
         */
        m01: number;
        /**
         * 矩阵第 0 列第 2 行的元素。
         */
        m02: number;
        /**
         * 矩阵第 1 列第 0 行的元素。
         */
        m03: number;
        /**
         * 矩阵第 1 列第 1 行的元素。
         */
        m04: number;
        /**
         * 矩阵第 1 列第 2 行的元素。
         */
        m05: number;
        /**
         * 矩阵第 2 列第 0 行的元素。
         */
        m06: number;
        /**
         * 矩阵第 2 列第 1 行的元素。
         */
        m07: number;
        /**
         * 矩阵第 2 列第 2 行的元素。
         */
        m08: number;
        constructor(other: Mat3);
        constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number);
        /**
         * @zh 克隆当前矩阵。
         */
        clone(): Mat3;
        /**
         * @zh 设置当前矩阵使其与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @return this
         */
        set(other: Mat3): any;
        /**
         * 设置当前矩阵指定元素值。
         * @return this
         */
        set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number): any;
        /**
         * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @param epsilon 允许的误差，应为非负数。
         * @return 两矩阵的各元素都分别相等时返回 `true`；否则返回 `false`。
         */
        equals(other: Mat3, epsilon?: number): boolean;
        /**
         * @zh 判断当前矩阵是否与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @return 两矩阵的各元素都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Mat3): boolean;
        /**
         * 返回当前矩阵的字符串表示。
         * @return 当前矩阵的字符串表示。
         */
        toString(): string;
        /**
         * 将当前矩阵设为单位矩阵。
         * @return `this`
         */
        identity(): this;
        /**
         * @zh 计算当前矩阵的转置矩阵。
         */
        transpose(): this;
        /**
         * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
         */
        invert(): this;
        /**
         * 计算当前矩阵的行列式。
         * @return 当前矩阵的行列式。
         */
        determinant(): number;
        /**
         * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
         * @param mat 相加的矩阵
         */
        add(mat: Mat3): this;
        /**
         * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
         * @param mat 减数矩阵。
         */
        subtract(mat: Mat3): this;
        /**
         * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
         * @param mat 指定的矩阵。
         */
        multiply(mat: Mat3): this;
        /**
         * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
         * @param scalar 指定的标量。
         */
        multiplyScalar(scalar: number): this;
        /**
         * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出。
         * @param vec 各个轴的缩放。
         */
        scale(vec: Vec3): this;
        /**
         * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出。
         * @param mat 矩阵
         * @param rad 旋转角度（弧度制）
         */
        rotate(rad: number): this;
        /**
         * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
         * @param q 四元数表示的旋转变换。
         * @returns this
         */
        fromQuat(q: Quat): this;
    }
}
declare module "cocos/core/math/mat4" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Quat } from "cocos/core/math/quat";
    import { IMat4Like, IVec3Like } from "cocos/core/math/type-define";
    import { Vec3 } from "cocos/core/math/vec3";
    /**
     * 表示四维（4x4）矩阵。
     */
    export class Mat4 extends ValueType {
        static IDENTITY: Readonly<Mat4>;
        /**
         * @zh 获得指定矩阵的拷贝
         */
        static clone<Out extends IMat4Like>(a: Out): Mat4;
        /**
         * @zh 复制目标矩阵
         */
        static copy<Out extends IMat4Like>(out: Out, a: Out): Out;
        /**
         * @zh 设置矩阵值
         */
        static set<Out extends IMat4Like>(out: Out, m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Out;
        /**
         * @zh 将目标赋值为单位矩阵
         */
        static identity<Out extends IMat4Like>(out: Out): Out;
        /**
         * @zh 转置矩阵
         */
        static transpose<Out extends IMat4Like>(out: Out, a: Out): Out;
        /**
         * @zh 矩阵求逆，注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
         */
        static invert<Out extends IMat4Like>(out: Out, a: Out): Out;
        /**
         * @zh 矩阵行列式
         */
        static determinant<Out extends IMat4Like>(a: Out): number;
        /**
         * @zh 矩阵乘法
         */
        static multiply<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 在给定矩阵变换基础上加入变换
         */
        static transform<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
        /**
         * @zh 在给定矩阵变换基础上加入新位移变换
         */
        static translate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
        /**
         * @zh 在给定矩阵变换基础上加入新缩放变换
         */
        static scale<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, v: VecLike): Out;
        /**
         * @zh 在给定矩阵变换基础上加入新旋转变换
         * @param rad 旋转角度
         * @param axis 旋转轴
         */
        static rotate<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, a: Out, rad: number, axis: VecLike): Out | null;
        /**
         * @zh 在给定矩阵变换基础上加入绕 X 轴的旋转变换
         * @param rad 旋转角度
         */
        static rotateX<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 在给定矩阵变换基础上加入绕 Y 轴的旋转变换
         * @param rad 旋转角度
         */
        static rotateY<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 在给定矩阵变换基础上加入绕 Z 轴的旋转变换
         * @param rad 旋转角度
         */
        static rotateZ<Out extends IMat4Like>(out: Out, a: Out, rad: number): Out;
        /**
         * @zh 计算位移矩阵
         */
        static fromTranslation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
        /**
         * @zh 计算缩放矩阵
         */
        static fromScaling<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, v: VecLike): Out;
        /**
         * @zh 计算旋转矩阵
         */
        static fromRotation<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, rad: number, axis: VecLike): Out | null;
        /**
         * @zh 计算绕 X 轴的旋转矩阵
         */
        static fromXRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
        /**
         * @zh 计算绕 Y 轴的旋转矩阵
         */
        static fromYRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
        /**
         * @zh 计算绕 Z 轴的旋转矩阵
         */
        static fromZRotation<Out extends IMat4Like>(out: Out, rad: number): Out;
        /**
         * @zh 根据旋转和位移信息计算矩阵
         */
        static fromRT<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike): Out;
        /**
         * @zh 提取矩阵的位移信息, 默认矩阵中的变换以 S->R->T 的顺序应用
         */
        static getTranslation<Out extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: Out): VecLike;
        /**
         * @zh 提取矩阵的缩放信息, 默认矩阵中的变换以 S->R->T 的顺序应用
         */
        static getScaling<Out extends IMat4Like, VecLike extends IVec3Like>(out: VecLike, mat: Out): VecLike;
        /**
         * @zh 提取矩阵的旋转信息, 默认输入矩阵不含有缩放信息，如考虑缩放应使用 `toRTS` 函数。
         */
        static getRotation<Out extends IMat4Like>(out: Quat, mat: Out): Quat;
        /**
         * @zh 提取旋转、位移、缩放信息， 默认矩阵中的变换以 S->R->T 的顺序应用
         */
        static toRTS<Out extends IMat4Like, VecLike extends IVec3Like>(m: Out, q: Quat, v: VecLike, s: VecLike): void;
        /**
         * @zh 根据旋转、位移、缩放信息计算矩阵，以 S->R->T 的顺序应用
         */
        static fromRTS<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike): Out;
        /**
         * @zh 根据指定的旋转、位移、缩放及变换中心信息计算矩阵，以 S->R->T 的顺序应用
         * @param q 旋转值
         * @param v 位移值
         * @param s 缩放值
         * @param o 指定变换中心
         */
        static fromRTSOrigin<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, q: Quat, v: VecLike, s: VecLike, o: VecLike): Out;
        /**
         * @zh 根据指定的旋转信息计算矩阵
         */
        static fromQuat<Out extends IMat4Like>(out: Out, q: Quat): Out;
        /**
         * @zh 根据指定的视锥体信息计算矩阵
         * @param left 左平面距离
         * @param right 右平面距离
         * @param bottom 下平面距离
         * @param top 上平面距离
         * @param near 近平面距离
         * @param far 远平面距离
         */
        static frustum<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number): Out;
        /**
         * @zh 计算透视投影矩阵
         * @param fovy 纵向视角高度
         * @param aspect 长宽比
         * @param near 近平面距离
         * @param far 远平面距离
         */
        static perspective<Out extends IMat4Like>(out: Out, fov: number, aspect: number, near: number, far: number, isFOVY?: boolean, minClipZ?: number, projectionSignY?: number): Out;
        /**
         * @zh 计算正交投影矩阵
         * @param left 左平面距离
         * @param right 右平面距离
         * @param bottom 下平面距离
         * @param top 上平面距离
         * @param near 近平面距离
         * @param far 远平面距离
         */
        static ortho<Out extends IMat4Like>(out: Out, left: number, right: number, bottom: number, top: number, near: number, far: number, minClipZ?: number, projectionSignY?: number): Out;
        /**
         * @zh 根据视点计算矩阵，注意 `eye - center` 不能为零向量或与 `up` 向量平行
         * @param eye 当前位置
         * @param center 目标视点
         * @param up 视口上方向
         */
        static lookAt<Out extends IMat4Like, VecLike extends IVec3Like>(out: Out, eye: VecLike, center: VecLike, up: VecLike): Out;
        /**
         * @zh 计算逆转置矩阵
         */
        static inverseTranspose<Out extends IMat4Like>(out: Out, a: Out): Out | null;
        /**
         * @zh 矩阵转数组
         * @param ofs 数组内的起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, m: IMat4Like, ofs?: number): Out;
        /**
         * @zh 数组转矩阵
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IMat4Like>(out: Out, arr: IWritableArrayLike<number>, ofs?: number): Out;
        /**
         * @zh 逐元素矩阵加法
         */
        static add<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素矩阵减法
         */
        static subtract<Out extends IMat4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 矩阵标量乘法
         */
        static multiplyScalar<Out extends IMat4Like>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 逐元素矩阵标量乘加: A + B * scale
         */
        static multiplyScalarAndAdd<Out extends IMat4Like>(out: Out, a: Out, b: Out, scale: number): Out;
        /**
         * @zh 矩阵等价判断
         */
        static strictEquals<Out extends IMat4Like>(a: Out, b: Out): boolean;
        /**
         * @zh 排除浮点数误差的矩阵近似等价判断
         */
        static equals<Out extends IMat4Like>(a: Out, b: Out, epsilon?: number): boolean;
        /**
         * 矩阵第 0 列第 0 行的元素。
         */
        m00: number;
        /**
         * 矩阵第 0 列第 1 行的元素。
         */
        m01: number;
        /**
         * 矩阵第 0 列第 2 行的元素。
         */
        m02: number;
        /**
         * 矩阵第 0 列第 3 行的元素。
         */
        m03: number;
        /**
         * 矩阵第 1 列第 0 行的元素。
         */
        m04: number;
        /**
         * 矩阵第 1 列第 1 行的元素。
         */
        m05: number;
        /**
         * 矩阵第 1 列第 2 行的元素。
         */
        m06: number;
        /**
         * 矩阵第 1 列第 3 行的元素。
         */
        m07: number;
        /**
         * 矩阵第 2 列第 0 行的元素。
         */
        m08: number;
        /**
         * 矩阵第 2 列第 1 行的元素。
         */
        m09: number;
        /**
         * 矩阵第 2 列第 2 行的元素。
         */
        m10: number;
        /**
         * 矩阵第 2 列第 3 行的元素。
         */
        m11: number;
        /**
         * 矩阵第 3 列第 0 行的元素。
         */
        m12: number;
        /**
         * 矩阵第 3 列第 1 行的元素。
         */
        m13: number;
        /**
         * 矩阵第 3 列第 2 行的元素。
         */
        m14: number;
        /**
         * 矩阵第 3 列第 3 行的元素。
         */
        m15: number;
        constructor(other: Mat4);
        constructor(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number);
        /**
         * @zh 克隆当前矩阵。
         */
        clone(): Mat4;
        /**
         * @zh 设置当前矩阵使其与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @return this
         */
        set(other: Mat4): any;
        /**
         * 设置当前矩阵指定元素值。
         * @return this
         */
        set(m00?: number, m01?: number, m02?: number, m03?: number, m04?: number, m05?: number, m06?: number, m07?: number, m08?: number, m09?: number, m10?: number, m11?: number, m12?: number, m13?: number, m14?: number, m15?: number): any;
        /**
         * @zh 判断当前矩阵是否在误差范围内与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @param epsilon 允许的误差，应为非负数。
         * @return 两矩阵的各元素都分别相等时返回 `true`；否则返回 `false`。
         */
        equals(other: Mat4, epsilon?: number): boolean;
        /**
         * @zh 判断当前矩阵是否与指定矩阵相等。
         * @param other 相比较的矩阵。
         * @return 两矩阵的各元素都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Mat4): boolean;
        /**
         * 返回当前矩阵的字符串表示。
         * @return 当前矩阵的字符串表示。
         */
        toString(): string;
        /**
         * 将当前矩阵设为单位矩阵。
         * @return `this`
         */
        identity(): this;
        /**
         * @zh 计算当前矩阵的转置矩阵。
         */
        transpose(): this;
        /**
         * @zh 计算当前矩阵的逆矩阵。注意，在矩阵不可逆时，会返回一个全为 0 的矩阵。
         */
        invert(): this;
        /**
         * 计算当前矩阵的行列式。
         * @return 当前矩阵的行列式。
         */
        determinant(): number;
        /**
         * @zh 矩阵加法。将当前矩阵与指定矩阵的相加，结果返回给当前矩阵。
         * @param mat 相加的矩阵
         */
        add(mat: Mat4): this;
        /**
         * @zh 计算矩阵减法。将当前矩阵减去指定矩阵的结果赋值给当前矩阵。
         * @param mat 减数矩阵。
         */
        subtract(mat: Mat4): this;
        /**
         * @zh 矩阵乘法。将当前矩阵左乘指定矩阵的结果赋值给当前矩阵。
         * @param mat 指定的矩阵。
         */
        multiply(mat: Mat4): this;
        /**
         * @zh 矩阵数乘。将当前矩阵与指定标量的数乘结果赋值给当前矩阵。
         * @param scalar 指定的标量。
         */
        multiplyScalar(scalar: number): this;
        /**
         * @zh 将当前矩阵左乘位移矩阵的结果赋值给当前矩阵，位移矩阵由各个轴的位移给出。
         * @param vec 位移向量。
         */
        translate(vec: Vec3): this;
        /**
         * @zh 将当前矩阵左乘缩放矩阵的结果赋值给当前矩阵，缩放矩阵由各个轴的缩放给出。
         * @param vec 各个轴的缩放。
         */
        scale(vec: Vec3): this;
        /**
         * @zh 将当前矩阵左乘旋转矩阵的结果赋值给当前矩阵，旋转矩阵由旋转轴和旋转角度给出。
         * @param mat 矩阵
         * @param rad 旋转角度（弧度制）
         * @param axis 旋转轴
         */
        rotate(rad: number, axis: Vec3): this | null;
        /**
         * @zh 从当前矩阵中计算出位移变换的部分，并以各个轴上位移的形式赋值给出口向量。
         * @param out 返回向量，当未指定时将创建为新的向量。
         */
        getTranslation(out: Vec3): Vec3;
        /**
         * @zh 从当前矩阵中计算出缩放变换的部分，并以各个轴上缩放的形式赋值给出口向量。
         * @param out 返回值，当未指定时将创建为新的向量。
         */
        getScale(out: Vec3): Vec3;
        /**
         * @zh 从当前矩阵中计算出旋转变换的部分，并以四元数的形式赋值给出口四元数。
         * @param out 返回值，当未指定时将创建为新的四元数。
         */
        getRotation(out: Quat): Quat;
        /**
         * @zh 重置当前矩阵的值，使其表示指定的旋转、缩放、位移依次组合的变换。
         * @param q 四元数表示的旋转变换。
         * @param v 位移变换，表示为各个轴的位移。
         * @param s 缩放变换，表示为各个轴的缩放。
         * @return `this`
         */
        fromRTS(q: Quat, v: Vec3, s: Vec3): this;
        /**
         * @zh 重置当前矩阵的值，使其表示指定四元数表示的旋转变换。
         * @param q 四元数表示的旋转变换。
         * @return `this`
         */
        fromQuat(q: Quat): this;
    }
    export function mat4(other: Mat4): Mat4;
    export function mat4(m00?: number, m01?: number, m02?: number, m03?: number, m10?: number, m11?: number, m12?: number, m13?: number, m20?: number, m21?: number, m22?: number, m23?: number, m30?: number, m31?: number, m32?: number, m33?: number): Mat4;
}
declare module "cocos/core/math/vec2" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Mat4 } from "cocos/core/math/mat4";
    import { IMat3Like, IMat4Like, IVec2Like } from "cocos/core/math/type-define";
    import { Vec3 } from "cocos/core/math/vec3";
    /**
     * 二维向量。
     */
    export class Vec2 extends ValueType {
        static ZERO: Readonly<Vec2>;
        static ONE: Readonly<Vec2>;
        static NEG_ONE: Readonly<Vec2>;
        static UNIT_X: Readonly<Vec2>;
        static UNIT_Y: Readonly<Vec2>;
        /**
         * @zh 获得指定向量的拷贝
         */
        static clone<Out extends IVec2Like>(a: Out): Vec2;
        /**
         * @zh 复制目标向量
         */
        static copy<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 设置向量值
         */
        static set<Out extends IVec2Like>(out: Out, x: number, y: number): Out;
        /**
         * @zh 逐元素向量加法
         */
        static add<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量减法
         */
        static subtract<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量乘法
         */
        static multiply<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量除法
         */
        static divide<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量向上取整
         */
        static ceil<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量向下取整
         */
        static floor<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量最小值
         */
        static min<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量最大值
         */
        static max<Out extends IVec2Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量四舍五入取整
         */
        static round<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 向量标量乘法
         */
        static multiplyScalar<Out extends IVec2Like>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 逐元素向量乘加: A + B * scale
         */
        static scaleAndAdd<Out extends IVec2Like>(out: Out, a: Out, b: Out, scale: number): Out;
        /**
         * @zh 求两向量的欧氏距离
         */
        static distance<Out extends IVec2Like>(a: Out, b: Out): number;
        /**
         * @zh 求两向量的欧氏距离平方
         */
        static squaredDistance<Out extends IVec2Like>(a: Out, b: Out): number;
        /**
         * @zh 求向量长度
         */
        static len<Out extends IVec2Like>(a: Out): number;
        /**
         * @zh 求向量长度平方
         */
        static lengthSqr<Out extends IVec2Like>(a: Out): number;
        /**
         * @zh 逐元素向量取负
         */
        static negate<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
         */
        static inverse<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 0
         */
        static inverseSafe<Out extends IVec2Like>(out: Out, a: Out): Out;
        /**
         * @zh 归一化向量
         */
        static normalize<Out extends IVec2Like, Vec2Like extends IVec2Like>(out: Out, a: Vec2Like): Out;
        /**
         * @zh 向量点积（数量积）
         */
        static dot<Out extends IVec2Like>(a: Out, b: Out): number;
        /**
         * @zh 向量叉积（向量积），注意二维向量的叉积为与 Z 轴平行的三维向量
         */
        static cross<Out extends IVec2Like>(out: Vec3, a: Out, b: Out): Vec3;
        /**
         * @zh 逐元素向量线性插值： A + t * (B - A)
         */
        static lerp<Out extends IVec2Like>(out: Out, a: Out, b: Out, t: number): Out;
        /**
         * @zh 生成一个在单位圆上均匀分布的随机向量
         * @param scale 生成的向量长度
         */
        static random<Out extends IVec2Like>(out: Out, scale?: number): Out;
        /**
         * @zh 向量与三维矩阵乘法，默认向量第三位为 1。
         */
        static transformMat3<Out extends IVec2Like, MatLike extends IMat3Like>(out: Out, a: Out, m: IMat3Like): Out;
        /**
         * @zh 向量与四维矩阵乘法，默认向量第三位为 0，第四位为 1。
         */
        static transformMat4<Out extends IVec2Like, MatLike extends IMat4Like>(out: Out, a: Out, m: IMat4Like): Out;
        /**
         * @zh 返回向量的字符串表示
         */
        static str<Out extends IVec2Like>(a: Out): string;
        /**
         * @zh 向量转数组
         * @param ofs 数组起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, v: IVec2Like, ofs?: number): Out;
        /**
         * @zh 数组转向量
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IVec2Like>(out: Out, arr: IWritableArrayLike<number>, ofs?: number): Out;
        /**
         * @zh 向量等价判断
         */
        static strictEquals<Out extends IVec2Like>(a: Out, b: Out): boolean;
        /**
         * @zh 排除浮点数误差的向量近似等价判断
         */
        static equals<Out extends IVec2Like>(a: Out, b: Out, epsilon?: number): boolean;
        /**
         * @zh 求两向量夹角弧度
         */
        static angle<Out extends IVec2Like>(a: Out, b: Out): number;
        /**
         * x 分量。
         */
        x: number;
        /**
         * y 分量。
         */
        y: number;
        constructor(other: Vec2);
        constructor(x?: number, y?: number);
        /**
         * @zh 克隆当前向量。
         */
        clone(): Vec2;
        /**
         * @zh 设置当前向量使其与指定向量相等。
         * @param other 相比较的向量。
         * @return `this`
         */
        set(other: Vec2): any;
        /**
         * @zh 设置当前向量的具体分量值。
         * @param x 要设置的 x 分量的值
         * @param y 要设置的 y 分量的值
         * @return `this`
         */
        set(x?: number, y?: number): any;
        /**
         * @zh 判断当前向量是否在误差范围内与指定向量相等。
         * @param other 相比较的向量。
         * @param epsilon 允许的误差，应为非负数。
         * @return 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals(other: Vec2, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
         * @param x 相比较的向量的 x 分量。
         * @param y 相比较的向量的 y 分量。
         * @param epsilon 允许的误差，应为非负数。
         * @return 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals2f(x: number, y: number, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否与指定向量相等。
         * @param other 相比较的向量。
         * @return 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Vec2): boolean;
        /**
         * @zh 判断当前向量是否与指定分量的向量相等。
         * @param x 指定向量的 x 分量。
         * @param y 指定向量的 y 分量。
         * @return 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals2f(x: number, y: number): boolean;
        /**
         * @zh 返回当前向量的字符串表示。
         * @returns 当前向量的字符串表示。
         */
        toString(): string;
        /**
         * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
         * @param to 目标向量。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Vec2, ratio: number): this;
        /**
         * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
         * @param minInclusive 每个分量都代表了对应分量允许的最小值。
         * @param maxInclusive 每个分量都代表了对应分量允许的最大值。
         * @return `this`
         */
        clampf(minInclusive: Vec2, maxInclusive: Vec2): this;
        /**
         * @zh 向量加法。将当前向量与指定向量的相加
         * @param other 指定的向量。
         */
        add(other: Vec2): this;
        /**
         * @zh 向量加法。将当前向量与指定分量的向量相加
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         */
        add2f(x: number, y: number): this;
        /**
         * @zh 向量减法。将当前向量减去指定向量
         * @param other 减数向量。
         */
        subtract(other: Vec2): this;
        /**
         * @zh 向量减法。将当前向量减去指定分量的向量
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         */
        subtract2f(x: number, y: number): this;
        /**
         * @zh 向量数乘。将当前向量数乘指定标量
         * @param scalar 标量乘数。
         */
        multiplyScalar(scalar: number): this;
        /**
         * @zh 向量乘法。将当前向量乘以与指定向量的结果赋值给当前向量。
         * @param other 指定的向量。
         */
        multiply(other: Vec2): this;
        /**
         * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         */
        multiply2f(x: number, y: number): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param other 指定的向量
         */
        divide(other: Vec2): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         */
        divide2f(x: number, y: number): this;
        /**
         * @zh 将当前向量的各个分量取反
         */
        negative(): this;
        /**
         * @zh 向量点乘。
         * @param other 指定的向量。
         * @return 当前向量与指定向量点乘的结果。
         */
        dot(other: Vec2): number;
        /**
         * @zh 向量叉乘。
         * @param other 指定的向量。
         * @return `out`
         */
        cross(other: Vec2): number;
        /**
         * 计算向量的长度（模）。
         * @return 向量的长度（模）。
         */
        length(): number;
        /**
         * 计算向量长度（模）的平方。
         * @return 向量长度（模）的平方。
         */
        lengthSqr(): number;
        /**
         * @zh 将当前向量归一化。
         */
        normalize(): this;
        /**
         * @zh 获取当前向量和指定向量之间的角度。
         * @param other 指定的向量。
         * @return 当前向量和指定向量之间的角度（弧度制）；若当前向量和指定向量中存在零向量，将返回 0。
         */
        angle(other: Vec2): number;
        /**
         * @zh 获取当前向量和指定向量之间的有符号角度。<br/>
         * 有符号角度的取值范围为 (-180, 180]，当前向量可以通过逆时针旋转有符号角度与指定向量同向。<br/>
         * @param other 指定的向量。
         * @return 当前向量和指定向量之间的有符号角度（弧度制）；若当前向量和指定向量中存在零向量，将返回 0。
         */
        signAngle(other: Vec2): number;
        /**
         * @zh 将当前向量的旋转
         * @param radians 旋转角度（弧度制）。
         */
        rotate(radians: number): this;
        /**
         * @zh 计算当前向量在指定向量上的投影向量。
         * @param other 指定的向量。
         */
        project(other: Vec2): this;
        /**
         * @zh 将当前向量视为 z 分量为 0、w 分量为 1 的四维向量，<br/>
         * 应用四维矩阵变换到当前矩阵<br/>
         * @param matrix 变换矩阵。
         */
        transformMat4(matrix: Mat4): this;
    }
    export function v2(other: Vec2): Vec2;
    export function v2(x?: number, y?: number): Vec2;
}
declare module "cocos/core/platform/event-manager/event-enum" {
    /**
     * @en The event type supported by SystemEvent and Node events
     * @zh SystemEvent 支持的事件类型以及节点事件类型
     */
    export enum SystemEventType {
        /**
         * @en
         * The event type for touch start event, you can use its value directly: 'touchstart'.
         *
         * @zh
         * 手指开始触摸事件。
         */
        TOUCH_START = "touch-start",
        /**
         * @en
         * The event type for touch move event, you can use its value directly: 'touchmove'.
         *
         * @zh
         * 当手指在屏幕上移动时。
         */
        TOUCH_MOVE = "touch-move",
        /**
         * @en
         * The event type for touch end event, you can use its value directly: 'touchend'.
         *
         * @zh
         * 手指结束触摸事件。
         */
        TOUCH_END = "touch-end",
        /**
         * @en
         * The event type for touch end event, you can use its value directly: 'touchcancel'.
         *
         * @zh
         * 当手指在目标节点区域外离开屏幕时。
         */
        TOUCH_CANCEL = "touch-cancel",
        /**
         * @en
         * The event type for mouse down events, you can use its value directly: 'mousedown'.
         *
         * @zh
         * 当鼠标按下时触发一次。
         */
        MOUSE_DOWN = "mouse-down",
        /**
         * @en
         * The event type for mouse move events, you can use its value directly: 'mousemove'.
         *
         * @zh
         * 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。
         */
        MOUSE_MOVE = "mouse-move",
        /**
         * @en
         * The event type for mouse up events, you can use its value directly: 'mouseup'.
         *
         * @zh
         * 当鼠标从按下状态松开时触发一次。
         */
        MOUSE_UP = "mouse-up",
        /**
         * @en
         * The event type for mouse wheel events, you can use its value directly: 'mousewheel'.
         *
         * @zh 手指开始触摸事件
         */
        MOUSE_WHEEL = "mouse-wheel",
        /**
         * @en
         * The event type for mouse leave target events, you can use its value directly: 'mouseleave'.
         *
         * @zh
         * 当鼠标移入目标节点区域时，不论是否按下.
         */
        MOUSE_ENTER = "mouse-enter",
        /**
         * @en
         * The event type for mouse leave target events, you can use its value directly: 'mouseleave'.
         *
         * @zh
         * 当鼠标移出目标节点区域时，不论是否按下。
         */
        MOUSE_LEAVE = "mouse-leave",
        /**
         * @en The event type for press the key down event, you can use its value directly: 'keydown'
         * @zh 当按下按键时触发的事件
         */
        KEY_DOWN = "keydown",
        /**
         * @en The event type for press the key up event, you can use its value directly: 'keyup'
         * @zh 当松开按键时触发的事件
         */
        KEY_UP = "keyup",
        /**
         * @en
         * The event type for press the devicemotion event, you can use its value directly: 'devicemotion'
         *
         * @zh
         * 重力感应
         */
        DEVICEMOTION = "devicemotion",
        /**
         * @en
         * The event type for position, rotation, scale changed.Use the type parameter as [[Node.TransformBit]] to check which part is changed
         *
         * @zh
         * 节点改变位置、旋转或缩放事件。如果具体需要判断是哪一个事件，可通过判断回调的第一个参数类型是 [[Node.TransformBit]] 中的哪一个来获取
         * @example
         * ```
         * this.node.on(Node.EventType.TRANSFORM_CHANGED, (type)=>{
         *  if (type & Node.TransformBit.POSITION) {
         *       //...
         *   }
         * }, this);
         * ```
         */
        TRANSFORM_CHANGED = "transform-changed",
        /**
         * @en The event type for notifying the host scene has been changed for a persist node.
         * @zh 当场景常驻节点的场景发生改变时触发的事件，一般在切换场景过程中触发。
         */
        SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists",
        /**
         * @en
         * The event type for size change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点尺寸改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         */
        SIZE_CHANGED = "size-changed",
        /**
         * @en
         * The event type for anchor point change events.
         * Performance note, this event will be triggered every time corresponding properties being changed,
         * if the event callback have heavy logic it may have great performance impact, try to avoid such scenario.
         *
         * @zh
         * 当节点的 UITransform 锚点改变时触发的事件。
         * 性能警告：这个事件会在每次对应的属性被修改时触发，如果事件回调损耗较高，有可能对性能有很大的负面影响，请尽量避免这种情况。
         * @deprecated
         */
        ANCHOR_CHANGED = "anchor-changed",
        /**
         * @en
         * The event type for adding a new child node to the target node.
         *
         * @zh
         * 给目标节点添加子节点时触发的事件。
         */
        CHILD_ADDED = "child-added",
        /**
         * @en
         * The event type for removing a child node from the target node.
         *
         * @zh
         * 给目标节点移除子节点时触发的事件。
         */
        CHILD_REMOVED = "child-removed",
        /**
         * @en The event type for changing the parent of the target node
         * @zh 目标节点的父节点改变时触发的事件。
         */
        PARENT_CHANGED = "parent-changed",
        /**
         * @en The event type for destroying the target node
         * @zh 目标节点被销毁时触发的事件。
         */
        NODE_DESTROYED = "node-destroyed"
    }
}
declare module "cocos/core/math/bits" {
    /**
     * 数学库
     * @category core/math
     */
    /**
     * Bit twiddling hacks for JavaScript.
     *
     * Author: Mikola Lysenko
     *
     * Ported from Stanford bit twiddling hack library:
     *    http://graphics.stanford.edu/~seander/bithacks.html
     */
    export const INT_BITS = 32;
    export const INT_MAX = 2147483647;
    export const INT_MIN: number;
    /**
     * @en Returns -1, 0, +1 depending on sign of x.
     * @zh 根据x的符号返回 -1，0，+1。
     */
    export function sign(v: number): number;
    /**
     * @en Computes absolute value of integer.
     * @zh 计算整数的绝对值。
     */
    export function abs(v: number): number;
    /**
     * @en Computes minimum of integers x and y.
     * @zh 计算整数x和y中的最小值。
     */
    export function min(x: number, y: number): number;
    /**
     * @en Computes maximum of integers x and y.
     * @zh 计算整数x和y中的最大值。
     */
    export function max(x: number, y: number): number;
    /**
     * @en Checks if a number is a power of two.
     * @zh 检查一个数字是否是2的幂。
     */
    export function isPow2(v: number): boolean;
    /**
     * Computes log base 2 of v.
     */
    export function log2(v: number): number;
    /**
     * Computes log base 10 of v.
     */
    export function log10(v: number): 1 | 0 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
    /**
     * Counts number of bits.
     */
    export function popCount(v: number): number;
    /**
     * @en Counts number of trailing zeros.
     * @zh 计算数字后面零的数量。
     */
    export function countTrailingZeros(v: number): number;
    /**
     * Rounds to next power of 2.
     */
    export function nextPow2(v: number): number;
    /**
     * Rounds down to previous power of 2.
     */
    export function prevPow2(v: number): number;
    /**
     * Computes parity of word.
     */
    export function parity(v: number): number;
    /**
     * Reverse bits in a 32 bit word.
     */
    export function reverse(v: number): number;
    /**
     * Interleave bits of 2 coordinates with 16 bits. Useful for fast quadtree codes.
     */
    export function interleave2(x: number, y: number): number;
    /**
     * Extracts the nth interleaved component.
     */
    export function deinterleave2(v: number, n: number): number;
    /**
     * Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes.
     */
    export function interleave3(x: number, y: number, z: number): number;
    /**
     * Extracts nth interleaved component of a 3-tuple.
     */
    export function deinterleave3(v: number, n: number): number;
    /**
     * Computes next combination in colexicographic order (this is
     * mistakenly called nextPermutation on the bit twiddling hacks page).
     */
    export function nextCombination(v: number): number;
}
declare module "cocos/core/math/vec4" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Mat4 } from "cocos/core/math/mat4";
    import { IMat4Like, IQuatLike, IVec4Like } from "cocos/core/math/type-define";
    /**
     * 四维向量。
     */
    export class Vec4 extends ValueType {
        static ZERO: Readonly<Vec4>;
        static ONE: Readonly<Vec4>;
        static NEG_ONE: Readonly<Vec4>;
        /**
         * @zh 获得指定向量的拷贝
         */
        static clone<Out extends IVec4Like>(a: Out): Vec4;
        /**
         * @zh 复制目标向量
         */
        static copy<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 设置向量值
         */
        static set<Out extends IVec4Like>(out: Out, x: number, y: number, z: number, w: number): Out;
        /**
         * @zh 逐元素向量加法
         */
        static add<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量减法
         */
        static subtract<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量乘法
         */
        static multiply<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量除法
         */
        static divide<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量向上取整
         */
        static ceil<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量向下取整
         */
        static floor<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量最小值
         */
        static min<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量最大值
         */
        static max<Out extends IVec4Like>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐元素向量四舍五入取整
         */
        static round<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 向量标量乘法
         */
        static multiplyScalar<Out extends IVec4Like>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 逐元素向量乘加: A + B * scale
         */
        static scaleAndAdd<Out extends IVec4Like>(out: Out, a: Out, b: Out, scale: number): Out;
        /**
         * @zh 求两向量的欧氏距离
         */
        static distance<Out extends IVec4Like>(a: Out, b: Out): number;
        /**
         * @zh 求两向量的欧氏距离平方
         */
        static squaredDistance<Out extends IVec4Like>(a: Out, b: Out): number;
        /**
         * @zh 求向量长度
         */
        static len<Out extends IVec4Like>(a: Out): number;
        /**
         * @zh 求向量长度平方
         */
        static lengthSqr<Out extends IVec4Like>(a: Out): number;
        /**
         * @zh 逐元素向量取负
         */
        static negate<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 Infinity
         */
        static inverse<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 逐元素向量取倒数，接近 0 时返回 0
         */
        static inverseSafe<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 归一化向量
         */
        static normalize<Out extends IVec4Like>(out: Out, a: Out): Out;
        /**
         * @zh 向量点积（数量积）
         */
        static dot<Out extends IVec4Like>(a: Out, b: Out): number;
        /**
         * @zh 逐元素向量线性插值： A + t * (B - A)
         */
        static lerp<Out extends IVec4Like>(out: Out, a: Out, b: Out, t: number): Out;
        /**
         * @zh 生成一个在单位球体上均匀分布的随机向量
         * @param scale 生成的向量长度
         */
        static random<Out extends IVec4Like>(out: Out, scale?: number): Out;
        /**
         * @zh 向量矩阵乘法
         */
        static transformMat4<Out extends IVec4Like, MatLike extends IMat4Like>(out: Out, a: Out, m: MatLike): Out;
        /**
         * @zh 向量仿射变换
         */
        static transformAffine<Out extends IVec4Like, VecLike extends IVec4Like, MatLike extends IMat4Like>(out: Out, v: VecLike, m: MatLike): Out;
        /**
         * @zh 向量四元数乘法
         */
        static transformQuat<Out extends IVec4Like, QuatLike extends IQuatLike>(out: Out, a: Out, q: QuatLike): Out;
        /**
         * @zh 向量转数组
         * @param ofs 数组起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, v: IVec4Like, ofs?: number): Out;
        /**
         * @zh 数组转向量
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IVec4Like>(out: Out, arr: IWritableArrayLike<number>, ofs?: number): Out;
        /**
         * @zh 向量等价判断
         */
        static strictEquals<Out extends IVec4Like>(a: Out, b: Out): boolean;
        /**
         * @zh 排除浮点数误差的向量近似等价判断
         */
        static equals<Out extends IVec4Like>(a: Out, b: Out, epsilon?: number): boolean;
        /**
         * x 分量。
         */
        x: number;
        /**
         * y 分量。
         */
        y: number;
        /**
         * z 分量。
         */
        z: number;
        /**
         * w 分量。
         */
        w: number;
        constructor(other: Vec4);
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * @zh 克隆当前向量。
         */
        clone(): Vec4;
        /**
         * @zh 设置当前向量使其与指定向量相等。
         * @param other 相比较的向量。
         * @returns `this`
         */
        set(other: Vec4): any;
        /**
         * @zh 设置当前向量的具体分量值。
         * @param x 要设置的 x 分量的值
         * @param y 要设置的 y 分量的值
         * @param z 要设置的 z 分量的值
         * @param w 要设置的 w 分量的值
         * @returns `this`
         */
        set(x?: number, y?: number, z?: number, w?: number): any;
        /**
         * @zh 判断当前向量是否在误差范围内与指定向量相等。
         * @param other 相比较的向量。
         * @param epsilon 允许的误差，应为非负数。
         * @returns 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals(other: Vec4, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否在误差范围内与指定分量的向量相等。
         * @param x 相比较的向量的 x 分量。
         * @param y 相比较的向量的 y 分量。
         * @param z 相比较的向量的 z 分量。
         * @param w 相比较的向量的 w 分量。
         * @param epsilon 允许的误差，应为非负数。
         * @returns 当两向量的各分量都在指定的误差范围内分别相等时，返回 `true`；否则返回 `false`。
         */
        equals4f(x: number, y: number, z: number, w: number, epsilon?: number): boolean;
        /**
         * @zh 判断当前向量是否与指定向量相等。
         * @param other 相比较的向量。
         * @returns 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals(other: Vec4): boolean;
        /**
         * @zh 判断当前向量是否与指定分量的向量相等。
         * @param x 指定向量的 x 分量。
         * @param y 指定向量的 y 分量。
         * @param z 指定向量的 z 分量。
         * @param w 指定向量的 w 分量。
         * @returns 两向量的各分量都分别相等时返回 `true`；否则返回 `false`。
         */
        strictEquals4f(x: number, y: number, z: number, w: number): boolean;
        /**
         * @zh 根据指定的插值比率，从当前向量到目标向量之间做插值。
         * @param to 目标向量。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Vec4, ratio: number): this;
        /**
         * @zh 返回当前向量的字符串表示。
         * @returns 当前向量的字符串表示。
         */
        toString(): string;
        /**
         * @zh 设置当前向量的值，使其各个分量都处于指定的范围内。
         * @param minInclusive 每个分量都代表了对应分量允许的最小值。
         * @param maxInclusive 每个分量都代表了对应分量允许的最大值。
         * @returns `this`
         */
        clampf(minInclusive: Vec4, maxInclusive: Vec4): this;
        /**
         * @zh 向量加法。将当前向量与指定向量的相加
         * @param other 指定的向量。
         */
        add(other: Vec4): this;
        /**
         * @zh 向量加法。将当前向量与指定分量的向量相加
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         * @param w 指定的向量的 w 分量。
         */
        add4f(x: number, y: number, z: number, w: number): this;
        /**
         * @zh 向量减法。将当前向量减去指定向量
         * @param other 减数向量。
         */
        subtract(other: Vec4): this;
        /**
         * @zh 向量减法。将当前向量减去指定分量的向量
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         * @param w 指定的向量的 w 分量。
         */
        subtract4f(x: number, y: number, z: number, w: number): this;
        /**
         * @zh 向量数乘。将当前向量数乘指定标量
         * @param scalar 标量乘数。
         */
        multiplyScalar(scalar: number): this;
        /**
         * @zh 向量乘法。将当前向量乘以指定向量
         * @param other 指定的向量。
         */
        multiply(other: Vec4): this;
        /**
         * @zh 向量乘法。将当前向量与指定分量的向量相乘的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         * @param w 指定的向量的 w 分量。
         */
        multiply4f(x: number, y: number, z: number, w: number): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param other 指定的向量
         */
        divide(other: Vec4): this;
        /**
         * @zh 向量逐元素相除。将当前向量与指定分量的向量相除的结果赋值给当前向量。
         * @param x 指定的向量的 x 分量。
         * @param y 指定的向量的 y 分量。
         * @param z 指定的向量的 z 分量。
         * @param w 指定的向量的 w 分量。
         */
        divide4f(x: number, y: number, z: number, w: number): this;
        /**
         * @zh 将当前向量的各个分量取反
         */
        negative(): this;
        /**
         * @zh 向量点乘。
         * @param other 指定的向量。
         * @returns 当前向量与指定向量点乘的结果。
         */
        dot(vector: Vec4): number;
        /**
         * @zh 向量叉乘。视当前向量和指定向量为三维向量（舍弃 w 分量），将当前向量左叉乘指定向量
         * @param other 指定的向量。
         */
        cross(vector: Vec4): this;
        /**
         * @zh 计算向量的长度（模）。
         * @returns 向量的长度（模）。
         */
        length(): number;
        /**
         * @zh 计算向量长度（模）的平方。
         * @returns 向量长度（模）的平方。
         */
        lengthSqr(): number;
        /**
         * @zh 将当前向量归一化
         */
        normalize(): this;
        /**
         * @zh 应用四维矩阵变换到当前矩阵
         * @param matrix 变换矩阵。
         */
        transformMat4(matrix: Mat4): this;
    }
    export function v4(other: Vec4): Vec4;
    export function v4(x?: number, y?: number, z?: number, w?: number): Vec4;
}
declare module "cocos/core/math/size" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { ISizeLike } from "cocos/core/math/type-define";
    /**
     * 二维尺寸。
     */
    export class Size extends ValueType {
        static ZERO: Readonly<Size>;
        static ONE: Readonly<Size>;
        /**
         * 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
         * @param out 本方法将插值结果赋值给此参数
         * @param from 起始尺寸。
         * @param to 目标尺寸。
         * @param ratio 插值比率，范围为 [0,1]。
         * @returns 当前尺寸的宽和高到目标尺寸的宽和高分别按指定插值比率进行线性插值构成的向量。
         */
        static lerp<Out extends ISizeLike>(out: Out, from: Out, to: Out, ratio: number): Out;
        set x(val: number);
        get x(): number;
        set y(val: number);
        get y(): number;
        /**
         * 宽度。
         */
        width: number;
        /**
         * 高度。
         */
        height: number;
        /**
         * 构造与指定尺寸相等的尺寸。
         * @param other 相比较的尺寸。
         */
        constructor(other: Size);
        /**
         * 构造具有指定宽度和高度的尺寸。
         * @param [width=0] 指定的宽度。
         * @param [height=0] 指定的高度。
         */
        constructor(width?: number, height?: number);
        /**
         * 克隆当前尺寸。
         */
        clone(): Size;
        /**
         * 设置当前尺寸使其与指定的尺寸相等。
         * @param other 相比较的尺寸。
         * @returns `this`
         */
        set(other: Size): any;
        /**
         * 设置当前尺寸的具体参数。
         * @param width 要设置的 width 值
         * @param height 要设置的 height 值
         * @returns `this`
         */
        set(width?: number, height?: number): any;
        /**
         * 判断当前尺寸是否与指定尺寸的相等。
         * @param other 相比较的尺寸。
         * @returns 两尺寸的宽和高都分别相等时返回 `true`；否则返回 `false`。
         */
        equals(other: Size): boolean;
        /**
         * 根据指定的插值比率，从当前尺寸到目标尺寸之间做插值。
         * @param to 目标尺寸。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Size, ratio: number): this;
        /**
         * 返回当前尺寸的字符串表示。
         * @returns 当前尺寸的字符串表示。
         */
        toString(): string;
    }
    /**
     * 等价于 `new Size(other)`。
     * @param other 相比较的尺寸。
     * @returns `new Size(other)`
     */
    export function size(other: Size): Size;
    /**
     * 等价于 `new Size(x, y)`。
     * @param [x=0] 指定的宽度。
     * @param [y=0] 指定的高度。
     * @returns `new Size(x, y)`
     */
    export function size(width?: number, height?: number): Size;
}
declare module "cocos/core/math/rect" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { Mat4 } from "cocos/core/math/mat4";
    import { Size } from "cocos/core/math/size";
    import { IRectLike, IVec2Like } from "cocos/core/math/type-define";
    import { Vec2 } from "cocos/core/math/vec2";
    /**
     * 轴对齐矩形。
     * 矩形内的所有点都大于等于矩形的最小点 (xMin, yMin) 并且小于等于矩形的最大点 (xMax, yMax)。
     * 矩形的宽度定义为 xMax - xMin；高度定义为 yMax - yMin。
     */
    export class Rect extends ValueType {
        /**
         * 由任意两个点创建一个矩形，目标矩形即是这两个点各向 x、y 轴作线所得到的矩形。
         * @param v1 指定的点。
         * @param v2 指定的点。
         * @returns 目标矩形。
         */
        static fromMinMax<Out extends IRectLike, VecLike extends IVec2Like>(out: Out, v1: VecLike, v2: VecLike): Out;
        /**
         * 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
         * @param out 本方法将插值结果赋值给此参数
         * @param from 起始矩形。
         * @param to 目标矩形。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        static lerp<Out extends IRectLike>(out: Out, from: Out, to: Out, ratio: number): Out;
        /**
         * 计算当前矩形与指定矩形重叠部分的矩形，将其赋值给出口矩形。
         * @param out 出口矩形。
         * @param one 指定的一个矩形。
         * @param other 指定的另一个矩形。
         */
        static intersection<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
        /**
         * 创建同时包含当前矩形和指定矩形的最小矩形，将其赋值给出口矩形。
         * @param out 出口矩形。
         * @param one 指定的一个矩形。
         * @param other 指定的另一个矩形。
         */
        static union<Out extends IRectLike>(out: Out, one: Out, other: Out): Out;
        /**
         * 获取或设置矩形在 x 轴上的最小值。
         */
        get xMin(): number;
        set xMin(value: number);
        /**
         * 获取或设置矩形在 y 轴上的最小值。
         */
        get yMin(): number;
        set yMin(value: number);
        /**
         * 获取或设置矩形在 x 轴上的最大值。
         */
        get xMax(): number;
        set xMax(value: number);
        /**
         * 获取或设置矩形在 y 轴上的最大值。
         */
        get yMax(): number;
        set yMax(value: number);
        /**
         * 获取或设置矩形中心点的坐标。
         */
        get center(): Vec2;
        set center(value: Vec2);
        /**
         * 获取或设置矩形最小点的坐标。
         */
        get origin(): any;
        set origin(value: any);
        /**
         * 获取或设置矩形的尺寸。
         */
        get size(): Size;
        set size(value: Size);
        set z(val: number);
        get z(): number;
        set w(val: number);
        get w(): number;
        /**
         * 获取或设置矩形最小点的 x 坐标。
         */
        x: number;
        /**
         * 获取或设置矩形最小点的 y 坐标。
         */
        y: number;
        /**
         * 获取或设置矩形的宽度。
         */
        width: number;
        /**
         * 获取或设置矩形的高度。
         */
        height: number;
        /**
         * 构造与指定矩形相等的矩形。
         * @param other 相比较的矩形。
         */
        constructor(other: Rect);
        /**
         * 构造具有指定的最小值和尺寸的矩形。
         * @param x 矩形在 x 轴上的最小值。
         * @param y 矩形在 y 轴上的最小值。
         * @param width 矩形的宽度。
         * @param height 矩形的高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * 克隆当前矩形。
         */
        clone(): Rect;
        /**
         * 设置当前矩形使其与指定矩形相等。
         * @param other 相比较的矩形。
         * @returns `this`
         */
        set(other: Rect): any;
        /**
         * 设置当前矩形使其与指定参数的矩形相等。
         * @param x 指定矩形的 x 参数
         * @param y 指定矩形的 y 参数
         * @param width 指定矩形的 width 参数
         * @param height 指定矩形的 height 参数
         * @returns `this`
         */
        set(x?: number, y?: number, width?: number, height?: number): any;
        /**
         * 判断当前矩形是否与指定矩形相等。
         * @param other 相比较的矩形。
         * @returns 两矩阵的最小值和最大值都分别相等时返回 `true`；否则返回 `false`。
         */
        equals(other: Rect): boolean;
        /**
         * 根据指定的插值比率，从当前矩形到目标矩形之间做插值。
         * @param to 目标矩形。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Rect, ratio: number): this;
        /**
         * 返回当前矩形的字符串表示。
         * @returns 当前矩形的字符串表示。
         */
        toString(): string;
        /**
         * 判断当前矩形是否与指定矩形相交。
         * @param other 相比较的矩形。
         * @returns 相交则返回 `true`，否则返回 `false`。
         */
        intersects(other: Rect): boolean;
        /**
         * 判断当前矩形是否包含指定的点。
         * @param point 指定的点。
         * @returns 指定的点包含在矩形内则返回 `true`，否则返回 `false`。
         */
        contains(point: Vec2): boolean;
        /**
         * 判断当前矩形是否包含指定矩形。
         * @param other 指定的矩形。
         * @returns 指定矩形所有的点都包含在当前矩形内则返回 `true`，否则返回 `false`。
         */
        containsRect(other: Rect): boolean;
        /**
         * 应用矩阵变换到当前矩形：
         * 应用矩阵变换到当前矩形的最小点得到新的最小点，
         * 将当前矩形的尺寸视为二维向量应用矩阵变换得到新的尺寸；
         * 并将如此构成的新矩形。
         * @param matrix 变换矩阵。
         */
        transformMat4(mat: Mat4): this;
    }
    /**
     * 构造与指定矩形相等的矩形。等价于 `new Rect(rect)`。
     * @param rect 相比较的矩形。
     * @returns `new Rect(rect)`
     */
    export function rect(rect: Rect): Rect;
    /**
     * 构造具有指定的最小值和尺寸的矩形，等价于`new Rect(x, y, width, height)`。
     * @param x 矩形在 x 轴上的最小值。
     * @param y 矩形在 y 轴上的最小值。
     * @param width 矩形的宽度。
     * @param height 矩形的高度。
     * @returns `new Rect(x, y, width, height)`
     */
    export function rect(x?: number, y?: number, width?: number, height?: number): Rect;
}
declare module "cocos/core/math/affine-transform" {
    /**
     * @category core/math
     */
    import { Mat4 } from "cocos/core/math/mat4";
    import { Rect } from "cocos/core/math/rect";
    import { Size } from "cocos/core/math/size";
    import { Vec2 } from "cocos/core/math/vec2";
    /**
     * 二维仿射变换矩阵，描述了平移、缩放和缩放。
     */
    export class AffineTransform {
        /**
         * 创建单位二维仿射变换矩阵，它不进行任何变换。
         */
        static identity(): AffineTransform;
        /**
         * 克隆指定的二维仿射变换矩阵。
         * @param affineTransform 指定的二维仿射变换矩阵。
         */
        static clone(affineTransform: AffineTransform): AffineTransform;
        /**
         * 将两个矩阵相乘的结果赋值给出口矩阵。
         * @param out 出口矩阵。
         * @param t1 左矩阵。
         * @param t2 右矩阵。
         */
        static concat(out: AffineTransform, t1: AffineTransform, t2: AffineTransform): void;
        /**
         * 将矩阵求逆的结果赋值给出口矩阵。
         * @param out 出口矩阵。
         * @param t 求逆的矩阵。
         */
        static invert(out: AffineTransform, t: AffineTransform): void;
        /**
         * 将四维矩阵转换为二维仿射变换矩阵并赋值给出口矩阵。
         * @param out 出口矩阵。
         * @param mat 四维矩阵。
         */
        static fromMat4(out: AffineTransform, mat: Mat4): void;
        /**
         * 应用二维仿射变换矩阵到二维向量上，并将结果赋值给出口向量。
         * @param out 出口向量。
         * @param point 应用变换的向量。
         * @param t 二维仿射变换矩阵。
         */
        static transformVec2(out: Vec2, point: Vec2, t: AffineTransform): any;
        /**
         * 应用二维仿射变换矩阵到二维向量上，并将结果赋值给出口向量。
         * @param out 出口向量。
         * @param x 应用变换的向量的 x 分量。
         * @param y 应用变换的向量的 y 分量。
         * @param t 二维仿射变换矩阵。
         */
        static transformVec2(out: Vec2, x: number, y: number, t: AffineTransform): any;
        /**
         * 应用二维仿射变换矩阵到二维尺寸上，并将结果赋值给出口尺寸。
         * @param out 出口尺寸。
         * @param size 应用变换的尺寸。
         * @param t 二维仿射变换矩阵。
         */
        static transformSize(out: Size, size: Size, t: AffineTransform): void;
        /**
         * 应用二维仿射变换矩阵到矩形上，并将结果赋值给出口矩形。
         * @param out 出口矩形。
         * @param rect 应用变换的矩形。
         * @param t 二维仿射变换矩阵。
         */
        static transformRect(out: Rect, rect: Rect, t: AffineTransform): void;
        /**
         * 应用二维仿射变换矩阵到矩形上, 并转换为有向包围盒。
         * 这个函数不创建任何内存，你需要先创建包围盒的四个 Vector 对象用来存储结果，并作为前四个参数传入函数。
         */
        static transformObb(out_bl: Vec2, out_tl: Vec2, out_tr: Vec2, out_br: Vec2, rect: Rect, anAffineTransform: AffineTransform): void;
        a: number;
        b: number;
        c: number;
        d: number;
        tx: number;
        ty: number;
        /**
         * 构造二维放射变换矩阵。
         * @param a a 元素。
         * @param b b 元素。
         * @param c c 元素。
         * @param d d 元素。
         * @param tx tx 元素。
         * @param ty ty 元素。
         */
        constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
    }
}
declare module "cocos/core/math/color" {
    import { ValueType } from "cocos/core/value-types/value-type";
    import { IColorLike } from "cocos/core/math/type-define";
    /**
     * @zh 通过 Red、Green、Blue 颜色通道表示颜色，并通过 Alpha 通道表示不透明度。<br/>
     * 每个通道都为取值范围 [0, 255] 的整数。<br/>
     */
    export class Color extends ValueType {
        static WHITE: Readonly<Color>;
        static GRAY: Readonly<Color>;
        static BLACK: Readonly<Color>;
        static TRANSPARENT: Readonly<Color>;
        static RED: Readonly<Color>;
        static GREEN: Readonly<Color>;
        static BLUE: Readonly<Color>;
        static CYAN: Readonly<Color>;
        static MAGENTA: Readonly<Color>;
        static YELLOW: Readonly<Color>;
        /**
         * @zh 获得指定颜色的拷贝
         */
        static clone<Out extends IColorLike>(a: Out): Color;
        /**
         * @zh 复制目标颜色
         */
        static copy<Out extends IColorLike>(out: Out, a: Out): Out;
        /**
         * @zh 设置颜色值
         */
        static set<Out extends IColorLike>(out: Out, r: number, g: number, b: number, a: number): Out;
        /**
         * @zh 从十六进制颜色字符串中读入颜色到 out 中
         */
        static fromHEX<Out extends IColorLike>(out: Out, hexString: string): Out;
        /**
         * @zh 逐通道颜色加法
         */
        static add<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐通道颜色减法
         */
        static subtract<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐通道颜色乘法
         */
        static multiply<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 逐通道颜色除法
         */
        static divide<Out extends IColorLike>(out: Out, a: Out, b: Out): Out;
        /**
         * @zh 全通道统一缩放颜色
         */
        static scale<Out extends IColorLike>(out: Out, a: Out, b: number): Out;
        /**
         * @zh 逐通道颜色线性插值：A + t * (B - A)
         */
        static lerp<Out extends IColorLike>(out: Out, from: Out, to: Out, ratio: number): Out;
        /**
         * @zh 颜色转数组
         * @param ofs 数组起始偏移量
         */
        static toArray<Out extends IWritableArrayLike<number>>(out: Out, a: IColorLike, ofs?: number): Out;
        /**
         * @zh 数组转颜色
         * @param ofs 数组起始偏移量
         */
        static fromArray<Out extends IColorLike>(arr: IWritableArrayLike<number>, out: Out, ofs?: number): Out;
        /**
         * @zh 颜色等价判断
         */
        static strictEquals<Out extends IColorLike>(a: Out, b: Out): boolean;
        /**
         * @zh 排除浮点数误差的颜色近似等价判断
         */
        static equals<Out extends IColorLike>(a: Out, b: Out, epsilon?: number): boolean;
        /**
         * @zh 获取指定颜色的整型数据表示
         */
        static hex<Out extends IColorLike>(a: Out): number;
        /**
         * @zh 获取或设置当前颜色的 Red 通道。
         */
        get r(): number;
        set r(red: number);
        /**
         * @zh 获取或设置当前颜色的 Green 通道。
         */
        get g(): number;
        set g(green: number);
        /**
         * @zh 获取或设置当前颜色的 Blue 通道。
         */
        get b(): number;
        set b(blue: number);
        /**
         * @zh 获取或设置当前颜色的 Alpha 通道。
         */
        get a(): number;
        set a(alpha: number);
        get x(): number;
        set x(value: number);
        get y(): number;
        set y(value: number);
        get z(): number;
        set z(value: number);
        get w(): number;
        set w(value: number);
        _val: number;
        /**
         * 构造与指定颜色相等的颜色。
         * @param other 指定的颜色。
         */
        constructor(other: Color);
        /**
         * @zh 用十六进制颜色字符串中构造颜色。
         * @param hexString 十六进制颜色字符串。
         */
        constructor(hexString: string);
        /**
         * @zh 构造具有指定通道的颜色。
         * @param [r=0] 指定的 Red 通道。
         * @param [g=0] 指定的 Green 通道。
         * @param [b=0] 指定的 Blue 通道。
         * @param [a=255] 指定的 Alpha 通道。
         */
        constructor(r?: number, g?: number, b?: number, a?: number);
        /**
         * @zh 克隆当前颜色。
         */
        clone(): Color;
        /**
         * @zh 判断当前颜色是否与指定颜色相等。
         * @param other 相比较的颜色。
         * @returns 两颜色的各通道都相等时返回 `true`；否则返回 `false`。
         */
        equals(other: Color): boolean;
        /**
         * @zh 根据指定的插值比率，从当前颜色到目标颜色之间做插值。
         * @param to 目标颜色。
         * @param ratio 插值比率，范围为 [0,1]。
         */
        lerp(to: Color, ratio: number): this;
        /**
         * @zh 返回当前颜色的字符串表示。
         * @returns 当前颜色的字符串表示。
         */
        toString(): string;
        /**
         * @zh 将当前颜色转换为 CSS 格式。
         * @param opt 格式选项。
         * @returns 当前颜色的 CSS 格式。
         */
        toCSS(opt: 'rgba' | 'rgb' | '#rrggbb' | '#rrggbbaa'): string;
        /**
         * @zh 从十六进制颜色字符串中读入当前颜色。<br/>
         * 十六进制颜色字符串应该以可选的 "#" 开头，紧跟最多 8 个代表十六进制数字的字符；<br/>
         * 每两个连续字符代表的数值依次作为 Red、Green、Blue 和 Alpha 通道；<br/>
         * 缺省的颜色通道将视为 0；缺省的透明通道将视为 255。<br/>
         * @param hexString 十六进制颜色字符串。
         * @returns `this`
         */
        fromHEX(hexString: string): this;
        /**
         * @zh 转换当前颜色为十六进制颜色字符串。
         * @param fmt 格式选项。
         * - `'#rrggbbaa'` 获取Red、Green、Blue、Alpha通道的十六进制值（**两位**，高位补 0）并依次连接；
         * - `'#rrggbb` 与 `'#rrggbbaa'` 类似但不包括 Alpha 通道。
         * @returns 十六进制颜色字符串。
         * @example
         * ```
         * const color = new Color(255, 14, 0, 255);
         * color.toHEX("#rgb");      // "f00";
         * color.toHEX("#rrggbbaa"); // "ff0e00"
         * color.toHEX("#rrggbb");   // "ff0e00ff"
         * ```
         */
        toHEX(fmt: '#rgb' | '#rrggbb' | '#rrggbbaa'): string;
        /**
         * @zh 将当前颜色转换为 RGB 整数值。
         * @returns RGB 整数值。从最低有效位开始，每8位分别是 Red、Green、Blue 通道的值。
         * @example
         * ```
         * const color = Color.YELLOW;
         * color.toRGBValue();
         * ```
         */
        toRGBValue(): number;
        /**
         * @zh 从 HSV 颜色中读入当前颜色。
         * @param h H 通道。
         * @param s S 通道。
         * @param v V 通道。
         * @returns `this`
         * @example
         * ```
         * const color = Color.YELLOW;
         * color.fromHSV(0, 0, 1); // Color {r: 255, g: 255, b: 255, a: 255};
         * ```
         */
        fromHSV(h: number, s: number, v: number): this;
        /**
         * @zh 转换当前颜色为 HSV 颜色。
         * @returns HSV 颜色。成员 `h`、`s`、`v` 分别代表 HSV 颜色的 H、S、V 通道。
         * @example
         * ```
         * import { Color } from 'cc';
         * const color = Color.YELLOW;
         * color.toHSV(); // {h: 0.1533864541832669, s: 0.9843137254901961, v: 1}
         * ```
         */
        toHSV(): {
            h: number;
            s: number;
            v: number;
        };
        /**
         * @zh 设置当前颜色使其与指定颜色相等。
         * @param other 相比较的颜色。
         * @overload 重载
         * @param [r=0] 指定的 Red 通道，[0-255]。
         * @param [g=0] 指定的 Green 通道。
         * @param [b=0] 指定的 Blue 通道。
         * @param [a=255] 指定的 Alpha 通道。
         * @returns 当前颜色。
         */
        set(other: Color): Color;
        set(r?: number, g?: number, b?: number, a?: number): Color;
        /**
         * @zh 将当前颜色乘以与指定颜色
         * @param other 指定的颜色。
         */
        multiply(other: Color): this;
        _set_r_unsafe(red: any): this;
        _set_g_unsafe(green: any): this;
        _set_b_unsafe(blue: any): this;
        _set_a_unsafe(alpha: any): this;
    }
    export function color(other: Color | string): Color;
    export function color(r?: number, g?: number, b?: number, a?: number): Color;
}
declare module "cocos/core/utils/deprecated" {
    export function setDefaultLogTimes(times: number): void;
    interface IReplacement {
        /** 废弃属性的名称 */
        name: string;
        /** 警告的次数 */
        logTimes?: number;
        /** 替换属性的名称 */
        newName?: string;
        /** 废弃属性的所属对象 */
        target?: object;
        /** 废弃属性的所属对象的名称 */
        targetName?: string;
        /** 自定义替换属性（函数） */
        customFunction?: Function;
        /** 自定义替换属性的 setter */
        customSetter?: (v: any) => void;
        /** 自定义替换属性的 getter */
        customGetter?: () => any;
    }
    interface IRemoveItem {
        /** 废弃属性的名称 */
        name: string;
        /** 警告的次数 */
        logTimes?: number;
        /** 额外建议 */
        suggest?: string;
    }
    interface IMarkItem {
        /** 废弃属性的名称 */
        name: string;
        /** 警告的次数 */
        logTimes?: number;
        /** 额外建议 */
        suggest?: string;
    }
    export let replaceProperty: (owner: object, ownerName: string, properties: IReplacement[]) => void;
    export let removeProperty: (owner: object, ownerName: string, properties: IRemoveItem[]) => void;
    export let markAsWarning: (owner: object, ownerName: string, properties: IMarkItem[]) => void;
}
declare module "cocos/core/math/deprecated" { }
declare module "cocos/core/math/index" {
    /**
     * @hidden
     */
    import * as bits from "cocos/core/math/bits";
    /**
     * Export module bits.
     */
    export { bits };
    export { Vec2, v2 } from "cocos/core/math/vec2";
    export { Vec3, v3 } from "cocos/core/math/vec3";
    export { Vec4, v4 } from "cocos/core/math/vec4";
    export { Quat, quat } from "cocos/core/math/quat";
    export { Mat3 } from "cocos/core/math/mat3";
    export { Mat4, mat4 } from "cocos/core/math/mat4";
    export { AffineTransform } from "cocos/core/math/affine-transform";
    export { Size, size } from "cocos/core/math/size";
    export { Rect, rect } from "cocos/core/math/rect";
    export { Color, color } from "cocos/core/math/color";
    export * from "cocos/core/math/utils";
    export * from "cocos/core/math/type-define";
    import "cocos/core/math/deprecated";
}
declare module "cocos/core/platform/event-manager/touch" {
    /**
     * @category event
     */
    import { Vec2 } from "cocos/core/math/index";
    /**
     * @en The touch point class
     * @zh 封装了触点相关的信息。
     */
    export class Touch {
        private _point;
        private _prevPoint;
        private _lastModified;
        private _id;
        private _startPoint;
        private _startPointCaptured;
        get lastModified(): number;
        /**
         * @param x - x position of the touch point
         * @param y - y position of the touch point
         * @param id - The id of the touch point
         */
        constructor(x: number, y: number, id?: number);
        /**
         * @en Returns the current touch location in OpenGL coordinates.、
         * @zh 获取当前触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: Vec2): Vec2;
        /**
         * @en Returns X axis location value.
         * @zh 获取当前触点 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns Y axis location value.
         * @zh 获取当前触点 Y 轴位置。
         */
        getLocationY(): number;
        /**
         * @en Returns the current touch location in UI coordinates.、
         * @zh 获取当前触点在 UI 坐标系中的位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: Vec2): Vec2;
        /**
         * @en Returns X axis location value in UI coordinates.
         * @zh 获取当前触点在 UI 坐标系中 X 轴位置。
         */
        getUILocationX(): number;
        /**
         * @en Returns Y axis location value in UI coordinates.
         * @zh 获取当前触点在 UI 坐标系中 Y 轴位置。
         */
        getUILocationY(): number;
        /**
         * @en Returns the previous touch location.
         * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the previous touch location in UI coordinates.
         * @zh 获取触点在上一次事件时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIPreviousLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the start touch location.
         * @zh 获获取触点落下时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the start touch location in UI coordinates.
         * @zh 获获取触点落下时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIStartLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the delta distance from the previous touche to the current one.
         * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the delta distance from the previous touche to the current one in UI coordinates.
         * @zh 获取触点距离上一次事件移动在 UI 坐标系中的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the current touch location in screen coordinates.
         * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: Vec2): Vec2;
        /**
         * @en Returns the previous touch location in screen coordinates.
         * @zh 获取触点在上一次事件时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocationInView(out?: Vec2): Vec2;
        /**
         * @en Returns the start touch location in screen coordinates.
         * @zh 获取触点落下时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocationInView(out?: Vec2): Vec2;
        /**
         * @en Returns the id of the touch point.
         * @zh 触点的标识 ID，可以用来在多点触摸中跟踪触点。
         */
        getID(): number;
        /**
         * @en Resets touch point information.
         * @zh 重置触点相关的信息。
         * @param id - The id of the touch point
         * @param x - x position of the touch point
         * @param y - y position of the touch point
         */
        setTouchInfo(id?: number, x?: number, y?: number): void;
        /**
         * @en Sets touch point location.
         * @zh 设置触点位置。
         * @param point - The location
         */
        setPoint(point: Vec2): void;
        /**
         * @en Sets touch point location.
         * @zh 设置触点位置。
         * @param x - x position
         * @param y - y position
         */
        setPoint(x: number, y: number): void;
        /**
         * @en Sets the location previously registered for the current touch.
         * @zh 设置触点在前一次触发时收集的位置。
         * @param point - The location
         */
        setPrevPoint(point: Vec2): void;
        /**
         * @en Sets the location previously registered for the current touch.
         * @zh 设置触点在前一次触发时收集的位置。
         * @param x - x position
         * @param y - y position
         */
        setPrevPoint(x: number, y: number): void;
    }
}
declare module "cocos/core/platform/macro" {
    /**
     * @en
     * Predefined constants
     * @zh
     * 预定义常量。
     */
    const macro: {
        /**
         * @en
         * The image format supported by the engine defaults, and the supported formats may differ in different build platforms and device types.
         * Currently all platform and device support ['.webp', '.jpg', '.jpeg', '.bmp', '.png'], ios mobile platform
         * @zh
         * 引擎默认支持的图片格式，支持的格式可能在不同的构建平台和设备类型上有所差别。
         * 目前所有平台和设备支持的格式有 ['.webp', '.jpg', '.jpeg', '.bmp', '.png']. The iOS mobile platform also supports the PVR format。
         */
        SUPPORT_TEXTURE_FORMATS: string[];
        /**
         * @en Key map for keyboard event
         * @zh 键盘事件的按键值。
         * @example {@link cocos/core/platform/CCCommon/KEY.js}
         */
        KEY: {
            /**
             * @en None
             * @zh 没有分配
             * @readonly
             */
            none: number;
            /**
             * @en The back key
             * @zh 返回键
             * @readonly
             */
            back: number;
            /**
             * @en The menu key
             * @zh 菜单键
             * @readonly
             */
            menu: number;
            /**
             * @en The backspace key
             * @zh 退格键
             * @readonly
             */
            backspace: number;
            /**
             * @en The tab key
             * @zh Tab 键
             * @readonly
             */
            tab: number;
            /**
             * @en The enter key
             * @zh 回车键
             * @readonly
             */
            enter: number;
            /**
             * @en The shift key
             * @zh Shift 键
             * @readonly
             */
            shift: number;
            /**
             * @en The ctrl key
             * @zh Ctrl 键
             * @readonly
             */
            ctrl: number;
            /**
             * @en The alt key
             * @zh Alt 键
             * @readonly
             */
            alt: number;
            /**
             * @en The pause key
             * @zh 暂停键
             * @readonly
             */
            pause: number;
            /**
             * @en The caps lock key
             * @zh 大写锁定键
             * @readonly
             */
            capslock: number;
            /**
             * @en The esc key
             * @zh ESC 键
             * @readonly
             */
            escape: number;
            /**
             * @en The space key
             * @zh 空格键
             * @readonly
             */
            space: number;
            /**
             * @en The page up key
             * @zh 向上翻页键
             * @readonly
             */
            pageup: number;
            /**
             * @en The page down key
             * @zh 向下翻页键
             * @readonly
             */
            pagedown: number;
            /**
             * @en The end key
             * @zh 结束键
             * @readonly
             */
            end: number;
            /**
             * @en The home key
             * @zh 主菜单键
             * @readonly
             */
            home: number;
            /**
             * @en The left key
             * @zh 向左箭头键
             * @readonly
             */
            left: number;
            /**
             * @en The up key
             * @zh 向上箭头键
             * @readonly
             */
            up: number;
            /**
             * @en The right key
             * @zh 向右箭头键
             * @readonly
             */
            right: number;
            /**
             * @en The down key
             * @zh 向下箭头键
             * @readonly
             */
            down: number;
            /**
             * @en The select key
             * @zh Select 键
             * @readonly
             */
            select: number;
            /**
             * @en The insert key
             * @zh 插入键
             * @readonly
             */
            insert: number;
            /**
             * @en The Delete key
             * @zh 删除键
             * @readonly
             */
            Delete: number;
            /**
             * @en The '0' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 0 键
             * @readonly
             */
            0: number;
            /**
             * @en The '1' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 1 键
             * @readonly
             */
            1: number;
            /**
             * @en The '2' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 2 键
             * @readonly
             */
            2: number;
            /**
             * @en The '3' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 3 键
             * @readonly
             */
            3: number;
            /**
             * @en The '4' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 4 键
             * @readonly
             */
            4: number;
            /**
             * @en The '5' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 5 键
             * @readonly
             */
            5: number;
            /**
             * @en The '6' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 6 键
             * @readonly
             */
            6: number;
            /**
             * @en The '7' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 7 键
             * @readonly
             */
            7: number;
            /**
             * @en The '8' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 8 键
             * @readonly
             */
            8: number;
            /**
             * @en The '9' key on the top of the alphanumeric keyboard.
             * @zh 字母键盘上的 9 键
             * @readonly
             */
            9: number;
            /**
             * @en The a key
             * @zh A 键
             * @readonly
             */
            a: number;
            /**
             * @en The b key
             * @zh B 键
             * @readonly
             */
            b: number;
            /**
             * @en The c key
             * @zh C 键
             * @readonly
             */
            c: number;
            /**
             * @en The d key
             * @zh D 键
             * @readonly
             */
            d: number;
            /**
             * @en The e key
             * @zh E 键
             * @readonly
             */
            e: number;
            /**
             * @en The f key
             * @zh F 键
             * @readonly
             */
            f: number;
            /**
             * @en The g key
             * @zh G 键
             * @readonly
             */
            g: number;
            /**
             * @en The h key
             * @zh H 键
             * @readonly
             */
            h: number;
            /**
             * @en The i key
             * @zh I 键
             * @readonly
             */
            i: number;
            /**
             * @en The j key
             * @zh J 键
             * @readonly
             */
            j: number;
            /**
             * @en The k key
             * @zh K 键
             * @readonly
             */
            k: number;
            /**
             * @en The l key
             * @zh L 键
             * @readonly
             */
            l: number;
            /**
             * @en The m key
             * @zh M 键
             * @readonly
             */
            m: number;
            /**
             * @en The n key
             * @zh N 键
             * @readonly
             */
            n: number;
            /**
             * @en The o key
             * @zh O 键
             * @readonly
             */
            o: number;
            /**
             * @en The p key
             * @zh P 键
             * @readonly
             */
            p: number;
            /**
             * @en The q key
             * @zh Q 键
             * @readonly
             */
            q: number;
            /**
             * @en The r key
             * @zh R 键
             * @readonly
             */
            r: number;
            /**
             * @en The s key
             * @zh S 键
             * @readonly
             */
            s: number;
            /**
             * @en The t key
             * @zh T 键
             * @readonly
             */
            t: number;
            /**
             * @en The u key
             * @zh U 键
             * @readonly
             */
            u: number;
            /**
             * @en The v key
             * @zh V 键
             * @readonly
             */
            v: number;
            /**
             * @en The w key
             * @zh W 键
             * @readonly
             */
            w: number;
            /**
             * @en The x key
             * @zh X 键
             * @readonly
             */
            x: number;
            /**
             * @en The y key
             * @zh Y 键
             * @readonly
             */
            y: number;
            /**
             * @en The z key
             * @zh Z 键
             * @readonly
             */
            z: number;
            /**
             * @en The numeric keypad 0
             * @zh 数字键盘 0
             * @readonly
             */
            num0: number;
            /**
             * @en The numeric keypad 1
             * @zh 数字键盘 1
             * @readonly
             */
            num1: number;
            /**
             * @en The numeric keypad 2
             * @zh 数字键盘 2
             * @readonly
             */
            num2: number;
            /**
             * @en The numeric keypad 3
             * @zh 数字键盘 3
             * @readonly
             */
            num3: number;
            /**
             * @en The numeric keypad 4
             * @zh 数字键盘 4
             * @readonly
             */
            num4: number;
            /**
             * @en The numeric keypad 5
             * @zh 数字键盘 5
             * @readonly
             */
            num5: number;
            /**
             * @en The numeric keypad 6
             * @zh 数字键盘 6
             * @readonly
             */
            num6: number;
            /**
             * @en The numeric keypad 7
             * @zh 数字键盘 7
             * @readonly
             */
            num7: number;
            /**
             * @en The numeric keypad 8
             * @zh 数字键盘 8
             * @readonly
             */
            num8: number;
            /**
             * @en The numeric keypad 9
             * @zh 数字键盘 9
             * @readonly
             */
            num9: number;
            /**
             * @en The numeric keypad '*'
             * @zh 数字键盘 *
             * @readonly
             */
            '*': number;
            /**
             * @en The numeric keypad '+'
             * @zh 数字键盘 +
             * @readonly
             */
            '+': number;
            /**
             * @en The numeric keypad '-'
             * @zh 数字键盘 -
             * @readonly
             */
            '-': number;
            /**
             * @en The numeric keypad 'delete'
             * @zh 数字键盘删除键
             * @readonly
             */
            numdel: number;
            /**
             * @en The numeric keypad '/'
             * @zh 数字键盘 /
             * @readonly
             */
            '/': number;
            /**
             * @en The F1 function key
             * @zh F1 功能键
             * @readonly
             */
            f1: number;
            /**
             * @en The F2 function key
             * @zh F2 功能键
             * @readonly
             */
            f2: number;
            /**
             * @en The F3 function key
             * @zh F3 功能键
             * @readonly
             */
            f3: number;
            /**
             * @en The F4 function key
             * @zh F4 功能键
             * @readonly
             */
            f4: number;
            /**
             * @en The F5 function key
             * @zh F5 功能键
             * @readonly
             */
            f5: number;
            /**
             * @en The F6 function key
             * @zh F6 功能键
             * @readonly
             */
            f6: number;
            /**
             * @en The F7 function key
             * @zh F7 功能键
             * @readonly
             */
            f7: number;
            /**
             * @en The F8 function key
             * @zh F8 功能键
             * @readonly
             */
            f8: number;
            /**
             * @en The F9 function key
             * @zh F9 功能键
             * @readonly
             */
            f9: number;
            /**
             * @en The F10 function key
             * @zh F10 功能键
             * @readonly
             */
            f10: number;
            /**
             * @en The F11 function key
             * @zh F11 功能键
             * @readonly
             */
            f11: number;
            /**
             * @en The F12 function key
             * @zh F12 功能键
             * @readonly
             */
            f12: number;
            /**
             * @en The numlock key
             * @zh 数字锁定键
             * @readonly
             */
            numlock: number;
            /**
             * @en The scroll lock key
             * @zh 滚动锁定键
             * @readonly
             */
            scrolllock: number;
            /**
             * @en The ';' key.
             * @zh 分号键
             * @readonly
             */
            ';': number;
            /**
             * @en The ';' key.
             * @zh 分号键
             * @readonly
             */
            semicolon: number;
            /**
             * @en The '=' key.
             * @zh 等于号键
             * @readonly
             */
            equal: number;
            /**
             * @en The '=' key.
             * @zh 等于号键
             * @readonly
             */
            '=': number;
            /**
             * @en The ',' key.
             * @zh 逗号键
             * @readonly
             */
            ',': number;
            /**
             * @en The ',' key.
             * @zh 逗号键
             * @readonly
             */
            comma: number;
            /**
             * @en The dash '-' key.
             * @zh 中划线键
             * @readonly
             */
            dash: number;
            /**
             * @en The '.' key.
             * @zh 句号键
             * @readonly
             */
            '.': number;
            /**
             * @en The '.' key
             * @zh 句号键
             * @readonly
             */
            period: number;
            /**
             * @en The forward slash key
             * @zh 正斜杠键
             * @readonly
             */
            forwardslash: number;
            /**
             * @en The grave key
             * @zh 按键 `
             * @readonly
             */
            grave: number;
            /**
             * @en The '[' key
             * @zh 按键 [
             * @readonly
             */
            '[': number;
            /**
             * @en The '[' key
             * @zh 按键 [
             * @readonly
             */
            openbracket: number;
            /**
             * @en The '\' key
             * @zh 反斜杠键
             * @readonly
             */
            backslash: number;
            /**
             * @en The ']' key
             * @zh 按键 ]
             * @readonly
             */
            ']': number;
            /**
             * @en The ']' key
             * @zh 按键 ]
             * @readonly
             */
            closebracket: number;
            /**
             * @en The quote key
             * @zh 单引号键
             * @readonly
             */
            quote: number;
            /**
             * @en The dpad left key
             * @zh 导航键 向左
             * @readonly
             */
            dpadLeft: number;
            /**
             * @en The dpad right key
             * @zh 导航键 向右
             * @readonly
             */
            dpadRight: number;
            /**
             * @en The dpad up key
             * @zh 导航键 向上
             * @readonly
             */
            dpadUp: number;
            /**
             * @en The dpad down key
             * @zh 导航键 向下
             * @readonly
             */
            dpadDown: number;
            /**
             * @en The dpad center key
             * @zh 导航键 确定键
             * @readonly
             */
            dpadCenter: number;
        };
        /**
         * PI / 180
         */
        RAD: number;
        /**
         * One degree
         */
        DEG: number;
        /**
         * A maximum value of number
         */
        REPEAT_FOREVER: number;
        /**
         * A minimal float value
         */
        FLT_EPSILON: number;
        /**
         * @en Oriented vertically
         * @zh 竖屏朝向
         */
        ORIENTATION_PORTRAIT: number;
        /**
         * @en Oriented horizontally
         * @zh 横屏朝向
         */
        ORIENTATION_LANDSCAPE: number;
        /**
         * @en Oriented automatically
         * @zh 自动适配朝向
         */
        ORIENTATION_AUTO: number;
        /**
         * <p>
         *   If enabled, the texture coordinates will be calculated by using this formula: <br/>
         *      - texCoord.left = (rect.x*2+1) / (texture.wide*2);                  <br/>
         *      - texCoord.right = texCoord.left + (rect.width*2-2)/(texture.wide*2); <br/>
         *                                                                                 <br/>
         *  The same for bottom and top.                                                   <br/>
         *                                                                                 <br/>
         *  This formula prevents artifacts by using 99% of the texture.                   <br/>
         *  The "correct" way to prevent artifacts is by expand the texture's border with the same color by 1 pixel<br/>
         *                                                                                  <br/>
         *  Affected component:                                                                 <br/>
         *      - TMXLayer                                                       <br/>
         *                                                                                  <br/>
         *  Enabled by default. To disabled set it to 0. <br/>
         *  To modify it, in Web engine please refer to CCMacro.js, in JSB please refer to CCConfig.h
         * </p>
         * Currently not useful in 3D engine
         */
        /**
         * @en
         * Whether or not enabled tiled map auto culling. If you set the TiledMap skew or rotation,
         * then need to manually disable this, otherwise, the rendering will be wrong.
         * Currently not useful in 3D engine
         * @zh
         * 是否开启瓦片地图的自动裁减功能。瓦片地图如果设置了 skew, rotation 的话，需要手动关闭，否则渲染会出错。
         * 在 3D 引擎中暂时无效。
         * @default true
         */
        ENABLE_TILEDMAP_CULLING: boolean;
        /**
         * @en
         * The timeout to determine whether a touch is no longer active and should be removed.
         * The reason to add this timeout is due to an issue in X5 browser core,
         * when X5 is presented in wechat on Android, if a touch is glissed from the bottom up, and leave the page area,
         * no touch cancel event is triggered, and the touch will be considered active forever.
         * After multiple times of this action, our maximum touches number will be reached and all new touches will be ignored.
         * So this new mechanism can remove the touch that should be inactive if it's not updated during the last 5000 milliseconds.
         * Though it might remove a real touch if it's just not moving for the last 5 seconds which is not easy with the sensibility of mobile touch screen.
         * You can modify this value to have a better behavior if you find it's not enough.
         * @zh
         * 用于甄别一个触点对象是否已经失效并且可以被移除的延时时长
         * 添加这个时长的原因是 X5 内核在微信浏览器中出现的一个 bug。
         * 在这个环境下，如果用户将一个触点从底向上移出页面区域，将不会触发任何 touch cancel 或 touch end 事件，而这个触点会被永远当作停留在页面上的有效触点。
         * 重复这样操作几次之后，屏幕上的触点数量将达到我们的事件系统所支持的最高触点数量，之后所有的触摸事件都将被忽略。
         * 所以这个新的机制可以在触点在一定时间内没有任何更新的情况下视为失效触点并从事件系统中移除。
         * 当然，这也可能移除一个真实的触点，如果用户的触点真的在一定时间段内完全没有移动（这在当前手机屏幕的灵敏度下会很难）。
         * 你可以修改这个值来获得你需要的效果，默认值是 5000 毫秒。
         * @default 5000
         */
        TOUCH_TIMEOUT: number;
        /**
         * @en
         * The max concurrent task number for the downloader
         * @zh
         * 下载任务的最大并发数限制，在安卓平台部分机型或版本上可能需要限制在较低的水平
         * @default 64
         */
        DOWNLOAD_MAX_CONCURRENT: number;
        /**
         * @en
         * Boolean that indicates if the canvas contains an alpha channel, default sets to false for better performance.
         * Though if you want to make your canvas background transparent and show other dom elements at the background,
         * you can set it to true before {{game.init}}.
         * Web only.
         * @zh
         * 用于设置 Canvas 背景是否支持 alpha 通道，默认为 false，这样可以有更高的性能表现。
         * 如果你希望 Canvas 背景是透明的，并显示背后的其他 DOM 元素，你可以在 {{game.init}} 之前将这个值设为 true。
         * 仅支持 Web
         * @default false
         */
        ENABLE_TRANSPARENT_CANVAS: boolean;
        /**
         * @en
         * Boolean that indicates if the WebGL context is created with `antialias` option turned on, default value is false.
         * Set it to true could make your game graphics slightly smoother, like texture hard edges when rotated.
         * Whether to use this really depend on your game design and targeted platform,
         * device with retina display usually have good detail on graphics with or without this option,
         * you probably don't want antialias if your game style is pixel art based.
         * Also, it could have great performance impact with some browser / device using software MSAA.
         * You can set it to true before {{game.init}}.
         * Web only.
         * @zh
         * 用于设置在创建 WebGL Context 时是否开启抗锯齿选项，默认值是 false。
         * 将这个选项设置为 true 会让你的游戏画面稍稍平滑一些，比如旋转硬边贴图时的锯齿。是否开启这个选项很大程度上取决于你的游戏和面向的平台。
         * 在大多数拥有 retina 级别屏幕的设备上用户往往无法区分这个选项带来的变化；如果你的游戏选择像素艺术风格，你也多半不会想开启这个选项。
         * 同时，在少部分使用软件级别抗锯齿算法的设备或浏览器上，这个选项会对性能产生比较大的影响。
         * 你可以在 {{game.init}} 之前设置这个值，否则它不会生效。
         * 仅支持 Web
         * @default false
         */
        ENABLE_WEBGL_ANTIALIAS: boolean;
        /**
         * @en
         * Whether or not clear dom Image object cache after uploading to gl texture.
         * Concretely, we are setting image.src to empty string to release the cache.
         * Normally you don't need to enable this option, because on web the Image object doesn't consume too much memory.
         * But on Wechat Game platform, the current version cache decoded data in Image object, which has high memory usage.
         * So we enabled this option by default on Wechat, so that we can release Image cache immediately after uploaded to GPU.
         * Currently not useful in 3D engine
         * @zh
         * 是否在将贴图上传至 GPU 之后删除 DOM Image 缓存。
         * 具体来说，我们通过设置 image.src 为空字符串来释放这部分内存。
         * 正常情况下，你不需要开启这个选项，因为在 web 平台，Image 对象所占用的内存很小。
         * 但是在微信小游戏平台的当前版本，Image 对象会缓存解码后的图片数据，它所占用的内存空间很大。
         * 所以我们在微信平台默认开启了这个选项，这样我们就可以在上传 GL 贴图之后立即释放 Image 对象的内存，避免过高的内存占用。
         * 在 3D 引擎中暂时无效。
         * @default false
         */
        CLEANUP_IMAGE_CACHE: boolean;
        /**
         * @en
         * Whether to enable multi-touch.
         * @zh
         * 是否开启多点触摸
         * @default true
         */
        ENABLE_MULTI_TOUCH: boolean;
    };
    export { macro };
}
declare module "cocos/core/platform/sys" {
    /**
     * @en A set of system related variables
     * @zh 一系列系统相关环境变量
     * @main
     */
    export const sys: {
        [x: string]: any;
    };
}
declare module "cocos/core/platform/event-manager/event-manager" {
    /**
     * @hidden
     */
    import { Event } from "cocos/core/event/index";
    import { EventListener } from "cocos/core/platform/event-manager/event-listener";
    import { Node } from "cocos/core/scene-graph/index";
    class EventManager {
        private _listenersMap;
        private _priorityDirtyFlagMap;
        private _nodeListenersMap;
        private _toAddedListeners;
        private _toRemovedListeners;
        private _dirtyListeners;
        private _inDispatch;
        private _isEnabled;
        private _internalCustomListenerIDs;
        private _currentTouch;
        private _currentTouchListener;
        /**
         * @en Pauses all listeners which are associated the specified target.
         * @zh 暂停传入的 node 相关的所有监听器的事件响应。
         * @param node - 暂停目标节点
         * @param recursive - 是否往子节点递归暂停。默认为 false。
         */
        pauseTarget(node: Node, recursive?: boolean): void;
        /**
         * @en
         * Resumes all listeners which are associated the specified target.
         *
         * @zh
         * 恢复传入的 node 相关的所有监听器的事件响应。
         *
         * @param node - 监听器节点。
         * @param recursive - 是否往子节点递归。默认为 false。
         */
        resumeTarget(node: Node, recursive?: boolean): void;
        frameUpdateListeners(): void;
        /**
         * @en
         * Query whether the specified event listener id has been added.
         *
         * @zh
         * 查询指定的事件 ID 是否存在。
         *
         * @param listenerID - 查找监听器 ID。
         * @returns 是否已查找到。
         */
        hasEventListener(listenerID: string): boolean;
        /**
         * @en
         * <p>
         * Adds a event listener for a specified event.<br/>
         * if the parameter "nodeOrPriority" is a node,
         * it means to add a event listener for a specified event with the priority of scene graph.<br/>
         * if the parameter "nodeOrPriority" is a Number,
         * it means to add a event listener for a specified event with the fixed priority.<br/>
         * </p>
         *
         * @zh
         * 将事件监听器添加到事件管理器中。<br/>
         * 如果参数 “nodeOrPriority” 是节点，优先级由 node 的渲染顺序决定，显示在上层的节点将优先收到事件。<br/>
         * 如果参数 “nodeOrPriority” 是数字，优先级则固定为该参数的数值，数字越小，优先级越高。<br/>
         *
         * @param listener - 指定事件监听器。
         * @param nodeOrPriority - 监听程序的优先级。
         * @returns
         */
        addListener(listener: EventListener, nodeOrPriority: any | number): any;
        /**
         * @en
         * Adds a Custom event listener. It will use a fixed priority of 1.
         *
         * @zh
         * 向事件管理器添加一个自定义事件监听器。
         *
         * @param eventName - 自定义事件名。
         * @param callback - 事件回调。
         * @returns 返回自定义监听器。
         */
        addCustomListener(eventName: string, callback: Function): EventListener;
        /**
         * @en
         * Remove a listener.
         *
         * @zh
         * 移除一个已添加的监听器。
         *
         * @param listener - 需要移除的监听器。
         */
        removeListener(listener: EventListener): void;
        /**
         * @en
         * Removes all listeners with the same event listener type or removes all listeners of a node.
         *
         * @zh
         * 移除注册到 eventManager 中指定类型的所有事件监听器。<br/>
         * 1. 如果传入的第一个参数类型是 Node，那么事件管理器将移除与该对象相关的所有事件监听器。
         * （如果第二参数 recursive 是 true 的话，就会连同该对象的子控件上所有的事件监听器也一并移除）<br/>
         * 2. 如果传入的第一个参数类型是 Number（该类型 EventListener 中定义的事件类型），
         * 那么事件管理器将移除该类型的所有事件监听器。<br/>
         *
         * 下列是目前存在监听器类型：       <br/>
         * `EventListener.UNKNOWN`       <br/>
         * `EventListener.KEYBOARD`      <br/>
         * `EventListener.ACCELERATION`，<br/>
         *
         * @param listenerType - 监听器类型。
         * @param recursive - 递归子节点的同类型监听器一并移除。默认为 false。
         */
        removeListeners(listenerType: number | any, recursive?: boolean): void;
        /**
         * @en
         * Removes all custom listeners with the same event name.
         *
         * @zh
         * 移除同一事件名的自定义事件监听器。
         *
         * @param customEventName - 自定义事件监听器名。
         */
        removeCustomListeners(customEventName: any): void;
        /**
         * @en
         * Removes all listeners.
         *
         * @zh
         * 移除所有事件监听器。
         */
        removeAllListeners(): void;
        /**
         * @en
         * Sets listener's priority with fixed value.
         *
         * @zh
         * 设置 FixedPriority 类型监听器的优先级。
         *
         * @param listener - 监听器。
         * @param fixedPriority - 优先级。
         */
        setPriority(listener: EventListener, fixedPriority: number): void;
        /**
         * @en
         * Whether to enable dispatching events.
         *
         * @zh
         * 启用或禁用事件管理器，禁用后不会分发任何事件。
         *
         * @param enabled - 是否启用事件管理器。
         */
        setEnabled(enabled: boolean): void;
        /**
         * @en
         * Checks whether dispatching events is enabled.
         *
         * @zh 检测事件管理器是否启用。
         *
         * @returns
         */
        isEnabled(): boolean;
        /**
         * @en
         * Dispatches the event, also removes all EventListeners marked for deletion from the event dispatcher list.
         *
         * @zh
         * 分发事件。
         *
         * @param event - 分发事件。
         */
        dispatchEvent(event: Event): void;
        _onListenerCallback(listener: EventListener, event: Event): boolean;
        /**
         * @en
         * Dispatches a Custom Event with a event name an optional user data.
         *
         * @zh
         * 分发自定义事件。
         *
         * @param eventName - 自定义事件名。
         * @param optionalUserData
         */
        dispatchCustomEvent(eventName: any, optionalUserData: any): void;
        private _setDirtyForNode;
        private _addListener;
        private _forceAddEventListener;
        private _getListeners;
        private _updateDirtyFlagForSceneGraph;
        private _removeAllListenersInVector;
        private _removeListenersForListenerID;
        private _sortEventListeners;
        private _sortListenersOfSceneGraphPriority;
        private _sortEventListenersOfSceneGraphPriorityDes;
        private _sortListenersOfFixedPriority;
        private _sortListenersOfFixedPriorityAsc;
        private _onUpdateListeners;
        private _updateTouchListeners;
        private _cleanToRemovedListeners;
        private _onTouchEventCallback;
        private _dispatchTouchEvent;
        private _onTouchesEventCallback;
        private _associateNodeAndEventListener;
        private _dissociateNodeAndEventListener;
        private _dispatchEventToListeners;
        private _setDirty;
        private _sortNumberAsc;
        private _removeListenerInCallback;
        private _removeListenerInVector;
    }
    /**
     * @en
     * This class has been deprecated, please use `systemEvent` or `EventTarget` instead.
     * See [Listen to and launch events](../../../manual/en/scripting/events.md) for details.<br>
     * <br>
     * `eventManager` is a singleton object which manages event listener subscriptions and event dispatching.
     * The EventListener list is managed in such way so that event listeners can be added and removed
     * while events are being dispatched.
     *
     * @zh
     * 该类已废弃，请使用 `systemEvent` 或 `EventTarget` 代替，详见 [监听和发射事件](../../../manual/zh/scripting/events.md)。<br>
     * <br>
     * 事件管理器，它主要管理事件监听器注册和派发系统事件。
     *
     * @class eventManager
     * @static
     * @example {@link cocos/core/event-manager/CCEventManager/addListener.js}
     * @deprecated
     */
    export const eventManager: EventManager;
    export default eventManager;
}
declare module "cocos/core/platform/event-manager/input-manager" {
    import { EventMouse } from "cocos/core/platform/event-manager/events";
    import { Touch } from "cocos/core/platform/event-manager/touch";
    interface IHTMLElementPosition {
        left: number;
        top: number;
        width: number;
        height: number;
    }
    /**
     * @en the device accelerometer reports values for each axis in units of g-force.
     * @zh 设备重力传感器传递的各个轴的数据。
     */
    export class Acceleration {
        x: number;
        y: number;
        z: number;
        timestamp: number;
        constructor(x?: number, y?: number, z?: number, timestamp?: number);
    }
    /**
     *  This class manages all events of input. include: touch, mouse, accelerometer, keyboard
     */
    class InputManager {
        private _mousePressed;
        private _isRegisterEvent;
        private _preTouchPoint;
        private _prevMousePoint;
        private _preTouchPool;
        private _preTouchPoolPointer;
        private _touches;
        private _touchesIntegerDict;
        private _indexBitsUsed;
        private _maxTouches;
        private _accelEnabled;
        private _accelInterval;
        private _accelMinus;
        private _accelCurTime;
        private _acceleration;
        private _accelDeviceEvent;
        private _glView;
        private _pointLocked;
        handleTouchesBegin(touches: Touch[]): void;
        handleTouchesMove(touches: Touch[]): void;
        handleTouchesEnd(touches: Touch[]): void;
        handleTouchesCancel(touches: Touch[]): void;
        getSetOfTouchesEndOrCancel(touches: Touch[]): Touch[];
        getHTMLElementPosition(element: HTMLElement): IHTMLElementPosition;
        getPreTouch(touch: Touch): Touch;
        setPreTouch(touch: Touch): void;
        getTouchByXY(event: MouseEvent, tx: number, ty: number, pos: IHTMLElementPosition): Touch;
        getMouseEvent(location: {
            x: number;
            y: number;
        }, pos: IHTMLElementPosition, eventType: number): EventMouse;
        getPointByEvent(event: MouseEvent, pos: IHTMLElementPosition): {
            x: number;
            y: number;
        };
        getTouchesByEvent(event: TouchEvent, position: IHTMLElementPosition): Touch[];
        registerSystemEvent(element: HTMLElement | null): void;
        /**
         * Whether enable accelerometer event.
         */
        setAccelerometerEnabled(isEnable: boolean): void;
        didAccelerate(eventData: DeviceMotionEvent | DeviceOrientationEvent): void;
        update(dt: number): void;
        /**
         * set accelerometer interval value
         * @method setAccelerometerInterval
         * @param {Number} interval
         */
        setAccelerometerInterval(interval: any): void;
        private _getUnUsedIndex;
        private _removeUsedIndexBit;
        private _registerMouseEvents;
        private _registerPointerLockEvent;
        private _registerWindowMouseEvents;
        private _registerElementMouseEvents;
        private _registerMousePointerEvents;
        private _registerTouchEvents;
        private _registerKeyboardEvent;
        private _registerAccelerometerEvent;
        private _unregisterAccelerometerEvent;
        private _getUsefulTouches;
    }
    const inputManager: InputManager;
    export default inputManager;
}
declare module "cocos/core/platform/event-manager/events" {
    /**
     * @category event
     */
    import Event from "cocos/core/event/event";
    import { Vec2 } from "cocos/core/math/vec2";
    import { Touch } from "cocos/core/platform/event-manager/touch";
    import { Acceleration } from "cocos/core/platform/event-manager/input-manager";
    /**
     * @en The mouse event
     * @zh 鼠标事件类型
     */
    export class EventMouse extends Event {
        /**
         * @en The none event code of mouse event.
         * @zh 无效事件代码
         */
        static NONE: number;
        /**
         * @en The event code of mouse down event.
         * @zh 鼠标按下事件代码。
         */
        static DOWN: number;
        /**
         * @en The event code of mouse up event.
         * @zh 鼠标按下后释放事件代码。
         */
        static UP: number;
        /**
         * @en The event code of mouse move event.
         * @zh 鼠标移动事件。
         */
        static MOVE: number;
        /**
         * @en The event code of mouse scroll event.
         * @zh 鼠标滚轮事件。
         */
        static SCROLL: number;
        /**
         * @en The default tag when no button is pressed
         * @zh 按键默认的缺省状态
         */
        static BUTTON_MISSING: number;
        /**
         * @en The tag of mouse's left button.
         * @zh 鼠标左键的标签。
         */
        static BUTTON_LEFT: number;
        /**
         * @en The tag of mouse's right button  (The right button number is 2 on browser).
         * @zh 鼠标右键的标签。
         */
        static BUTTON_RIGHT: number;
        /**
         * @en The tag of mouse's middle button.
         * @zh 鼠标中键的标签。
         */
        static BUTTON_MIDDLE: number;
        /**
         * @en The tag of mouse's button 4.
         * @zh 鼠标按键 4 的标签。
         */
        static BUTTON_4: number;
        /**
         * @en The tag of mouse's button 5.
         * @zh 鼠标按键 5 的标签。
         */
        static BUTTON_5: number;
        /**
         * @en The tag of mouse's button 6.
         * @zh 鼠标按键 6 的标签。
         */
        static BUTTON_6: number;
        /**
         * @en The tag of mouse's button 7.
         * @zh 鼠标按键 7 的标签。
         */
        static BUTTON_7: number;
        /**
         * @en The tag of mouse's button 8.
         * @zh 鼠标按键 8 的标签。
         */
        static BUTTON_8: number;
        /**
         * @en Mouse movement on x axis of the UI coordinate system.
         * @zh 鼠标在 UI 坐标系下 X 轴上的移动距离
         */
        movementX: number;
        /**
         * @en Mouse movement on y axis of the UI coordinate system.
         * @zh 鼠标在 UI 坐标系下 Y 轴上的移动距离
         */
        movementY: number;
        /**
         * @en The type of the event, possible values are UP, DOWN, MOVE, SCROLL
         * @zh 鼠标事件类型，可以是 UP, DOWN, MOVE, CANCELED。
         */
        eventType: number;
        private _button;
        private _x;
        private _y;
        private _prevX;
        private _prevY;
        private _scrollX;
        private _scrollY;
        /**
         * @param eventType - The type of the event, possible values are UP, DOWN, MOVE, SCROLL
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         */
        constructor(eventType: number, bubbles?: boolean, prevLoc?: Vec2);
        /**
         * @en Sets scroll data of the mouse.
         * @zh 设置鼠标滚轮的滚动数据。
         * @param scrollX - The scroll value on x axis
         * @param scrollY - The scroll value on y axis
         */
        setScrollData(scrollX: number, scrollY: number): void;
        /**
         * @en Returns the scroll value on x axis.
         * @zh 获取鼠标滚动的 X 轴距离，只有滚动时才有效。
         */
        getScrollX(): number;
        /**
         * @en Returns the scroll value on y axis.
         * @zh 获取滚轮滚动的 Y 轴距离，只有滚动时才有效。
         */
        getScrollY(): number;
        /**
         * @en Sets cursor location.
         * @zh 设置当前鼠标位置。
         * @param x - The location on x axis
         * @param y - The location on y axis
         */
        setLocation(x: number, y: number): void;
        /**
         * @en Returns cursor location.
         * @zh 获取鼠标相对于左下角位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the current cursor location in game view coordinates.
         * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: Vec2): Vec2;
        /**
         * @en Returns the current cursor location in ui coordinates.
         * @zh 获取当前事件在 UI 窗口内的坐标位置，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: Vec2): Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIPreviousLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的 X 轴距离。
         */
        getDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location.
         * @zh 获取鼠标距离上一次事件移动的 Y 轴距离。
         */
        getDeltaY(): number;
        /**
         * @en Returns the delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 X 轴距离。
         */
        getUIDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location in the UI coordinates.
         * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 Y 轴距离。
         */
        getUIDeltaY(): number;
        /**
         * @en Sets mouse button code.
         * @zh 设置鼠标按键。
         * @param button - The button code
         */
        setButton(button: number): void;
        /**
         * @en Returns mouse button code.
         * @zh 获取鼠标按键。
         */
        getButton(): number;
        /**
         * @en Returns location data on X axis.
         * @zh 获取鼠标当前 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns location data on Y axis.
         * @zh 获取鼠标当前 Y 轴位置。
         */
        getLocationY(): number;
        /**
         * @en Returns location data on X axis.
         * @zh 获取鼠标当前 X 轴位置。
         */
        getUILocationX(): number;
        /**
         * @en Returns location data on Y axis.
         * @zh 获取鼠标当前 Y 轴位置。
         */
        getUILocationY(): number;
    }
    /**
     * @en
     * The touch event.
     *
     * @zh
     * 触摸事件。
     */
    export class EventTouch extends Event {
        /**
         * @en The maximum touch point numbers simultaneously
         * @zh 同时存在的最大触点数量。
         */
        static MAX_TOUCHES: number;
        /**
         * @en The event type code of touch began event.
         * @zh 开始触摸事件。
         */
        static BEGAN: number;
        /**
         * @en The event type code of touch moved event.
         * @zh 触摸后移动事件。
         */
        static MOVED: number;
        /**
         * @en The event type code of touch ended event.
         * @zh 结束触摸事件。
         */
        static ENDED: number;
        /**
         * @en The event type code of touch canceled event.
         * @zh 取消触摸事件。
         */
        static CANCELLED: number;
        /**
         * @en The current touch object
         * @zh 当前触点对象
         */
        touch: Touch | null;
        /**
         * @en Indicate whether the touch event is simulated or real
         * @zh 表示触摸事件是真实触点触发的还是模拟的
         */
        simulate: boolean;
        private _eventCode;
        private _touches;
        private _allTouches;
        /**
         * @param touches - An array of current touches
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         * @param eventCode - The type code of the touch event
         */
        constructor(changedTouches?: Touch[], bubbles?: boolean, eventCode?: number, touches?: Touch[]);
        /**
         * @en Returns event type code.
         * @zh 获取触摸事件类型。
         */
        getEventCode(): number;
        /**
         * @en Returns touches of event.
         * @zh 获取有变动的触摸点的列表。
         * 注意：第一根手指按下不动，接着按第二根手指，这时候触点信息就只有变动的这根手指（第二根手指）的信息。
         * 如果需要获取全部手指的信息，请使用 `getAllTouches`。
         */
        getTouches(): Touch[];
        /**
         * @en Returns touches of event.
         * @zh 获取所有触摸点的列表。
         * 注意：如果手指行为是 touch end，这个时候列表是没有该手指信息的。如需知道该手指信息，可通过 `getTouches` 获取识别。
         */
        getAllTouches(): Touch[];
        /**
         * @en Sets touch location.
         * @zh 设置当前触点位置
         * @param x - The current touch location on the x axis
         * @param y - The current touch location on the y axis
         */
        setLocation(x: number, y: number): void;
        /**
         * @en Returns the current touch location.
         * @zh 获取触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the current touch location in UI coordinates.
         * @zh 获取 UI 坐标系下的触点位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUILocation(out?: Vec2): Vec2;
        /**
         * @en Returns the current touch location in game screen coordinates.
         * @zh 获取当前触点在游戏窗口中的位置。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getLocationInView(out?: Vec2): Vec2;
        /**
         * @en Returns the previous touch location.
         * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getPreviousLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the start touch location.
         * @zh 获获取触点落下时的位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getStartLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the start touch location in UI coordinates.
         * @zh 获获取触点落下时的 UI 世界下位置对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getUIStartLocation(out?: Vec2): Vec2;
        /**
         * @en Returns the id of the current touch point.
         * @zh 获取触点的标识 ID，可以用来在多点触摸中跟踪触点。
         */
        getID(): number | null;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
         */
        getDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件 UI 世界下移动的距离对象，对象包含 x 和 y 属性。
         * @param out - Pass the out object to avoid object creation, very good practice
        */
        getUIDelta(out?: Vec2): Vec2;
        /**
         * @en Returns the X axis delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的 x 轴距离。
         */
        getDeltaX(): number;
        /**
         * @en Returns the Y axis delta distance from the previous location to current location.
         * @zh 获取触点距离上一次事件移动的 y 轴距离。
         */
        getDeltaY(): number;
        /**
         * @en Returns location X axis data.
         * @zh 获取当前触点 X 轴位置。
         */
        getLocationX(): number;
        /**
         * @en Returns location Y axis data.
         * @zh 获取当前触点 Y 轴位置。
         */
        getLocationY(): number;
    }
    /**
     * @en
     * The acceleration event.
     * @zh
     * 加速计事件。
     */
    export class EventAcceleration extends Event {
        /**
         * @en The acceleration object
         * @zh 加速度对象
         */
        acc: Acceleration;
        /**
         * @param acc - The acceleration
         * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
         */
        constructor(acc: Acceleration, bubbles?: boolean);
    }
    /**
     * @en
     * The keyboard event.
     * @zh
     * 键盘事件。
     */
    export class EventKeyboard extends Event {
        /**
         * @en The keyCode read-only property represents a system and implementation dependent numerical code
         * identifying the unmodified value of the pressed key.
         * This is usually the decimal ASCII (RFC 20) or Windows 1252 code corresponding to the key.
         * If the key can't be identified, this value is 0.
         * @zh keyCode 是只读属性它表示一个系统和依赖于实现的数字代码，可以识别按键的未修改值。
         * 这通常是十进制 ASCII (RFC20) 或者 Windows 1252 代码，所对应的密钥。
         * 如果无法识别该键，则该值为 0。
         */
        keyCode: number;
        /**
         * @en Raw DOM KeyboardEvent.
         * @zh 原始 DOM KeyboardEvent 事件对象
         */
        rawEvent?: KeyboardEvent;
        /**
         * @en Indicates whether the current key is being pressed
         * @zh 表示当前按键是否正在被按下
         */
        isPressed: boolean;
        /**
         * @param keyCode - The key code of the current key or the DOM KeyboardEvent
         * @param isPressed - Indicates whether the current key is being pressed
         * @param bubbles - Indicates whether the event bubbles up through the hierarchy or not.
         */
        constructor(keyCode: number | KeyboardEvent, isPressed: boolean, bubbles?: boolean);
    }
}
declare module "cocos/core/platform/event-manager/event-listener" {
    /**
     * @hidden
     */
    import { EventKeyboard, EventAcceleration, EventMouse } from "cocos/core/platform/event-manager/events";
    import { Node } from "cocos/core/scene-graph/index";
    export interface IEventListenerCreateInfo {
        event?: number;
        [x: string]: any;
    }
    export interface IListenerMask {
        index: number;
        node: Node;
    }
    /**
     * @en The base class of event listener.                                                                        <br/>
     * If you need custom listener which with different callback, you need to inherit this class.               <br/>
     * For instance, you could refer to EventListenerAcceleration, EventListenerKeyboard,                       <br/>
     * EventListenerTouchOneByOne, EventListenerCustom.<br/>
     * @zh 封装用户的事件处理逻辑
     * 注意：这是一个抽象类，开发者不应该直接实例化这个类，请参考 [[create]] 。
     */
    export class EventListener {
        /**
         * @en The type code of unknown event listener.<br/>
         * @zh 未知的事件监听器类型
         */
        static UNKNOWN: number;
        /**
         * @en The type code of one by one touch event listener.<br/>
         * @zh 触摸事件监听器类型，触点会一个一个得分开被派发
         */
        static TOUCH_ONE_BY_ONE: number;
        /**
         * @en The type code of all at once touch event listener.<br/>
         * @zh 触摸事件监听器类型，触点会被一次性全部派发
         */
        static TOUCH_ALL_AT_ONCE: number;
        /**
         * @en The type code of keyboard event listener.<br/>
         * @zh 键盘事件监听器类型
         */
        static KEYBOARD: number;
        /**
         * @en The type code of mouse event listener.<br/>
         * @zh 鼠标事件监听器类型
         */
        static MOUSE: number;
        /**
         * @en The type code of acceleration event listener.<br/>
         * @zh 加速器事件监听器类型
         */
        static ACCELERATION: number;
        /**
         * @en The type code of custom event listener.<br/>
         * @zh 自定义事件监听器类型
         */
        static CUSTOM: number;
        static ListenerID: {
            MOUSE: string;
            TOUCH_ONE_BY_ONE: string;
            TOUCH_ALL_AT_ONCE: string;
            KEYBOARD: string;
            ACCELERATION: string;
        };
        /**
         * @en Create a EventListener object with configuration including the event type, handlers and other parameters.<br/>
         * In handlers, this refer to the event listener object itself.<br/>
         * You can also pass custom parameters in the configuration object,<br/>
         * all custom parameters will be polyfilled into the event listener object and can be accessed in handlers.<br/>
         * @zh 通过指定不同的 Event 对象来设置想要创建的事件监听器。
         * @param argObj a json object
         */
        static create(argObj: IEventListenerCreateInfo): EventListener;
        owner: Object | null;
        mask: IListenerMask | null;
        _previousIn?: boolean;
        _target: any;
        protected _onEvent: ((...args: any[]) => any) | null;
        private _type;
        private _listenerID;
        private _registered;
        private _fixedPriority;
        private _node;
        private _paused;
        private _isEnabled;
        get onEvent(): ((...args: any[]) => any) | null;
        constructor(type: number, listenerID: string, callback: ((...args: any[]) => any) | null);
        /**
         * @en
         * <p><br/>
         *     Sets paused state for the listener<br/>
         *     The paused state is only used for scene graph priority listeners.<br/>
         *     `EventDispatcher.resumeAllEventListenersForTarget(node)` will set the paused state to `true`,<br/>
         *     while `EventDispatcher.pauseAllEventListenersForTarget(node)` will set it to `false`.<br/>
         *     @note 1) Fixed priority listeners will never get paused. If a fixed priority doesn't want to receive events,<br/>
         *              call `setEnabled(false)` instead.<br/>
         *            2) In `Node`'s onEnter and onExit, the `paused state` of the listeners<br/>
         *              which associated with that node will be automatically updated.<br/>
         * </p><br/>
         * @zh
         * *为侦听器设置暂停状态<br/>
         * 暂停状态仅用于场景图优先级侦听器。<br/>
         * `EventDispatcher :: resumeAllEventListenersForTarget（node）`将暂停状态设置为`true`，<br/>
         * 而`EventDispatcher :: pauseAllEventListenersForTarget（node）`将它设置为`false`。<br/>
         * 注意：<br/>
         * - 固定优先级侦听器永远不会被暂停。 如果固定优先级不想接收事件，改为调用`setEnabled（false）`。<br/>
         * - 在“Node”的onEnter和onExit中，监听器的“暂停状态”与该节点关联的*将自动更新。
         */
        _setPaused(paused: boolean): void;
        /**
         * @en Checks whether the listener is paused.<br/>
         * @zh 检查侦听器是否已暂停。
         */
        _isPaused(): boolean;
        /**
         * @en Marks the listener was registered by EventDispatcher.<br/>
         * @zh 标记监听器已由 EventDispatcher 注册。
         */
        _setRegistered(registered: boolean): void;
        /**
         * @en Checks whether the listener was registered by EventDispatcher<br/>
         * @zh 检查监听器是否已由 EventDispatcher 注册。
         * @private
         */
        _isRegistered(): boolean;
        /**
         * @en Gets the type of this listener<br/>
         * note： It's different from `EventType`, e.g.<br/>
         * TouchEvent has two kinds of event listeners - EventListenerOneByOne, EventListenerAllAtOnce<br/>
         * @zh 获取此侦听器的类型<br/>
         * 注意：它与`EventType`不同，例如<br/>
         * TouchEvent 有两种事件监听器 -  EventListenerOneByOne，EventListenerAllAtOnce
         */
        _getType(): number;
        /**
         * @en Gets the listener ID of this listener<br/>
         * When event is being dispatched, listener ID is used as key for searching listeners according to event type.<br/>
         * @zh 获取此侦听器的侦听器 ID。<br/>
         * 调度事件时，侦听器 ID 用作根据事件类型搜索侦听器的键。
         */
        _getListenerID(): string;
        /**
         * @en Sets the fixed priority for this listener<br/>
         * note: This method is only used for `fixed priority listeners`,<br/>
         *   it needs to access a non-zero value. 0 is reserved for scene graph priority listeners<br/>
         * @zh 设置此侦听器的固定优先级。<br/>
         * 注意：此方法仅用于“固定优先级侦听器”，<br/>
         * 它需要访问非零值。 0保留给场景图优先级侦听器。
         */
        _setFixedPriority(fixedPriority: number): void;
        /**
         * @en Gets the fixed priority of this listener<br/>
         * @zh 获取此侦听器的固定优先级。
         * @return 如果它是场景图优先级侦听器则返回 0 ，则对于固定优先级侦听器则不为零
         */
        _getFixedPriority(): number;
        /**
         * @en Sets scene graph priority for this listener<br/>
         * @zh 设置此侦听器的场景图优先级。
         * @param {Node} node
         */
        _setSceneGraphPriority(node: any): void;
        /**
         * @en Gets scene graph priority of this listener<br/>
         * @zh 获取此侦听器的场景图优先级。
         * @return 如果它是固定优先级侦听器，则为场景图优先级侦听器非 null 。
         */
        _getSceneGraphPriority(): any;
        /**
         * @en Checks whether the listener is available.<br/>
         * @zh 检测监听器是否有效
         */
        checkAvailable(): boolean;
        /**
         * @en Clones the listener, its subclasses have to override this method.<br/>
         * @zh 克隆监听器,它的子类必须重写此方法。
         */
        clone(): EventListener | null;
        /**
         * @en
         * Enables or disables the listener<br/>
         * note: Only listeners with `enabled` state will be able to receive events.<br/>
         * When an listener was initialized, it's enabled by default.<br/>
         * An event listener can receive events when it is enabled and is not paused.<br/>
         * paused state is always false when it is a fixed priority listener.<br/>
         * @zh
         * 启用或禁用监听器。<br/>
         * 注意：只有处于“启用”状态的侦听器才能接收事件。<br/>
         * 初始化侦听器时，默认情况下启用它。<br/>
         * 事件侦听器可以在启用且未暂停时接收事件。<br/>
         * 当固定优先级侦听器时，暂停状态始终为false。<br/>
         */
        setEnabled(enabled: boolean): void;
        /**
         * @en Checks whether the listener is enabled<br/>
         * @zh 检查监听器是否可用。
         */
        isEnabled(): boolean;
    }
    export class Mouse extends EventListener {
        onMouseDown: Function | null;
        onMouseUp: Function | null;
        onMouseMove: Function | null;
        onMouseScroll: Function | null;
        constructor();
        _callback(event: EventMouse): void;
        clone(): Mouse;
        checkAvailable(): boolean;
    }
    export class TouchOneByOne extends EventListener {
        swallowTouches: boolean;
        onTouchBegan: Function | null;
        onTouchMoved: Function | null;
        onTouchEnded: Function | null;
        onTouchCancelled: Function | null;
        _claimedTouches: any[];
        constructor();
        setSwallowTouches(needSwallow: any): void;
        isSwallowTouches(): boolean;
        clone(): TouchOneByOne;
        checkAvailable(): boolean;
    }
    export class TouchAllAtOnce extends EventListener {
        onTouchesBegan: Function | null;
        onTouchesMoved: Function | null;
        onTouchesEnded: Function | null;
        onTouchesCancelled: Function | null;
        constructor();
        clone(): TouchAllAtOnce;
        checkAvailable(): boolean;
    }
    export class Acceleration extends EventListener {
        _onAccelerationEvent: Function | null;
        constructor(callback: Function | null);
        _callback(event: EventAcceleration): void;
        checkAvailable(): boolean;
        clone(): Acceleration;
    }
    export class Keyboard extends EventListener {
        onKeyPressed: Function | null;
        onKeyReleased: Function | null;
        constructor();
        _callback(event: EventKeyboard): void;
        clone(): Keyboard;
        checkAvailable(): boolean;
    }
}
declare module "cocos/core/assets/scripts" {
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @zh
     * 脚本资源基类。
     */
    export class Script extends Asset {
    }
    /**
     * @zh
     * JavaScript 脚本资源。
     */
    export class JavaScript extends Script {
    }
    /**
     * @zh
     * Typescript 脚本资源。
     */
    export class TypeScript extends Script {
    }
}
declare module "cocos/core/gfx/define" {
    /**
     * @category gfx
     */
    export const GFX_MAX_VERTEX_ATTRIBUTES: number;
    export const GFX_MAX_TEXTURE_UNITS: number;
    export const GFX_MAX_ATTACHMENTS: number;
    export const GFX_MAX_BUFFER_BINDINGS: number;
    export enum GFXObjectType {
        UNKNOWN = 0,
        BUFFER = 1,
        TEXTURE = 2,
        RENDER_PASS = 3,
        FRAMEBUFFER = 4,
        SAMPLER = 5,
        SHADER = 6,
        DESCRIPTOR_SET_LAYOUT = 7,
        PIPELINE_LAYOUT = 8,
        PIPELINE_STATE = 9,
        DESCRIPTOR_SET = 10,
        INPUT_ASSEMBLER = 11,
        COMMAND_BUFFER = 12,
        FENCE = 13,
        QUEUE = 14,
        WINDOW = 15
    }
    /**
     * @en GFX base object.
     * @zh GFX 基类对象。
     */
    export class GFXObject {
        get gfxType(): GFXObjectType;
        protected _gfxType: GFXObjectType;
        constructor(gfxType: GFXObjectType);
    }
    export enum GFXAttributeName {
        ATTR_POSITION = "a_position",
        ATTR_NORMAL = "a_normal",
        ATTR_TANGENT = "a_tangent",
        ATTR_BITANGENT = "a_bitangent",
        ATTR_WEIGHTS = "a_weights",
        ATTR_JOINTS = "a_joints",
        ATTR_COLOR = "a_color",
        ATTR_COLOR1 = "a_color1",
        ATTR_COLOR2 = "a_color2",
        ATTR_TEX_COORD = "a_texCoord",
        ATTR_TEX_COORD1 = "a_texCoord1",
        ATTR_TEX_COORD2 = "a_texCoord2",
        ATTR_TEX_COORD3 = "a_texCoord3",
        ATTR_TEX_COORD4 = "a_texCoord4",
        ATTR_TEX_COORD5 = "a_texCoord5",
        ATTR_TEX_COORD6 = "a_texCoord6",
        ATTR_TEX_COORD7 = "a_texCoord7",
        ATTR_TEX_COORD8 = "a_texCoord8",
        ATTR_BATCH_ID = "a_batch_id",
        ATTR_BATCH_UV = "a_batch_uv"
    }
    export enum GFXType {
        UNKNOWN = 0,
        BOOL = 1,
        BOOL2 = 2,
        BOOL3 = 3,
        BOOL4 = 4,
        INT = 5,
        INT2 = 6,
        INT3 = 7,
        INT4 = 8,
        UINT = 9,
        UINT2 = 10,
        UINT3 = 11,
        UINT4 = 12,
        FLOAT = 13,
        FLOAT2 = 14,
        FLOAT3 = 15,
        FLOAT4 = 16,
        MAT2 = 17,
        MAT2X3 = 18,
        MAT2X4 = 19,
        MAT3X2 = 20,
        MAT3 = 21,
        MAT3X4 = 22,
        MAT4X2 = 23,
        MAT4X3 = 24,
        MAT4 = 25,
        SAMPLER1D = 26,
        SAMPLER1D_ARRAY = 27,
        SAMPLER2D = 28,
        SAMPLER2D_ARRAY = 29,
        SAMPLER3D = 30,
        SAMPLER_CUBE = 31,
        COUNT = 32
    }
    export enum GFXFormat {
        UNKNOWN = 0,
        A8 = 1,
        L8 = 2,
        LA8 = 3,
        R8 = 4,
        R8SN = 5,
        R8UI = 6,
        R8I = 7,
        R16F = 8,
        R16UI = 9,
        R16I = 10,
        R32F = 11,
        R32UI = 12,
        R32I = 13,
        RG8 = 14,
        RG8SN = 15,
        RG8UI = 16,
        RG8I = 17,
        RG16F = 18,
        RG16UI = 19,
        RG16I = 20,
        RG32F = 21,
        RG32UI = 22,
        RG32I = 23,
        RGB8 = 24,
        SRGB8 = 25,
        RGB8SN = 26,
        RGB8UI = 27,
        RGB8I = 28,
        RGB16F = 29,
        RGB16UI = 30,
        RGB16I = 31,
        RGB32F = 32,
        RGB32UI = 33,
        RGB32I = 34,
        RGBA8 = 35,
        BGRA8 = 36,
        SRGB8_A8 = 37,
        RGBA8SN = 38,
        RGBA8UI = 39,
        RGBA8I = 40,
        RGBA16F = 41,
        RGBA16UI = 42,
        RGBA16I = 43,
        RGBA32F = 44,
        RGBA32UI = 45,
        RGBA32I = 46,
        R5G6B5 = 47,
        R11G11B10F = 48,
        RGB5A1 = 49,
        RGBA4 = 50,
        RGB10A2 = 51,
        RGB10A2UI = 52,
        RGB9E5 = 53,
        D16 = 54,
        D16S8 = 55,
        D24 = 56,
        D24S8 = 57,
        D32F = 58,
        D32F_S8 = 59,
        BC1 = 60,
        BC1_ALPHA = 61,
        BC1_SRGB = 62,
        BC1_SRGB_ALPHA = 63,
        BC2 = 64,
        BC2_SRGB = 65,
        BC3 = 66,
        BC3_SRGB = 67,
        BC4 = 68,
        BC4_SNORM = 69,
        BC5 = 70,
        BC5_SNORM = 71,
        BC6H_UF16 = 72,
        BC6H_SF16 = 73,
        BC7 = 74,
        BC7_SRGB = 75,
        ETC_RGB8 = 76,
        ETC2_RGB8 = 77,
        ETC2_SRGB8 = 78,
        ETC2_RGB8_A1 = 79,
        ETC2_SRGB8_A1 = 80,
        ETC2_RGBA8 = 81,
        ETC2_SRGB8_A8 = 82,
        EAC_R11 = 83,
        EAC_R11SN = 84,
        EAC_RG11 = 85,
        EAC_RG11SN = 86,
        PVRTC_RGB2 = 87,
        PVRTC_RGBA2 = 88,
        PVRTC_RGB4 = 89,
        PVRTC_RGBA4 = 90,
        PVRTC2_2BPP = 91,
        PVRTC2_4BPP = 92,
        ASTC_RGBA_4x4 = 93,
        ASTC_RGBA_5x4 = 94,
        ASTC_RGBA_5x5 = 95,
        ASTC_RGBA_6x5 = 96,
        ASTC_RGBA_6x6 = 97,
        ASTC_RGBA_8x5 = 98,
        ASTC_RGBA_8x6 = 99,
        ASTC_RGBA_8x8 = 100,
        ASTC_RGBA_10x5 = 101,
        ASTC_RGBA_10x6 = 102,
        ASTC_RGBA_10x8 = 103,
        ASTC_RGBA_10x10 = 104,
        ASTC_RGBA_12x10 = 105,
        ASTC_RGBA_12x12 = 106,
        ASTC_SRGBA_4x4 = 107,
        ASTC_SRGBA_5x4 = 108,
        ASTC_SRGBA_5x5 = 109,
        ASTC_SRGBA_6x5 = 110,
        ASTC_SRGBA_6x6 = 111,
        ASTC_SRGBA_8x5 = 112,
        ASTC_SRGBA_8x6 = 113,
        ASTC_SRGBA_8x8 = 114,
        ASTC_SRGBA_10x5 = 115,
        ASTC_SRGBA_10x6 = 116,
        ASTC_SRGBA_10x8 = 117,
        ASTC_SRGBA_10x10 = 118,
        ASTC_SRGBA_12x10 = 119,
        ASTC_SRGBA_12x12 = 120
    }
    export enum GFXBufferUsageBit {
        NONE = 0,
        TRANSFER_SRC = 1,
        TRANSFER_DST = 2,
        INDEX = 4,
        VERTEX = 8,
        UNIFORM = 16,
        STORAGE = 32,
        INDIRECT = 64
    }
    export type GFXBufferUsage = GFXBufferUsageBit;
    export enum GFXMemoryUsageBit {
        NONE = 0,
        DEVICE = 1,
        HOST = 2
    }
    export type GFXMemoryUsage = GFXMemoryUsageBit;
    export enum GFXBufferFlagBit {
        NONE = 0,
        BAKUP_BUFFER = 4
    }
    export type GFXBufferFlags = GFXBufferFlagBit;
    export enum GFXBufferAccessBit {
        NONE = 0,
        READ = 1,
        WRITE = 2
    }
    export type GFXBufferAccess = GFXBufferAccessBit;
    export enum GFXPrimitiveMode {
        POINT_LIST = 0,
        LINE_LIST = 1,
        LINE_STRIP = 2,
        LINE_LOOP = 3,
        LINE_LIST_ADJACENCY = 4,
        LINE_STRIP_ADJACENCY = 5,
        ISO_LINE_LIST = 6,
        TRIANGLE_LIST = 7,
        TRIANGLE_STRIP = 8,
        TRIANGLE_FAN = 9,
        TRIANGLE_LIST_ADJACENCY = 10,
        TRIANGLE_STRIP_ADJACENCY = 11,
        TRIANGLE_PATCH_ADJACENCY = 12,
        QUAD_PATCH_LIST = 13
    }
    export enum GFXPolygonMode {
        FILL = 0,
        POINT = 1,
        LINE = 2
    }
    export enum GFXShadeModel {
        GOURAND = 0,
        FLAT = 1
    }
    export enum GFXCullMode {
        NONE = 0,
        FRONT = 1,
        BACK = 2
    }
    export enum GFXComparisonFunc {
        NEVER = 0,
        LESS = 1,
        EQUAL = 2,
        LESS_EQUAL = 3,
        GREATER = 4,
        NOT_EQUAL = 5,
        GREATER_EQUAL = 6,
        ALWAYS = 7
    }
    export enum GFXStencilOp {
        ZERO = 0,
        KEEP = 1,
        REPLACE = 2,
        INCR = 3,
        DECR = 4,
        INVERT = 5,
        INCR_WRAP = 6,
        DECR_WRAP = 7
    }
    export enum GFXBlendOp {
        ADD = 0,
        SUB = 1,
        REV_SUB = 2,
        MIN = 3,
        MAX = 4
    }
    export enum GFXBlendFactor {
        ZERO = 0,
        ONE = 1,
        SRC_ALPHA = 2,
        DST_ALPHA = 3,
        ONE_MINUS_SRC_ALPHA = 4,
        ONE_MINUS_DST_ALPHA = 5,
        SRC_COLOR = 6,
        DST_COLOR = 7,
        ONE_MINUS_SRC_COLOR = 8,
        ONE_MINUS_DST_COLOR = 9,
        SRC_ALPHA_SATURATE = 10,
        CONSTANT_COLOR = 11,
        ONE_MINUS_CONSTANT_COLOR = 12,
        CONSTANT_ALPHA = 13,
        ONE_MINUS_CONSTANT_ALPHA = 14
    }
    export enum GFXColorMask {
        NONE = 0,
        R = 1,
        G = 2,
        B = 4,
        A = 8,
        ALL = 15
    }
    export enum GFXFilter {
        NONE = 0,
        POINT = 1,
        LINEAR = 2,
        ANISOTROPIC = 3
    }
    export enum GFXAddress {
        WRAP = 0,
        MIRROR = 1,
        CLAMP = 2,
        BORDER = 3
    }
    export enum GFXTextureType {
        TEX1D = 0,
        TEX2D = 1,
        TEX3D = 2,
        CUBE = 3,
        TEX1D_ARRAY = 4,
        TEX2D_ARRAY = 5
    }
    export enum GFXTextureUsageBit {
        NONE = 0,
        TRANSFER_SRC = 1,
        TRANSFER_DST = 2,
        SAMPLED = 4,
        STORAGE = 8,
        COLOR_ATTACHMENT = 16,
        DEPTH_STENCIL_ATTACHMENT = 32,
        TRANSIENT_ATTACHMENT = 64,
        INPUT_ATTACHMENT = 128
    }
    export type GFXTextureUsage = GFXTextureUsageBit;
    export enum GFXSampleCount {
        X1 = 0,
        X2 = 1,
        X4 = 2,
        X8 = 3,
        X16 = 4,
        X32 = 5,
        X64 = 6
    }
    export enum GFXTextureFlagBit {
        NONE = 0,
        GEN_MIPMAP = 1,
        CUBEMAP = 2,
        BAKUP_BUFFER = 4
    }
    export type GFXTextureFlags = GFXTextureFlagBit;
    export enum GFXShaderStageFlagBit {
        NONE = 0,
        VERTEX = 1,
        CONTROL = 2,
        EVALUATION = 4,
        GEOMETRY = 8,
        FRAGMENT = 16,
        COMPUTE = 32,
        ALL = 63
    }
    export type GFXShaderStageFlags = GFXShaderStageFlagBit;
    export enum GFXDescriptorType {
        UNKNOWN = 0,
        UNIFORM_BUFFER = 1,
        DYNAMIC_UNIFORM_BUFFER = 2,
        STORAGE_BUFFER = 4,
        DYNAMIC_STORAGE_BUFFER = 8,
        SAMPLER = 16
    }
    export enum GFXCommandBufferType {
        PRIMARY = 0,
        SECONDARY = 1
    }
    export enum GFXLoadOp {
        LOAD = 0,
        CLEAR = 1,
        DISCARD = 2
    }
    export enum GFXStoreOp {
        STORE = 0,
        DISCARD = 1
    }
    export enum GFXTextureLayout {
        UNDEFINED = 0,
        GENERAL = 1,
        COLOR_ATTACHMENT_OPTIMAL = 2,
        DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
        DEPTH_STENCIL_READONLY_OPTIMAL = 4,
        SHADER_READONLY_OPTIMAL = 5,
        TRANSFER_SRC_OPTIMAL = 6,
        TRANSFER_DST_OPTIMAL = 7,
        PREINITIALIZED = 8,
        PRESENT_SRC = 9
    }
    export enum GFXPipelineBindPoint {
        GRAPHICS = 0,
        COMPUTE = 1,
        RAY_TRACING = 2
    }
    export enum GFXDynamicStateFlagBit {
        NONE = 0,
        VIEWPORT = 1,
        SCISSOR = 2,
        LINE_WIDTH = 4,
        DEPTH_BIAS = 8,
        BLEND_CONSTANTS = 16,
        DEPTH_BOUNDS = 32,
        STENCIL_WRITE_MASK = 64,
        STENCIL_COMPARE_MASK = 128
    }
    export type GFXDynamicStateFlags = GFXDynamicStateFlagBit;
    export enum GFXStencilFace {
        FRONT = 0,
        BACK = 1,
        ALL = 2
    }
    export enum GFXQueueType {
        GRAPHICS = 0,
        COMPUTE = 1,
        TRANSFER = 2
    }
    export class GFXRect {
        x: number;
        y: number;
        width: number;
        height: number;
        constructor(x?: number, y?: number, width?: number, height?: number);
    }
    export class GFXViewport {
        left: number;
        top: number;
        width: number;
        height: number;
        minDepth: number;
        maxDepth: number;
        constructor(left?: number, top?: number, width?: number, height?: number, minDepth?: number, maxDepth?: number);
    }
    export class GFXColor {
        r: number;
        g: number;
        b: number;
        a: number;
        constructor(r?: number, g?: number, b?: number, a?: number);
    }
    export enum GFXClearFlag {
        NONE = 0,
        COLOR = 1,
        DEPTH = 2,
        STENCIL = 4,
        DEPTH_STENCIL = 6,
        ALL = 7
    }
    export class GFXOffset {
        x: number;
        y: number;
        z: number;
        constructor(x?: number, y?: number, z?: number);
    }
    export class GFXExtent {
        width: number;
        height: number;
        depth: number;
        constructor(width?: number, height?: number, depth?: number);
    }
    export class GFXTextureSubres {
        mipLevel: number;
        baseArrayLayer: number;
        layerCount: number;
        constructor(mipLevel?: number, baseArrayLayer?: number, layerCount?: number);
    }
    export class GFXTextureCopy {
        srcSubres: GFXTextureSubres;
        srcOffset: GFXOffset;
        dstSubres: GFXTextureSubres;
        dstOffset: GFXOffset;
        extent: GFXExtent;
        constructor(srcSubres?: GFXTextureSubres, srcOffset?: GFXOffset, dstSubres?: GFXTextureSubres, dstOffset?: GFXOffset, extent?: GFXExtent);
    }
    export class GFXBufferTextureCopy {
        buffStride: number;
        buffTexHeight: number;
        texOffset: GFXOffset;
        texExtent: GFXExtent;
        texSubres: GFXTextureSubres;
        constructor(buffStride?: number, buffTexHeight?: number, texOffset?: GFXOffset, texExtent?: GFXExtent, texSubres?: GFXTextureSubres);
    }
    export enum GFXFormatType {
        NONE = 0,
        UNORM = 1,
        SNORM = 2,
        UINT = 3,
        INT = 4,
        UFLOAT = 5,
        FLOAT = 6
    }
    export class GFXFormatInfo {
        readonly name: string;
        readonly size: number;
        readonly count: number;
        readonly type: GFXFormatType;
        readonly hasAlpha: boolean;
        readonly hasDepth: boolean;
        readonly hasStencil: boolean;
        readonly isCompressed: boolean;
        constructor(name: string, size: number, count: number, type: GFXFormatType, hasAlpha: boolean, hasDepth: boolean, hasStencil: boolean, isCompressed: boolean);
    }
    export class GFXMemoryStatus {
        bufferSize: number;
        textureSize: number;
    }
    export const GFXFormatInfos: readonly GFXFormatInfo[];
    /**
     * @en Get memory size of the specified fomat.
     * @zh 获取指定格式对应的内存大小。
     * @param format The target format.
     * @param width The target width.
     * @param height The target height.
     * @param depth The target depth.
     */
    export function GFXFormatSize(format: GFXFormat, width: number, height: number, depth: number): number;
    /**
     * @en Get memory size of the specified surface.
     * @zh GFX 格式表面内存大小。
     * @param format The target format.
     * @param width The target width.
     * @param height The target height.
     * @param depth The target depth.
     * @param mips The target mip levels.
     */
    export function GFXFormatSurfaceSize(format: GFXFormat, width: number, height: number, depth: number, mips: number): number;
    /**
     * @en Get the memory size of the specified type.
     * @zh 得到 GFX 数据类型的大小。
     * @param type The target type.
     */
    export function GFXGetTypeSize(type: GFXType): number;
    export function getTypedArrayConstructor(info: GFXFormatInfo): TypedArrayConstructor;
}
declare module "cocos/core/3d/misc/buffer" {
    import { GFXFormat } from "cocos/core/gfx/define";
    export function writeBuffer(target: DataView, data: number[], format?: GFXFormat, offset?: number, stride?: number): void;
    export function readBuffer(target: DataView, format?: GFXFormat, offset?: number, length?: number, stride?: number, out?: number[]): number[];
    export function mapBuffer(target: DataView, callback: (cur: number, idx: number, view: DataView) => number, format?: GFXFormat, offset?: number, length?: number, stride?: number, out?: DataView): DataView;
}
declare module "cocos/core/3d/misc/buffer-blob" {
    export class BufferBlob {
        private _arrayBufferOrPaddings;
        private _length;
        setNextAlignment(align: number): void;
        addBuffer(arrayBuffer: ArrayBuffer): number;
        getLength(): number;
        getCombined(): ArrayBuffer | SharedArrayBuffer;
    }
}
declare module "cocos/core/geometry/enums" {
    const _default: {
        SHAPE_RAY: number;
        SHAPE_LINE: number;
        SHAPE_SPHERE: number;
        SHAPE_AABB: number;
        SHAPE_OBB: number;
        SHAPE_PLANE: number;
        SHAPE_TRIANGLE: number;
        SHAPE_FRUSTUM: number;
        SHAPE_FRUSTUM_ACCURATE: number;
        SHAPE_CAPSULE: number;
    };
    /**
     * 几何工具模块
     * @category geometry
     */
    /**
     * @en
     * The enum type of basic geometry.
     * @zh
     * 形状的类型值。
     */
    export default _default;
}
declare module "cocos/core/geometry/aabb" {
    /**
     * @category geometry
     */
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import { IVec3Like } from "cocos/core/math/type-define";
    /**
     * @en
     * Basic Geometry: Axis-aligned bounding box, using center and half extents structure.
     * @zh
     * 基础几何  轴对齐包围盒，使用中心点和半长宽高的结构。
     */
    export default class aabb {
        /**
         * @en
         * create a new aabb
         * @zh
         * 创建一个新的 aabb 实例。
         * @param px - aabb 的原点的 X 坐标。
         * @param py - aabb 的原点的 Y 坐标。
         * @param pz - aabb 的原点的 Z 坐标。
         * @param hw - aabb 宽度的一半。
         * @param hh - aabb 高度的一半。
         * @param hl - aabb 长度的一半。
         * @returns 返回新创建的 aabb 实例。
         */
        static create(px?: number, py?: number, pz?: number, hw?: number, hh?: number, hl?: number): aabb;
        /**
         * @en
         * clone a new aabb
         * @zh
         * 克隆一个 aabb。
         * @param a - 克隆的目标。
         * @returns 克隆出的 aabb。
         */
        static clone(a: aabb): aabb;
        /**
         * @en
         * copy the values from one aabb to another
         * @zh
         * 将从一个 aabb 的值复制到另一个 aabb。
         * @param {aabb} out 接受操作的 aabb。
         * @param {aabb} a 被复制的 aabb。
         * @return {aabb} out 接受操作的 aabb。
         */
        static copy(out: aabb, a: aabb): aabb;
        /**
         * @en
         * create a new aabb from two corner points
         * @zh
         * 从两个点创建一个新的 aabb。
         * @param out - 接受操作的 aabb。
         * @param minPos - aabb 的最小点。
         * @param maxPos - aabb 的最大点。
         * @returns {aabb} out 接受操作的 aabb。
         */
        static fromPoints(out: aabb, minPos: IVec3Like, maxPos: IVec3Like): aabb;
        /**
         * @en
         * Set the components of a aabb to the given values
         * @zh
         * 将 aabb 的属性设置为给定的值。
         * @param {aabb} out 接受操作的 aabb。
         * @param px - aabb 的原点的 X 坐标。
         * @param py - aabb 的原点的 Y 坐标。
         * @param pz - aabb 的原点的 Z 坐标。
         * @param hw - aabb 宽度的一半。
         * @param hh - aabb 高度的一半。
         * @param hl - aabb 长度度的一半。
         * @return {aabb} out 接受操作的 aabb。
         */
        static set(out: aabb, px: number, py: number, pz: number, hw: number, hh: number, hl: number): aabb;
        /**
         * @en
         * Merge tow aabb.
         * @zh
         * 合并两个 aabb 到 out。
         * @param out 接受操作的 aabb。
         * @param a 输入的 aabb。
         * @param b 输入的 aabb。
         * @returns {aabb} out 接受操作的 aabb。
         */
        static merge(out: aabb, a: aabb, b: aabb): aabb;
        /**
         * @en
         * Transform this aabb.
         * @zh
         * 变换一个 aabb 到 out 中。
         * @param out 接受操作的 aabb。
         * @param a 输入的源 aabb。
         * @param matrix 矩阵。
         * @returns {aabb} out 接受操作的 aabb。
         */
        static transform(out: aabb, a: aabb, matrix: Mat4): aabb;
        /**
         * @zh
         * 本地坐标的中心点。
         */
        center: Vec3;
        /**
         * @zh
         * 长宽高的一半。
         */
        halfExtents: Vec3;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        constructor(px?: number, py?: number, pz?: number, hw?: number, hh?: number, hl?: number);
        /**
         * @en
         * Get the bounding points of this shape
         * @zh
         * 获取 aabb 的最小点和最大点。
         * @param {Vec3} minPos 最小点。
         * @param {Vec3} maxPos 最大点。
         */
        getBoundary(minPos: IVec3Like, maxPos: IVec3Like): void;
        /**
         * @en
         * Transform this shape
         * @zh
         * 将 out 根据这个 aabb 的数据进行变换。
         * @param m 变换的矩阵。
         * @param pos 变换的位置部分。
         * @param rot 变换的旋转部分。
         * @param scale 变换的缩放部分。
         * @param out 变换的目标。
         */
        transform(m: Mat4, pos: Vec3 | null, rot: Quat | null, scale: Vec3 | null, out: aabb): void;
        /**
         * @zh
         * 获得克隆。
         * @returns {aabb}
         */
        clone(): aabb;
        /**
         * @zh
         * 拷贝对象。
         * @param a 拷贝的目标。
         * @returns {aabb}
         */
        copy(a: aabb): aabb;
    }
}
declare module "cocos/core/geometry/obb" {
    /**
     * @category geometry
     */
    import { Mat3, Mat4, Quat, Vec3 } from "cocos/core/math/index";
    /**
     * @en
     * Basic Geometry: directional bounding box.
     * @zh
     * 基础几何  方向包围盒。
     */
    export default class obb {
        /**
         * @en
         * create a new obb
         * @zh
         * 创建一个新的 obb 实例。
         * @param cx 形状的相对于原点的 X 坐标。
         * @param cy 形状的相对于原点的 Y 坐标。
         * @param cz 形状的相对于原点的 Z 坐标。
         * @param hw - obb 宽度的一半。
         * @param hh - obb 高度的一半。
         * @param hl - obb 长度的一半。
         * @param ox_1 方向矩阵参数。
         * @param ox_2 方向矩阵参数。
         * @param ox_3 方向矩阵参数。
         * @param oy_1 方向矩阵参数。
         * @param oy_2 方向矩阵参数。
         * @param oy_3 方向矩阵参数。
         * @param oz_1 方向矩阵参数。
         * @param oz_2 方向矩阵参数。
         * @param oz_3 方向矩阵参数。
         * @return 返回一个 obb。
         */
        static create(cx: number, cy: number, cz: number, hw: number, hh: number, hl: number, ox_1: number, ox_2: number, ox_3: number, oy_1: number, oy_2: number, oy_3: number, oz_1: number, oz_2: number, oz_3: number): obb;
        /**
         * @en
         * clone a new obb
         * @zh
         * 克隆一个 obb。
         * @param a 克隆的目标。
         * @returns 克隆出的新对象。
         */
        static clone(a: obb): obb;
        /**
         * @en
         * copy the values from one obb to another
         * @zh
         * 将从一个 obb 的值复制到另一个 obb。
         * @param {obb} out 接受操作的 obb。
         * @param {obb} a 被复制的 obb。
         * @return {obb} out 接受操作的 obb。
         */
        static copy(out: obb, a: obb): obb;
        /**
         * @en
         * create a new obb from two corner points
         * @zh
         * 用两个点创建一个新的 obb。
         * @param out - 接受操作的 obb。
         * @param minPos - obb 的最小点。
         * @param maxPos - obb 的最大点。
         * @returns {obb} out 接受操作的 obb。
         */
        static fromPoints(out: obb, minPos: Vec3, maxPos: Vec3): obb;
        /**
         * @en
         * Set the components of a obb to the given values
         * @zh
         * 将给定 obb 的属性设置为给定的值。
         * @param cx - obb 的原点的 X 坐标。
         * @param cy - obb 的原点的 Y 坐标。
         * @param cz - obb 的原点的 Z 坐标。
         * @param hw - obb 宽度的一半。
         * @param hh - obb 高度的一半。
         * @param hl - obb 长度的一半。
         * @param ox_1 方向矩阵参数。
         * @param ox_2 方向矩阵参数。
         * @param ox_3 方向矩阵参数。
         * @param oy_1 方向矩阵参数。
         * @param oy_2 方向矩阵参数。
         * @param oy_3 方向矩阵参数。
         * @param oz_1 方向矩阵参数。
         * @param oz_2 方向矩阵参数。
         * @param oz_3 方向矩阵参数。
         * @return {obb} out
         */
        static set(out: obb, cx: number, cy: number, cz: number, hw: number, hh: number, hl: number, ox_1: number, ox_2: number, ox_3: number, oy_1: number, oy_2: number, oy_3: number, oz_1: number, oz_2: number, oz_3: number): obb;
        /**
         * @zh
         * 本地坐标的中心点。
         */
        center: Vec3;
        /**
         * @zh
         * 长宽高的一半。
         */
        halfExtents: Vec3;
        /**
         * @zh
         * 方向矩阵。
         */
        orientation: Mat3;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        constructor(cx?: number, cy?: number, cz?: number, hw?: number, hh?: number, hl?: number, ox_1?: number, ox_2?: number, ox_3?: number, oy_1?: number, oy_2?: number, oy_3?: number, oz_1?: number, oz_2?: number, oz_3?: number);
        /**
         * @en
         * Get the bounding points of this shape
         * @zh
         * 获取 obb 的最小点和最大点。
         * @param {Vec3} minPos 最小点。
         * @param {Vec3} maxPos 最大点。
         */
        getBoundary(minPos: Vec3, maxPos: Vec3): void;
        /**
         * Transform this shape
         * @zh
         * 将 out 根据这个 obb 的数据进行变换。
         * @param m 变换的矩阵。
         * @param pos 变换的位置部分。
         * @param rot 变换的旋转部分。
         * @param scale 变换的缩放部分。
         * @param out 变换的目标。
         */
        transform(m: Mat4, pos: Vec3, rot: Quat, scale: Vec3, out: obb): void;
        /**
         * @zh
         * 将 out 根据这个 obb 的数据进行变换。
         * @param m 变换的矩阵。
         * @param rot 变换的旋转部分。
         * @param out 变换的目标。
         */
        translateAndRotate(m: Mat4, rot: Quat, out: obb): void;
        /**
         * @zh
         *  将 out 根据这个 obb 的数据进行缩放。
         * @param scale 缩放值。
         * @param out 缩放的目标。
         */
        setScale(scale: Vec3, out: obb): void;
    }
}
declare module "cocos/core/geometry/plane" {
    /**
     * @category geometry
     */
    import { Mat4, Vec3 } from "cocos/core/math/index";
    /**
     * @en
     * Basic Geometry: plane.
     * @zh
     * 基础几何 plane。
     */
    export default class plane {
        /**
         * @en
         * create a new plane
         * @zh
         * 创建一个新的 plane。
         * @param nx 法向分量的 x 部分。
         * @param ny 法向分量的 y 部分。
         * @param nz 法向分量的 z 部分。
         * @param d 与原点的距离。
         * @return
         */
        static create(nx: number, ny: number, nz: number, d: number): plane;
        /**
         * @en
         * clone a new plane
         * @zh
         * 克隆一个新的 plane。
         * @param p 克隆的来源。
         * @return 克隆出的对象。
         */
        static clone(p: plane): plane;
        /**
         * @en
         * copy the values from one plane to another
         * @zh
         * 复制一个平面的值到另一个。
         * @param out 接受操作的对象。
         * @param p 复制的来源。
         * @return 接受操作的对象。
         */
        static copy(out: plane, p: plane): plane;
        /**
         * @en
         * create a plane from three points
         * @zh
         * 用三个点创建一个平面。
         * @param out 接受操作的对象。
         * @param a 点 a。
         * @param b 点 b。
         * @param c 点 c。
         * @return out 接受操作的对象。
         */
        static fromPoints(out: plane, a: Vec3, b: Vec3, c: Vec3): plane;
        /**
         * @en
         * Set the components of a plane to the given values
         * @zh
         * 将给定平面的属性设置为给定值。
         * @param out 接受操作的对象。
         * @param nx 法向分量的 x 部分。
         * @param ny 法向分量的 y 部分。
         * @param nz 法向分量的 z 部分。
         * @param d 与原点的距离。
         * @return out 接受操作的对象。
         */
        static set(out: plane, nx: number, ny: number, nz: number, d: number): plane;
        /**
         * @en
         * create plane from normal and point
         * @zh
         * 用一条法线和一个点创建平面。
         * @param out 接受操作的对象。
         * @param normal 平面的法线。
         * @param point 平面上的一点。
         * @return out 接受操作的对象。
         */
        static fromNormalAndPoint(out: plane, normal: Vec3, point: Vec3): plane;
        /**
         * @en
         * normalize a plane
         * @zh
         * 归一化一个平面。
         * @param out 接受操作的对象。
         * @param a 操作的源数据。
         * @return out 接受操作的对象。
         */
        static normalize(out: plane, a: plane): plane;
        /**
         * @en
         * The normal of the plane.
         * @zh
         * 法线向量。
         */
        n: Vec3;
        /**
         * @en
         * The distance from the origin to the plane.
         * @zh
         * 原点到平面的距离。
         */
        d: number;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        /**
         * @en
         * Construct a plane.
         * @zh
         * 构造一个平面。
         * @param nx 法向分量的 x 部分。
         * @param ny 法向分量的 y 部分。
         * @param nz 法向分量的 z 部分。
         * @param d 与原点的距离。
         */
        constructor(nx?: number, ny?: number, nz?: number, d?: number);
        /**
         * @en
         * transform this plane.
         * @zh
         * 变换一个平面。
         * @param mat
         */
        transform(mat: Mat4): void;
    }
}
declare module "cocos/core/geometry/distance" {
    /**
     * @category geometry
     */
    import { Vec3 } from "cocos/core/math/index";
    import aabb from "cocos/core/geometry/aabb";
    import obb from "cocos/core/geometry/obb";
    import plane from "cocos/core/geometry/plane";
    /**
     * @en
     * the distance between a point and a plane
     * @zh
     * 计算点和平面之间的距离。
     * @param {Vec3} point 点。
     * @param {plane} plane 平面。
     * @return 距离。
     */
    export function point_plane(point: Vec3, plane_: plane): number;
    /**
     * @en
     * the closest point on plane to a given point
     * @zh
     * 计算平面上最接近给定点的点。
     * @param out 最近点。
     * @param point 给定点。
     * @param plane 平面。
     * @return 最近点。
     */
    export function pt_point_plane(out: Vec3, point: Vec3, plane_: plane): Vec3;
    /**
     * @en
     * the closest point on aabb to a given point
     * @zh
     * 计算 aabb 上最接近给定点的点。
     * @param {Vec3} out 最近点。
     * @param {Vec3} point 给定点。
     * @param {aabb} aabb 轴对齐包围盒。
     * @return {Vec3} 最近点。
     */
    export function pt_point_aabb(out: Vec3, point: Vec3, aabb_: aabb): Vec3;
    /**
     * @en
     * the closest point on obb to a given point
     * @zh
     * 计算 obb 上最接近给定点的点。
     * @param {Vec3} out 最近点。
     * @param {Vec3} point 给定点。
     * @param {obb} obb 方向包围盒。
     * @return {Vec3} 最近点。
     */
    export function pt_point_obb(out: Vec3, point: Vec3, obb_: obb): Vec3;
    /**
     * @en
     * Calculate the nearest point on the line to the given point.
     * @zh
     * 计算给定点距离直线上最近的一点。
     * @param out 最近点
     * @param point 给定点
     * @param linePointA 线上的某点 A
     * @param linePointB 线上的某点 B
     */
    export function pt_point_line(out: Vec3, point: Vec3, linePointA: Vec3, linePointB: Vec3): void;
}
declare module "cocos/core/geometry/capsule" {
    /**
     * @category geometry
     */
    import { Vec3, Quat, Mat4 } from "cocos/core/math/index";
    import { IVec3Like, IQuatLike } from "cocos/core/math/type-define";
    /**
     * @en
     * Basic Geometry: capsule.
     * @zh
     * 基础几何，胶囊体。
     */
    export class capsule {
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        /**
         * @en
         * Capsule sphere radius.
         * @zh
         * 胶囊体球部半径。
         */
        radius: number;
        /**
         * @en
         * The distance between the center point of the capsule and the center of the sphere.
         * @zh
         * 胶囊体中心点和球部圆心的距离。
         */
        halfHeight: number;
        /**
         * @en
         * Local orientation of capsule [0,1,2] => [x,y,z].
         * @zh
         * 胶囊体的本地朝向，映射关系 [0,1,2] => [x,y,z]。
         */
        axis: number;
        /**
         * @en
         * The origin of the capsule.
         * @zh
         * 胶囊体的原点。
         */
        readonly center: Vec3;
        /**
         * @en
         * The rotation of the capsule.
         * @zh
         * 胶囊体的旋转。
         */
        readonly rotation: Quat;
        /** cache, local center of ellipse */
        readonly ellipseCenter0: Vec3;
        readonly ellipseCenter1: Vec3;
        constructor(radius?: number, halfHeight?: number, axis?: number);
        /**
         * @en
         * Transform this capsule.
         * @zh
         * 变换此胶囊体。
         */
        transform(m: Mat4, pos: IVec3Like, rot: IQuatLike, scale: IVec3Like, out: capsule): void;
        updateCache(): void;
        updateLocalCenter(): void;
    }
}
declare module "cocos/core/geometry/frustum" {
    /**
     * @category geometry
     */
    import { Mat4, Vec3 } from "cocos/core/math/index";
    import plane from "cocos/core/geometry/plane";
    /**
     * @en
     * Basic Geometry: frustum.
     * @zh
     * 基础几何 截头锥体。
     */
    export class frustum {
        /**
         * @en
         * Set whether to use accurate intersection testing function on this frustum.
         * @zh
         * 设置是否在此截锥体上使用精确的相交测试函数。
         */
        set accurate(b: boolean);
        /**
         * @en
         * Create a ortho frustum.
         * @zh
         * 创建一个正交视锥体。
         * @param out 正交视锥体。
         * @param width 正交视锥体的宽度。
         * @param height 正交视锥体的高度。
         * @param near 正交视锥体的近平面值。
         * @param far 正交视锥体的远平面值。
         * @param transform 正交视锥体的变换矩阵。
         * @return {frustum} frustum.
         */
        static createOrtho: (out: frustum, width: number, height: number, near: number, far: number, transform: Mat4) => void;
        /**
         * @en
         * create a new frustum.
         * @zh
         * 创建一个新的截锥体。
         * @return {frustum} frustum.
         */
        static create(): frustum;
        /**
         * @en
         * Clone a frustum.
         * @zh
         * 克隆一个截锥体。
         */
        static clone(f: frustum): frustum;
        /**
         * @en
         * Copy the values from one frustum to another.
         * @zh
         * 从一个截锥体拷贝到另一个截锥体。
         */
        static copy(out: frustum, f: frustum): frustum;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected _type: number;
        planes: plane[];
        vertices: Vec3[];
        constructor();
        /**
         * @en
         * Update the frustum information according to the given transform matrix.
         * Note that the resulting planes are not normalized under normal mode.
         * @zh
         * 根据给定的变换矩阵更新截锥体信息，注意得到的平面不是在标准模式下归一化的。
         * @param {Mat4} m the view-projection matrix
         * @param {Mat4} inv the inverse view-projection matrix
         */
        update(m: Mat4, inv: Mat4): void;
        /**
         * @en
         * Transform this frustum.
         * @zh
         * 变换此截锥体。
         * @param mat 变换矩阵。
         */
        transform(mat: Mat4): void;
    }
}
declare module "cocos/core/geometry/line" {
    /**
     * @category geometry
     */
    import { Vec3 } from "cocos/core/math/index";
    /**
     * @en
     * Basic Geometry: line.
     * @zh
     * 基础几何 line。
     */
    export default class line {
        /**
         * @en
         * create a new line
         * @zh
         * 创建一个新的 line。
         * @param sx 起点的 x 部分。
         * @param sy 起点的 y 部分。
         * @param sz 起点的 z 部分。
         * @param ex 终点的 x 部分。
         * @param ey 终点的 y 部分。
         * @param ez 终点的 z 部分。
         * @return
         */
        static create(sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): line;
        /**
         * @en
         * Creates a new line initialized with values from an existing line
         * @zh
         * 克隆一个新的 line。
         * @param a 克隆的来源。
         * @return 克隆出的对象。
         */
        static clone(a: line): line;
        /**
         * @en
         * Copy the values from one line to another
         * @zh
         * 复制一个线的值到另一个。
         * @param out 接受操作的对象。
         * @param a 复制的来源。
         * @return 接受操作的对象。
         */
        static copy(out: line, a: line): line;
        /**
         * @en
         * create a line from two points
         * @zh
         * 用两个点创建一个线。
         * @param out 接受操作的对象。
         * @param start 起点。
         * @param end 终点。
         * @return out 接受操作的对象。
         */
        static fromPoints(out: line, start: Vec3, end: Vec3): line;
        /**
         * @en
         * Set the components of a Vec3 to the given values
         * @zh
         * 将给定线的属性设置为给定值。
         * @param out 接受操作的对象。
         * @param sx 起点的 x 部分。
         * @param sy 起点的 y 部分。
         * @param sz 起点的 z 部分。
         * @param ex 终点的 x 部分。
         * @param ey 终点的 y 部分。
         * @param ez 终点的 z 部分。
         * @return out 接受操作的对象。
         */
        static set(out: line, sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): line;
        /**
         * @zh
         * 计算线的长度。
         * @param a 要计算的线。
         * @return 长度。
         */
        static len(a: line): number;
        /**
         * @zh
         * 起点。
         */
        s: Vec3;
        /**
         * @zh
         * 终点。
         */
        e: Vec3;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        private readonly _type;
        /**
         * 构造一条线。
         * @param sx 起点的 x 部分。
         * @param sy 起点的 y 部分。
         * @param sz 起点的 z 部分。
         * @param ex 终点的 x 部分。
         * @param ey 终点的 y 部分。
         * @param ez 终点的 z 部分。
         */
        constructor(sx?: number, sy?: number, sz?: number, ex?: number, ey?: number, ez?: number);
        /**
         * @zh
         * 计算线的长度。
         * @param a 要计算的线。
         * @return 长度。
         */
        length(): number;
    }
}
declare module "cocos/core/geometry/ray" {
    /**
     * @category geometry
     */
    import { Vec3 } from "cocos/core/math/index";
    import { IVec3Like } from "cocos/core/math/type-define";
    /**
     * @en
     * Basic Geometry: ray.
     * @zh
     * 基础几何 射线。
     */
    export default class ray {
        /**
         * @en
         * create a new ray
         * @zh
         * 创建一条射线。
         * @param {number} ox 起点的 x 部分。
         * @param {number} oy 起点的 y 部分。
         * @param {number} oz 起点的 z 部分。
         * @param {number} dx 方向的 x 部分。
         * @param {number} dy 方向的 y 部分。
         * @param {number} dz 方向的 z 部分。
         * @return {ray} 射线。
         */
        static create(ox?: number, oy?: number, oz?: number, dx?: number, dy?: number, dz?: number): ray;
        /**
         * @en
         * Creates a new ray initialized with values from an existing ray
         * @zh
         * 从一条射线克隆出一条新的射线。
         * @param {ray} a 克隆的目标。
         * @return {ray} 克隆出的新对象。
         */
        static clone(a: ray): ray;
        /**
         * @en
         * Copy the values from one ray to another
         * @zh
         * 将从一个 ray 的值复制到另一个 ray。
         * @param {ray} out 接受操作的 ray。
         * @param {ray} a 被复制的 ray。
         * @return {ray} out 接受操作的 ray。
         */
        static copy(out: ray, a: ray): ray;
        /**
         * @en
         * create a ray from two points
         * @zh
         * 用两个点创建一条射线。
         * @param {ray} out 接受操作的射线。
         * @param {Vec3} origin 射线的起点。
         * @param {Vec3} target 射线上的一点。
         * @return {ray} out 接受操作的射线。
         */
        static fromPoints(out: ray, origin: Vec3, target: Vec3): ray;
        /**
         * @en
         * Set the components of a ray to the given values
         * @zh
         * 将给定射线的属性设置为给定的值。
         * @param {ray} out 接受操作的射线。
         * @param {number} ox 起点的 x 部分。
         * @param {number} oy 起点的 y 部分。
         * @param {number} oz 起点的 z 部分。
         * @param {number} dx 方向的 x 部分。
         * @param {number} dy 方向的 y 部分。
         * @param {number} dz 方向的 z 部分。
         * @return {ray} out 接受操作的射线。
         */
        static set(out: ray, ox: number, oy: number, oz: number, dx: number, dy: number, dz: number): ray;
        /**
         * @en
         * The origin of the ray.
         * @zh
         * 起点。
         */
        o: Vec3;
        /**
         * @en
         * The direction of the ray.
         * @zh
         * 方向。
         */
        d: Vec3;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        /**
         * @en
         * Construct a ray;
         * @zh
         * 构造一条射线。
         * @param {number} ox 起点的 x 部分。
         * @param {number} oy 起点的 y 部分。
         * @param {number} oz 起点的 z 部分。
         * @param {number} dx 方向的 x 部分。
         * @param {number} dy 方向的 y 部分。
         * @param {number} dz 方向的 z 部分。
         */
        constructor(ox?: number, oy?: number, oz?: number, dx?: number, dy?: number, dz?: number);
        /**
         * @en
         * Compute a point with the distance between the origin.
         * @zh
         * 根据给定距离计算出射线上的一点。
         * @param out 射线上的另一点。
         * @param distance 给定距离。
         */
        computeHit(out: IVec3Like, distance: number): void;
    }
}
declare module "cocos/core/geometry/sphere" {
    /**
     * @category geometry
     */
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import aabb from "cocos/core/geometry/aabb";
    /**
     * @en
     * Basic Geometry: sphere.
     * @zh
     * 基础几何 轴对齐球。
     */
    export default class sphere {
        /**
         * @en
         * create a new sphere
         * @zh
         * 创建一个新的 sphere 实例。
         * @param cx 形状的相对于原点的 X 坐标。
         * @param cy 形状的相对于原点的 Y 坐标。
         * @param cz 形状的相对于原点的 Z 坐标。
         * @param r 球体的半径
         * @return {sphere} 返回一个 sphere。
         */
        static create(cx: number, cy: number, cz: number, r: number): sphere;
        /**
         * @en
         * clone a new sphere
         * @zh
         * 克隆一个新的 sphere 实例。
         * @param {sphere} p 克隆的目标。
         * @return {sphere} 克隆出的示例。
         */
        static clone(p: sphere): sphere;
        /**
         * @en
         * copy the values from one sphere to another
         * @zh
         * 将从一个 sphere 的值复制到另一个 sphere。
         * @param {sphere} out 接受操作的 sphere。
         * @param {sphere} a 被复制的 sphere。
         * @return {sphere} out 接受操作的 sphere。
         */
        static copy(out: sphere, p: sphere): sphere;
        /**
         * @en
         * create a new bounding sphere from two corner points
         * @zh
         * 从两个点创建一个新的 sphere。
         * @param out - 接受操作的 sphere。
         * @param minPos - sphere 的最小点。
         * @param maxPos - sphere 的最大点。
         * @returns {sphere} out 接受操作的 sphere。
         */
        static fromPoints(out: sphere, minPos: Vec3, maxPos: Vec3): sphere;
        /**
         * @en
         * Set the components of a sphere to the given values
         * @zh
         * 将球体的属性设置为给定的值。
         * @param {sphere} out 接受操作的 sphere。
         * @param cx 形状的相对于原点的 X 坐标。
         * @param cy 形状的相对于原点的 Y 坐标。
         * @param cz 形状的相对于原点的 Z 坐标。
         * @param {number} r 半径。
         * @return {sphere} out 接受操作的 sphere。
         * @function
         */
        static set(out: sphere, cx: number, cy: number, cz: number, r: number): sphere;
        /**
         * @zh
         * 球跟点合并
         */
        static mergePoint(out: sphere, s: sphere, point: Vec3): sphere;
        /**
         * @zh
         * 球跟立方体合并
         */
        static mergeAABB(out: sphere, s: sphere, a: aabb): sphere;
        /**
         * @en
         * The center of this sphere.
         * @zh
         * 本地坐标的中心点。
         */
        center: Vec3;
        /**
         * @en
         * The radius of this sphere.
         * @zh
         * 半径。
         */
        radius: number;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        /**
         * @en
         * Construct a sphere.
         * @zh
         * 构造一个球。
         * @param cx 该球的世界坐标的 X 坐标。
         * @param cy 该球的世界坐标的 Y 坐标。
         * @param cz 该球的世界坐标的 Z 坐标。
         * @param {number} r 半径。
         */
        constructor(cx?: number, cy?: number, cz?: number, r?: number);
        /**
         * @en
         * Get a clone.
         * @zh
         * 获得克隆。
         */
        clone(): sphere;
        /**
         * @en
         * Copy a sphere.
         * @zh
         * 拷贝对象。
         * @param a 拷贝的目标。
         */
        copy(a: sphere): sphere;
        /**
         * @en
         * Get the bounding points of this shape
         * @zh
         * 获取此形状的边界点。
         * @param {Vec3} minPos 最小点。
         * @param {Vec3} maxPos 最大点。
         */
        getBoundary(minPos: Vec3, maxPos: Vec3): void;
        /**
         * @en
         * Transform this shape
         * @zh
         * 将 out 根据这个 sphere 的数据进行变换。
         * @param m 变换的矩阵。
         * @param pos 变换的位置部分。
         * @param rot 变换的旋转部分。
         * @param scale 变换的缩放部分。
         * @param out 变换的目标。
         */
        transform(m: Mat4, pos: Vec3, rot: Quat, scale: Vec3, out: sphere): void;
        /**
         * @en
         * Translate and rotate this sphere.
         * @zh
         * 将 out 根据这个 sphere 的数据进行变换。
         * @param m 变换的矩阵。
         * @param rot 变换的旋转部分。
         * @param out 变换的目标。
         */
        translateAndRotate(m: Mat4, rot: Quat, out: sphere): void;
        /**
         * @en
         * Scaling this sphere.
         * @zh
         * 将 out 根据这个 sphere 的数据进行缩放。
         * @param scale 缩放值。
         * @param out 缩放的目标。
         */
        setScale(scale: Vec3, out: sphere): void;
    }
}
declare module "cocos/core/geometry/triangle" {
    /**
     * @category geometry
     */
    import { Vec3 } from "cocos/core/math/index";
    /**
     * @en
     * Basic Geometry: triangle.
     * @zh
     * 基础几何 三角形。
     */
    export default class triangle {
        /**
         * @en
         * create a new triangle
         * @zh
         * 创建一个新的 triangle。
         * @param {number} ax a 点的 x 部分。
         * @param {number} ay a 点的 y 部分。
         * @param {number} az a 点的 z 部分。
         * @param {number} bx b 点的 x 部分。
         * @param {number} by b 点的 y 部分。
         * @param {number} bz b 点的 z 部分。
         * @param {number} cx c 点的 x 部分。
         * @param {number} cy c 点的 y 部分。
         * @param {number} cz c 点的 z 部分。
         * @return {triangle} 一个新的 triangle。
         */
        static create(ax?: number, ay?: number, az?: number, bx?: number, by?: number, bz?: number, cx?: number, cy?: number, cz?: number): triangle;
        /**
         * @en
         * clone a new triangle
         * @zh
         * 克隆一个新的 triangle。
         * @param {triangle} t 克隆的目标。
         * @return {triangle} 克隆出的新对象。
         */
        static clone(t: triangle): triangle;
        /**
         * @en
         * copy the values from one triangle to another
         * @zh
         * 将一个 triangle 的值复制到另一个 triangle。
         * @param {triangle} out 接受操作的 triangle。
         * @param {triangle} t 被复制的 triangle。
         * @return {triangle} out 接受操作的 triangle。
         */
        static copy(out: triangle, t: triangle): triangle;
        /**
         * @en
         * Create a triangle from three points
         * @zh
         * 用三个点创建一个 triangle。
         * @param {triangle} out 接受操作的 triangle。
         * @param {Vec3} a a 点。
         * @param {Vec3} b b 点。
         * @param {Vec3} c c 点。
         * @return {triangle} out 接受操作的 triangle。
         */
        static fromPoints(out: triangle, a: Vec3, b: Vec3, c: Vec3): triangle;
        /**
         * @en
         * Set the components of a triangle to the given values
         * @zh
         * 将给定三角形的属性设置为给定值。
         * @param {triangle} out 给定的三角形。
         * @param {number} ax a 点的 x 部分。
         * @param {number} ay a 点的 y 部分。
         * @param {number} az a 点的 z 部分。
         * @param {number} bx b 点的 x 部分。
         * @param {number} by b 点的 y 部分。
         * @param {number} bz b 点的 z 部分。
         * @param {number} cx c 点的 x 部分。
         * @param {number} cy c 点的 y 部分。
         * @param {number} cz c 点的 z 部分。
         * @return {triangle}
         * @function
         */
        static set(out: triangle, ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): triangle;
        /**
         * @en
         * Point a.
         * @zh
         * 点 a。
         */
        a: Vec3;
        /**
         * @en
         * Point b.
         * @zh
         * 点 b。
         */
        b: Vec3;
        /**
         * @en
         * Point c.
         * @zh
         * 点 c。
         */
        c: Vec3;
        /**
         * @en
         * Gets the type of the shape.
         * @zh
         * 获取形状的类型。
         */
        get type(): number;
        protected readonly _type: number;
        /**
         * @en
         * Construct a triangle.
         * @zh
         * 构造一个三角形。
         * @param {number} ax a 点的 x 部分。
         * @param {number} ay a 点的 y 部分。
         * @param {number} az a 点的 z 部分。
         * @param {number} bx b 点的 x 部分。
         * @param {number} by b 点的 y 部分。
         * @param {number} bz b 点的 z 部分。
         * @param {number} cx c 点的 x 部分。
         * @param {number} cy c 点的 y 部分。
         * @param {number} cz c 点的 z 部分。
         */
        constructor(ax?: number, ay?: number, az?: number, bx?: number, by?: number, bz?: number, cx?: number, cy?: number, cz?: number);
    }
}
declare module "cocos/core/gfx/sampler" {
    /**
     * @category gfx
     */
    import { GFXAddress, GFXComparisonFunc, GFXFilter, GFXObject, GFXColor } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    export interface IGFXSamplerInfo {
        name?: string;
        minFilter?: GFXFilter;
        magFilter?: GFXFilter;
        mipFilter?: GFXFilter;
        addressU?: GFXAddress;
        addressV?: GFXAddress;
        addressW?: GFXAddress;
        maxAnisotropy?: number;
        cmpFunc?: GFXComparisonFunc;
        borderColor?: GFXColor;
        minLOD?: number;
        maxLOD?: number;
        mipLODBias?: number;
    }
    /**
     * @en GFX sampler state.
     * @zh GFX 采样器状态。
     */
    export class GFXSamplerState {
        name: string;
        minFilter: GFXFilter;
        magFilter: GFXFilter;
        mipFilter: GFXFilter;
        addressU: GFXAddress;
        addressV: GFXAddress;
        addressW: GFXAddress;
        maxAnisotropy: number;
        cmpFunc: GFXComparisonFunc;
        borderColor: GFXColor;
        minLOD: number;
        maxLOD: number;
        mipLODBias: number;
        compare(state: GFXSamplerState): boolean;
    }
    /**
     * @en GFX sampler.
     * @zh GFX 采样器。
     */
    export abstract class GFXSampler extends GFXObject {
        /**
         * @en Get current sampler state.
         * @zh GFX 采样器状态。
         */
        get state(): GFXSamplerState;
        protected _device: GFXDevice;
        protected _state: GFXSamplerState;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXSamplerInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/gfx/texture" {
    /**
     * @category gfx
     */
    import { GFXFormat, GFXObject, GFXSampleCount, GFXTextureFlags, GFXTextureType, GFXTextureUsage } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    export interface IGFXTextureInfo {
        type: GFXTextureType;
        usage: GFXTextureUsage;
        format: GFXFormat;
        width: number;
        height: number;
        depth?: number;
        layerCount?: number;
        levelCount?: number;
        samples?: GFXSampleCount;
        flags?: GFXTextureFlags;
    }
    export interface IGFXTextureViewInfo {
        texture: GFXTexture;
        type: GFXTextureType;
        format: GFXFormat;
        baseLevel?: number;
        levelCount?: number;
        baseLayer?: number;
        layerCount?: number;
    }
    export function IsPowerOf2(x: number): boolean;
    /**
     * @en GFX texture.
     * @zh GFX 纹理。
     */
    export abstract class GFXTexture extends GFXObject {
        /**
         * @en Get texture type.
         * @zh 纹理类型。
         */
        get type(): GFXTextureType;
        /**
         * @en Get texture usage.
         * @zh 纹理使用方式。
         */
        get usage(): GFXTextureUsage;
        /**
         * @en Get texture format.
         * @zh 纹理格式。
         */
        get format(): GFXFormat;
        /**
         * @en Get texture width.
         * @zh 纹理宽度。
         */
        get width(): number;
        /**
         * @en Get texture height.
         * @zh 纹理高度。
         */
        get height(): number;
        /**
         * @en Get texture depth.
         * @zh 纹理深度。
         */
        get depth(): number;
        /**
         * @en Get texture array layer.
         * @zh 纹理数组层数。
         */
        get layerCount(): number;
        /**
         * @en Get texture mip level.
         * @zh 纹理 mip 层级数。
         */
        get levelCount(): number;
        /**
         * @en Get texture samples.
         * @zh 纹理采样数。
         */
        get samples(): GFXSampleCount;
        /**
         * @en Get texture flags.
         * @zh 纹理标识位。
         */
        get flags(): GFXTextureFlags;
        /**
         * @en Get texture size.
         * @zh 纹理大小。
         */
        get size(): number;
        /**
         * @en Get texture buffer.
         * @zh 纹理缓冲。
         */
        get buffer(): ArrayBuffer | null;
        protected _device: GFXDevice;
        protected _type: GFXTextureType;
        protected _usage: GFXTextureUsage;
        protected _format: GFXFormat;
        protected _width: number;
        protected _height: number;
        protected _depth: number;
        protected _layerCount: number;
        protected _levelCount: number;
        protected _samples: GFXSampleCount;
        protected _flags: GFXTextureFlags;
        protected _isPowerOf2: boolean;
        protected _size: number;
        protected _buffer: ArrayBuffer | null;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXTextureInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Resize texture.
         * @zh 重置纹理大小。
         * @param width The new width.
         * @param height The new height.
         */
        abstract resize(width: number, height: number): void;
    }
}
declare module "cocos/core/gfx/descriptor-set-layout" {
    /**
     * @category gfx
     */
    import { GFXDescriptorType, GFXObject, GFXShaderStageFlags } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXSampler } from "cocos/core/gfx/sampler";
    export interface IGFXDescriptorSetLayoutBinding {
        descriptorType: GFXDescriptorType;
        count: number;
        stageFlags: GFXShaderStageFlags;
        immutableSamplers?: GFXSampler[];
    }
    export interface IGFXDescriptorSetLayoutInfo {
        bindings: IGFXDescriptorSetLayoutBinding[];
    }
    export const DESCRIPTOR_DYNAMIC_TYPE: number;
    /**
     * @en GFX descriptor sets layout.
     * @zh GFX 描述符集布局。
     */
    export abstract class GFXDescriptorSetLayout extends GFXObject {
        get bindings(): IGFXDescriptorSetLayoutBinding[];
        get descriptorIndices(): number[];
        protected _device: GFXDevice;
        protected _bindings: IGFXDescriptorSetLayoutBinding[];
        protected _descriptorIndices: number[];
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXDescriptorSetLayoutInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/gfx/descriptor-set" {
    /**
     * @category gfx
     */
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXDescriptorType, GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXSampler } from "cocos/core/gfx/sampler";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { GFXDescriptorSetLayout } from "cocos/core/gfx/descriptor-set-layout";
    export const DESCRIPTOR_BUFFER_TYPE: number;
    export const DESCRIPTOR_SAMPLER_TYPE = GFXDescriptorType.SAMPLER;
    export interface IGFXDescriptorSetInfo {
        layout: GFXDescriptorSetLayout;
    }
    /**
     * @en GFX descriptor sets.
     * @zh GFX 描述符集组。
     */
    export abstract class GFXDescriptorSet extends GFXObject {
        get layout(): GFXDescriptorSetLayout;
        protected _device: GFXDevice;
        protected _layout: GFXDescriptorSetLayout | null;
        protected _buffers: GFXBuffer[];
        protected _textures: GFXTexture[];
        protected _samplers: GFXSampler[];
        protected _isDirty: boolean;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXDescriptorSetInfo): boolean;
        abstract destroy(): void;
        abstract update(): void;
        /**
         * @en Bind buffer to the specified descriptor.
         * @zh 在指定的描述符位置上绑定缓冲。
         * @param binding The target binding.
         * @param buffer The buffer to be bound.
         */
        bindBuffer(binding: number, buffer: GFXBuffer, index?: number): void;
        /**
         * @en Bind sampler to the specified descriptor.
         * @zh 在指定的描述符位置上绑定采样器。
         * @param binding The target binding.
         * @param sampler The sampler to be bound.
         */
        bindSampler(binding: number, sampler: GFXSampler, index?: number): void;
        /**
         * @en Bind texture to the specified descriptor.
         * @zh 在指定的描述符位置上绑定纹理。
         * @param binding The target binding.
         * @param texture The texture to be bound.
         */
        bindTexture(binding: number, texture: GFXTexture, index?: number): void;
        /**
         * @en Get buffer from the specified binding location.
         * @zh 获取当前指定绑定位置上的缓冲。
         * @param binding The target binding.
         */
        getBuffer(binding: number, index?: number): GFXBuffer;
        /**
         * @en Get sampler from the specified binding location.
         * @zh 获取当前指定绑定位置上的采样器。
         * @param binding The target binding.
         */
        getSampler(binding: number, index?: number): GFXSampler;
        /**
         * @en Get texture from the specified binding location.
         * @zh 获取当前指定绑定位置上的贴图。
         * @param binding The target binding.
         */
        getTexture(binding: number, index?: number): GFXTexture;
    }
}
declare module "cocos/core/utils/murmurhash2_gc" {
    export function murmurhash2_32_gc(input: string | Uint8Array, seed: number): number;
}
declare module "cocos/core/gfx/render-pass" {
    /**
     * @category gfx
     */
    import { GFXFormat, GFXLoadOp, GFXObject, GFXPipelineBindPoint, GFXStoreOp, GFXTextureLayout } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    /**
     * @en Color attachment.
     * @zh GFX 颜色附件。
     */
    export class GFXColorAttachment {
        format: GFXFormat;
        sampleCount: number;
        loadOp: GFXLoadOp;
        storeOp: GFXStoreOp;
        beginLayout: GFXTextureLayout;
        endLayout: GFXTextureLayout;
    }
    /**
     * @en Depth stencil attachment.
     * @zh GFX 深度模板附件。
     */
    export class GFXDepthStencilAttachment {
        format: GFXFormat;
        sampleCount: number;
        depthLoadOp: GFXLoadOp;
        depthStoreOp: GFXStoreOp;
        stencilLoadOp: GFXLoadOp;
        stencilStoreOp: GFXStoreOp;
        beginLayout: GFXTextureLayout;
        endLayout: GFXTextureLayout;
    }
    export interface IGFXSubPassInfo {
        bindPoint: GFXPipelineBindPoint;
        inputs: number[];
        colors: number[];
        resolves: number[];
        depthStencil?: number;
        preserves: number[];
    }
    export interface IGFXRenderPassInfo {
        colorAttachments: GFXColorAttachment[];
        depthStencilAttachment: GFXDepthStencilAttachment | null;
        subPasses?: IGFXSubPassInfo[];
    }
    /**
     * @en GFX render pass.
     * @zh GFX 渲染过程。
     */
    export abstract class GFXRenderPass extends GFXObject {
        protected _device: GFXDevice;
        protected _colorInfos: GFXColorAttachment[];
        protected _depthStencilInfo: GFXDepthStencilAttachment | null;
        protected _subPasses: IGFXSubPassInfo[];
        protected _hash: number;
        get colorAttachments(): GFXColorAttachment[];
        get depthStencilAttachment(): GFXDepthStencilAttachment | null;
        get subPasses(): IGFXSubPassInfo[];
        get hash(): number;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXRenderPassInfo): boolean;
        abstract destroy(): void;
        protected computeHash(): number;
    }
}
declare module "cocos/core/gfx/framebuffer" {
    /**
     * @category gfx
     */
    import { GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    import { GFXTexture } from "cocos/core/gfx/texture";
    export interface IGFXFramebufferInfo {
        renderPass: GFXRenderPass;
        colorTextures: (GFXTexture | null)[];
        depthStencilTexture: GFXTexture | null;
        colorMipmapLevels?: number[];
        depStencilMipmapLevel?: number;
    }
    /**
     * @en GFX frame buffer.
     * @zh GFX 帧缓冲。
     */
    export abstract class GFXFramebuffer extends GFXObject {
        /**
         * @en Get current render pass.
         * @zh GFX 渲染过程。
         */
        get renderPass(): GFXRenderPass;
        /**
         * @en Get current color views.
         * @zh 颜色纹理视图数组。
         */
        get colorTextures(): (GFXTexture | null)[];
        /**
         * @en Get current depth stencil views.
         * @zh 深度模板纹理视图。
         */
        get depthStencilTexture(): GFXTexture | null;
        protected _device: GFXDevice;
        protected _renderPass: GFXRenderPass | null;
        protected _colorTextures: (GFXTexture | null)[];
        protected _depthStencilTexture: GFXTexture | null;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXFramebufferInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/gfx/input-assembler" {
    /**
     * @category gfx
     */
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXFormat, GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    export interface IGFXAttribute {
        name: string;
        format: GFXFormat;
        isNormalized?: boolean;
        stream?: number;
        isInstanced?: boolean;
        location?: number;
    }
    export interface IGFXInputAssemblerInfo {
        attributes: IGFXAttribute[];
        vertexBuffers: GFXBuffer[];
        indexBuffer?: GFXBuffer;
        indirectBuffer?: GFXBuffer;
    }
    /**
     * @en GFX input assembler.
     * @zh GFX 输入汇集器。
     */
    export abstract class GFXInputAssembler extends GFXObject {
        /**
         * @en Get current vertex buffers.
         * @zh 顶点缓冲数组。
         */
        get vertexBuffers(): GFXBuffer[];
        /**
         * @en Get current index buffer.
         * @zh 索引缓冲。
         */
        get indexBuffer(): GFXBuffer | null;
        /**
         * @en Get current attributes.
         * @zh 顶点属性数组。
         */
        get attributes(): IGFXAttribute[];
        /**
         * @en Get hash of current attributes.
         * @zh 获取顶点属性数组的哈希值。
         */
        get attributesHash(): number;
        /**
         * @en Get current vertex count.
         * @zh 顶点数量。
         */
        get vertexCount(): number;
        set vertexCount(count: number);
        /**
         * @en Get starting vertex.
         * @zh 起始顶点。
         */
        get firstVertex(): number;
        set firstVertex(first: number);
        /**
         * @en Get current index count.
         * @zh 索引数量。
         */
        get indexCount(): number;
        set indexCount(count: number);
        /**
         * @en Get starting index.
         * @zh 起始索引。
         */
        get firstIndex(): number;
        set firstIndex(first: number);
        /**
         * @en Get current vertex offset.
         * @zh 顶点偏移量。
         */
        get vertexOffset(): number;
        set vertexOffset(offset: number);
        /**
         * @en Get current instance count.
         * @zh 实例数量。
         */
        get instanceCount(): number;
        set instanceCount(count: number);
        /**
         * @en Get starting instance.
         * @zh 起始实例。
         */
        get firstInstance(): number;
        set firstInstance(first: number);
        /**
         * @en Get the indirect buffer, if present.
         * @zh 间接绘制缓冲。
         */
        get indirectBuffer(): GFXBuffer | null;
        protected _device: GFXDevice;
        protected _attributes: IGFXAttribute[];
        protected _vertexBuffers: GFXBuffer[];
        protected _indexBuffer: GFXBuffer | null;
        protected _vertexCount: number;
        protected _firstVertex: number;
        protected _indexCount: number;
        protected _firstIndex: number;
        protected _vertexOffset: number;
        protected _instanceCount: number;
        protected _firstInstance: number;
        protected _attributesHash: number;
        protected _indirectBuffer: GFXBuffer | null;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXInputAssemblerInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Get the specified vertex buffer.
         * @zh 获取顶点缓冲。
         * @param stream The stream index of the vertex buffer.
         */
        getVertexBuffer(stream?: number): GFXBuffer | null;
        protected computeAttributesHash(): number;
    }
}
declare module "cocos/core/gfx/shader" {
    /**
     * @category gfx
     */
    import { GFXObject, GFXShaderStageFlagBit, GFXType } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    export class GFXShaderStage {
        stage: GFXShaderStageFlagBit;
        source: string;
    }
    /**
     * @en GFX uniform.
     * @zh GFX uniform。
     */
    export class GFXUniform {
        name: string;
        type: GFXType;
        count: number;
    }
    /**
     * @en GFX uniform block.
     * @zh GFX uniform 块。
     */
    export class GFXUniformBlock {
        set: number;
        binding: number;
        name: string;
        members: GFXUniform[];
        count: number;
    }
    /**
     * @en GFX uniform sampler.
     * @zh GFX Uniform 采样器。
     */
    export class GFXUniformSampler {
        set: number;
        binding: number;
        name: string;
        type: GFXType;
        count: number;
    }
    export class GFXShaderInfo {
        name: string;
        stages: GFXShaderStage[];
        attributes: IGFXAttribute[];
        blocks: GFXUniformBlock[];
        samplers: GFXUniformSampler[];
    }
    /**
     * @en GFX shader.
     * @zh GFX 着色器。
     */
    export abstract class GFXShader extends GFXObject {
        /**
         * @en Get current shader id.
         * @zh 着色器 id。
         */
        get id(): number;
        /**
         * @en Get current shader name.
         * @zh 着色器名称。
         */
        get name(): string;
        get attributes(): IGFXAttribute[];
        get blocks(): GFXUniformBlock[];
        get samplers(): GFXUniformSampler[];
        protected _device: GFXDevice;
        protected _id: number;
        protected _name: string;
        protected _stages: GFXShaderStage[];
        protected _attributes: IGFXAttribute[];
        protected _blocks: GFXUniformBlock[];
        protected _samplers: GFXUniformSampler[];
        constructor(device: GFXDevice);
        abstract initialize(info: GFXShaderInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/utils/path" {
    /**
     * @en Join strings to be a path.
     * @zh 拼接字符串为路径。
     * @example {@link cocos/core/utils/CCPath/join.js}
     */
    export function join(...segments: string[]): string;
    /**
     * @en Get the ext name of a path including '.', like '.png'.
     * @zh 返回 Path 的扩展名，包括 '.'，例如 '.png'。
     * @example {@link cocos/core/utils/CCPath/extname.js}
     */
    export function extname(path: string): string;
    /**
     * @en Get the main name of a file name.
     * @zh 获取文件名的主名称。
     * @deprecated
     */
    export function mainFileName(fileName: string): string;
    /**
     * @en Get the file name of a file path.
     * @zh 获取文件路径的文件名。
     * @example {@link cocos/core/utils/CCPath/basename.js}
     */
    export function basename(path: string, extName?: string): string;
    /**
     * @en Get dirname of a file path.
     * @zh 获取文件路径的目录名。
     * @example {@link cocos/core/utils/CCPath/dirname.js}
     */
    export function dirname(path: string): string;
    /**
     * @en Change extname of a file path.
     * @zh 更改文件路径的扩展名。
     * @example {@link cocos/core/utils/CCPath/changeExtname.js}
     */
    export function changeExtname(path: string, extName?: string): string;
    /**
     * @en Change file name of a file path.
     * @zh 更改文件路径的文件名。
     * @example {@link cocos/core/utils/CCPath/changeBasename.js}
     */
    export function changeBasename(path: string, baseName: string, isSameExt?: boolean): string;
    export function _normalize(url: any): any;
    export function stripSep(path: string): string;
    export function getSeperator(): "/" | "\\";
}
declare module "cocos/core/utils/text-utils" {
    /**
     * @hide
     */
    export const BASELINE_RATIO = 0.26;
    export function isUnicodeCJK(ch: string): boolean;
    export function isUnicodeSpace(ch: string): boolean;
    export function safeMeasureText(ctx: CanvasRenderingContext2D, string: string): number;
    export function fragmentText(stringToken: string, allWidth: number, maxWidth: number, measureText: (string: string) => number): string[];
}
declare module "cocos/core/utils/html-text-parser" {
    /**
     * A utils class for parsing HTML texts. The parsed results will be an object array.
     */
    export interface IHtmlTextParserResultObj {
        text?: string;
        style?: IHtmlTextParserStack;
    }
    export interface IHtmlTextParserStack {
        color?: string;
        size?: number;
        event?: Map<string, string>;
        isNewLine?: boolean;
        isImage?: boolean;
        src?: string;
        imageWidth?: number;
        imageHeight?: number;
        imageOffset?: string;
        imageAlign?: string;
        underline?: boolean;
        italic?: boolean;
        bold?: boolean;
        outline?: {
            color: string;
            width: number;
        };
    }
    export class HtmlTextParser {
        private _specialSymbolArray;
        private _stack;
        private _resultObjectArray;
        constructor();
        parse(htmlString: string): IHtmlTextParserResultObj[];
        private _attributeToObject;
        private _processEventHandler;
        private _addToStack;
        private _processResult;
        private _escapeSpecialSymbol;
    }
}
declare module "cocos/core/utils/prefab-helper" {
    export class PrefabInfo {
        root: null;
        asset: null;
        fileId: string;
        sync: boolean;
        _synced: {
            default: boolean;
            serializable: boolean;
        };
    }
    export default function syncWithPrefab(node: any): void;
}
declare module "cocos/core/data/utils/compiler" {
    export function flattenCodeArray(array: any): string;
}
declare module "cocos/core/data/instantiate-jit" {
    export function equalsToDefault(def: any, value: any): boolean;
    export function compile(node: any): any;
}
declare module "cocos/core/assets/prefab" {
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @en Class for prefab handling.
     * @zh 预制资源类。
     */
    export default class Prefab extends Asset {
        static OptimizationPolicy: {
            /**
             * 根据创建次数自动调整优化策略。初次创建实例时，行为等同 SINGLE_INSTANCE，多次创建后将自动采用 MULTI_INSTANCE。
             */
            AUTO: number;
            /**
             * 优化单次创建性能。<br>
             * 该选项会跳过针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般只会创建一个实例时，请选择此项。
             */
            SINGLE_INSTANCE: number;
            /**
             * 优化多次创建性能。<br>
             * 该选项会启用针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般会创建多个实例时，请选择此项。如果该 prefab 在场景中的节点启用了自动关联，并且在场景中有多份实例，也建议选择此项。
             */
            MULTI_INSTANCE: number;
        };
        static OptimizationPolicyThreshold: number;
        data: any;
        /**
         * @zh
         * 设置实例化这个 prefab 时所用的优化策略。根据使用情况设置为合适的值，能优化该 prefab 实例化所用的时间。
         * @en
         * Indicates the optimization policy for instantiating this prefab.
         * Set to a suitable value based on usage, can optimize the time it takes to instantiate this prefab.
         *
         * @default Prefab.OptimizationPolicy.AUTO
         * @since 1.10.0
         * @example
         * ```ts
         * import { Prefab } from 'cc';
         * prefab.optimizationPolicy = Prefab.OptimizationPolicy.MULTI_INSTANCE;
         * ```
         */
        optimizationPolicy: number;
        /**
         * @en Indicates the raw assets of this prefab can be load after prefab loaded.
         * @zh 指示该 Prefab 依赖的资源可否在 Prefab 加载后再延迟加载。
         * @default false
         */
        asyncLoadAssets: Boolean;
        private _createFunction;
        private _instantiatedTimes;
        constructor();
        createNode(cb: Function): void;
        /**
         * @en
         * Dynamically translation prefab data into minimized code.<br/>
         * This method will be called automatically before the first time the prefab being instantiated,<br/>
         * but you can re-call to refresh the create function once you modified the original prefab data in script.
         * @zh
         * 将预制数据动态转换为最小化代码。<br/>
         * 此方法将在第一次实例化预制件之前自动调用，<br/>
         * 但是您可以在脚本中修改原始预制数据后重新调用以刷新创建功能。
         */
        compileCreateFunction(): void;
        private _doInstantiate;
        private _instantiate;
    }
}
declare module "cocos/core/assets/scene-asset" {
    import { Scene } from "cocos/core/scene-graph/index";
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @en Class for scene handling.
     * @zh 场景资源类。
     * @class SceneAsset
     * @extends Asset
     *
     */
    export default class SceneAsset extends Asset {
        /**
         * 场景结点。
         */
        scene: Scene | null;
        /**
         * @en Indicates the raw assets of this scene can be load after scene launched.
         * @zh 指示该场景依赖的资源可否在场景切换后再延迟加载。
         * @default false
         */
        asyncLoadAssets: boolean;
    }
}
declare module "cocos/core/assets/asset-enum" {
    /**
     * @en
     * The texture pixel format, default value is RGBA8888,<br>
     * you should note that textures loaded by normal image files (png, jpg) can only support RGBA8888 format,<br>
     * other formats are supported by compressed file types or raw data.
     * @zh
     * 纹理像素格式，默认值为RGBA8888，<br>
     * 你应该注意到普通图像文件（png，jpg）加载的纹理只能支持RGBA8888格式，<br>
     * 压缩文件类型或原始数据支持其他格式。
     */
    export enum PixelFormat {
        /**
         * @en
         * 16-bit texture without Alpha channel
         * @zh
         * 没有透明度通道的16位纹理。
         */
        RGB565 = 47,
        /**
         * @en
         * 16-bit textures: RGB5A1
         * @zh
         * 16位纹理：RGB5A1。
         */
        RGB5A1 = 49,
        /**
         * @en
         * 16-bit textures: RGBA4444
         * @zh
         * 16位纹理：RGBA4444。
         */
        RGBA4444 = 50,
        /**
         * @en
         * 24-bit texture: RGB888
         * @zh
         * 24位纹理：RGB888。
         */
        RGB888 = 24,
        /**
         * @en
         * 32-bit float texture: RGBA32F
         * @zh
         * 32位纹理：RGBA32F。
         */
        RGB32F = 32,
        /**
         * @en
         * 32-bit texture: RGBA8888
         * @zh
         * 32位纹理：RGBA8888。
         */
        RGBA8888 = 35,
        /**
         * @en
         * 32-bit float texture: RGBA32F
         * @zh
         * 32位纹理：RGBA32F。
         */
        RGBA32F = 44,
        /**
         * @en
         * 8-bit textures used as masks
         * @zh
         * 用作蒙版的8位纹理。
         */
        A8 = 1,
        /**
         * @en
         * 8-bit intensity texture
         * @zh
         * 8位强度纹理。
         */
        I8 = 2,
        /**
         * @en
         * 16-bit textures used as masks
         * @zh
         * 用作蒙版的16位纹理。
         */
        AI8 = 3,
        /**
         * rgb 2 bpp pvrtc
         */
        RGB_PVRTC_2BPPV1 = 87,
        /**
         * rgba 2 bpp pvrtc
         */
        RGBA_PVRTC_2BPPV1 = 88,
        /**
         * rgb separate a 2 bpp pvrtc
         * RGB_A_PVRTC_2BPPV1 texture is a 2x height RGB_PVRTC_2BPPV1 format texture.
         * It separate the origin alpha channel to the bottom half atlas, the origin rgb channel to the top half atlas
         */
        RGB_A_PVRTC_2BPPV1,
        /**
         * rgb 4 bpp pvrtc
         */
        RGB_PVRTC_4BPPV1 = 89,
        /**
         * rgba 4 bpp pvrtc
         */
        RGBA_PVRTC_4BPPV1 = 90,
        /**
         * rgb a 4 bpp pvrtc
         * RGB_A_PVRTC_4BPPV1 texture is a 2x height RGB_PVRTC_4BPPV1 format texture.
         * It separate the origin alpha channel to the bottom half atlas, the origin rgb channel to the top half atlas
         */
        RGB_A_PVRTC_4BPPV1,
        /**
         * rgb etc1
         */
        RGB_ETC1 = 76,
        /**
         * rgba etc1
         */
        RGBA_ETC1,
        /**
         * rgb etc2
         */
        RGB_ETC2 = 77,
        /**
         * rgba etc2
         */
        RGBA_ETC2 = 81,
        RGBA_ASTC_4x4 = 93,
        RGBA_ASTC_5x4 = 94,
        RGBA_ASTC_5x5 = 95,
        RGBA_ASTC_6x5 = 96,
        RGBA_ASTC_6x6 = 97,
        RGBA_ASTC_8x5 = 98,
        RGBA_ASTC_8x6 = 99,
        RGBA_ASTC_8x8 = 100,
        RGBA_ASTC_10x5 = 101,
        RGBA_ASTC_10x6 = 102,
        RGBA_ASTC_10x8 = 103,
        RGBA_ASTC_10x10 = 104,
        RGBA_ASTC_12x10 = 105,
        RGBA_ASTC_12x12 = 106
    }
    /**
     * @en
     * The texture wrap mode.
     * @zh
     * 纹理环绕方式。
     */
    export enum WrapMode {
        /**
         * @en
         * Specifies that the repeat warp mode will be used.
         * @zh
         * 指定环绕模式：重复纹理图像。
         */
        REPEAT = 0,
        /**
         * @en
         * Specifies that the clamp to edge warp mode will be used.
         * @zh
         * 指定环绕模式：纹理边缘拉伸效果。
         */
        CLAMP_TO_EDGE = 2,
        /**
         * @en
         * Specifies that the mirrored repeat warp mode will be used.
         * @zh
         * 指定环绕模式：以镜像模式重复纹理图像。
         */
        MIRRORED_REPEAT = 1,
        /**
         * @en
         * Specifies that the  clamp to border wrap mode will be used.
         * @zh
         * 指定环绕模式：超出纹理坐标部分以用户指定颜色填充。
         */
        CLAMP_TO_BORDER = 3
    }
    /**
     * @en
     * The texture filter mode
     * @zh
     * 纹理过滤模式。
     */
    export enum Filter {
        NONE = 0,
        /**
         * @en
         * Specifies linear filtering.
         * @zh
         * 线性过滤模式。
         */
        LINEAR = 2,
        /**
         * @en
         * Specifies nearest filtering.
         * @zh
         * 临近过滤模式。
         */
        NEAREST = 1
    }
}
declare module "cocos/core/assets/image-asset" {
    import { Asset } from "cocos/core/assets/asset";
    import { PixelFormat } from "cocos/core/assets/asset-enum";
    /**
     * 内存图像源。
     */
    export interface IMemoryImageSource {
        _data: ArrayBufferView | null;
        _compressed: boolean;
        width: number;
        height: number;
        format: number;
    }
    /**
     * 图像资源的原始图像源。可以来源于 HTML 元素也可以来源于内存。
     */
    export type ImageSource = HTMLCanvasElement | HTMLImageElement | IMemoryImageSource;
    /**
     * 图像资源。
     */
    export class ImageAsset extends Asset {
        get _nativeAsset(): ImageSource;
        set _nativeAsset(value: ImageSource);
        /**
         * 此图像资源的图像数据。
         */
        get data(): ArrayBufferView | HTMLCanvasElement | HTMLImageElement | null;
        /**
         * 此图像资源的像素宽度。
         */
        get width(): number;
        /**
         * 此图像资源的像素高度。
         */
        get height(): number;
        /**
         * 此图像资源的像素格式。
         */
        get format(): PixelFormat;
        /**
         * 此图像资源是否为压缩像素格式。
         */
        get isCompressed(): boolean;
        /**
         * 此图像资源的原始图像源的 URL。当原始图像元不是 HTML 文件时可能为空。
         * @deprecated 请转用 `this.nativeUrl`。
         */
        get url(): string;
        set _texture(tex: any);
        get _texture(): any;
        private static extnames;
        private _nativeData;
        private _tex;
        private _url;
        private _exportedExts;
        private _format;
        private _width;
        private _height;
        /**
         * @param nativeAsset
         */
        constructor(nativeAsset?: ImageSource);
        /**
         * 重置此图像资源使用的原始图像源。
         * @param data 新的原始图像源。
         */
        reset(data: ImageSource): void;
        destroy(): boolean;
        _serialize(): "" | {
            fmt: string;
            w: number;
            h: number;
        };
        _deserialize(data: any, handle: any): void;
        _onDataComplete(): void;
    }
}
declare module "cocos/core/renderer/core/sampler-lib" {
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXSampler } from "cocos/core/gfx/sampler";
    export enum SamplerInfoIndex {
        minFilter = 0,
        magFilter = 1,
        mipFilter = 2,
        addressU = 3,
        addressV = 4,
        addressW = 5,
        maxAnisotropy = 6,
        cmpFunc = 7,
        minLOD = 8,
        maxLOD = 9,
        mipLODBias = 10,
        total = 11
    }
    export const defaultSamplerHash: number;
    export function genSamplerHash(info: (number | undefined)[]): number;
    /**
     * @zh
     * 维护 sampler 资源实例的全局管理器。
     */
    class SamplerLib {
        protected _cache: Record<number, GFXSampler>;
        /**
         * @zh
         * 获取指定属性的 sampler 资源。
         * @param device 渲染设备 [GFXDevice]
         * @param info 目标 sampler 属性
         */
        getSampler(device: GFXDevice, hash: number): GFXSampler;
    }
    export const samplerLib: SamplerLib;
}
declare module "cocos/core/assets/texture-base" {
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { Asset } from "cocos/core/assets/asset";
    import { Filter, PixelFormat, WrapMode } from "cocos/core/assets/asset-enum";
    import { GFXSampler } from "cocos/core/gfx/index";
    /**
     * 贴图资源基类。它定义了所有贴图共用的概念。
     */
    export class TextureBase extends Asset {
        /**
         * 此贴图是否为压缩的像素格式。
         */
        get isCompressed(): boolean;
        /**
         * 此贴图的像素宽度。
         */
        get width(): number;
        /**
         * 此贴图的像素高度。
         */
        get height(): number;
        static PixelFormat: typeof PixelFormat;
        static WrapMode: typeof WrapMode;
        static Filter: typeof Filter;
        protected _format: number;
        protected _minFilter: number;
        protected _magFilter: number;
        protected _mipFilter: number;
        protected _wrapS: number;
        protected _wrapT: number;
        protected _wrapR: number;
        protected _anisotropy: number;
        protected _width: number;
        protected _height: number;
        private _id;
        private _samplerInfo;
        private _samplerHash;
        private _gfxSampler;
        private _gfxDevice;
        constructor();
        /**
         * 获取标识符。
         * @returns 此贴图的标识符。
         */
        getId(): string;
        /**
         * 获取像素格式。
         * @returns 此贴图的像素格式。
         */
        getPixelFormat(): number;
        /**
         * 获取各向异性。
         * @returns 此贴图的各向异性。
         */
        getAnisotropy(): number;
        /**
         * 设置此贴图的缠绕模式。
         * 注意，若贴图尺寸不是 2 的整数幂，缠绕模式仅允许 `WrapMode.CLAMP_TO_EDGE`。
         * @param wrapS S(U) 坐标的采样模式。
         * @param wrapT T(V) 坐标的采样模式。
         * @param wrapR R(W) 坐标的采样模式。
         */
        setWrapMode(wrapS: WrapMode, wrapT: WrapMode, wrapR?: WrapMode): void;
        /**
         * 设置此贴图的过滤算法。
         * @param minFilter 缩小过滤算法。
         * @param magFilter 放大过滤算法。
         */
        setFilters(minFilter: Filter, magFilter: Filter): void;
        /**
         * 设置此贴图的 mip 过滤算法。
         * @param mipFilter mip 过滤算法。
         */
        setMipFilter(mipFilter: Filter): void;
        /**
         * 设置此贴图的各向异性。
         * @param anisotropy 各向异性。
         */
        setAnisotropy(anisotropy: number): void;
        /**
         * 销毁此贴图，并释放占有的所有 GPU 资源。
         */
        destroy(): boolean;
        /**
         * 获取此贴图底层的 GFX 纹理对象。
         */
        getGFXTexture(): GFXTexture | null;
        /**
         * 获取此贴图内部使用的 GFX 采样器信息。
         * @private
         */
        getSamplerHash(): number;
        /**
         * 获取此贴图底层的 GFX 采样信息。
         */
        getGFXSampler(): GFXSampler;
        /**
         * @return
         */
        _serialize(exporting?: any): any;
        /**
         *
         * @param data
         */
        _deserialize(serializedData: any, handle: any): void;
        protected _getGFXDevice(): GFXDevice | null;
        protected _getGFXFormat(): any;
        protected _setGFXFormat(format?: PixelFormat): void;
        protected _getGFXPixelFormat(format: any): any;
    }
}
declare module "cocos/core/assets/simple-texture" {
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXTexture, IGFXTextureInfo } from "cocos/core/gfx/texture";
    import { ImageAsset } from "cocos/core/assets/image-asset";
    import { TextureBase } from "cocos/core/assets/texture-base";
    export type PresumedGFXTextureInfo = Pick<IGFXTextureInfo, 'usage' | 'flags' | 'format' | 'levelCount'>;
    /**
     * 简单贴图基类。
     * 简单贴图内部创建了 GFX 贴图和该贴图上的 GFX 贴图视图。
     * 简单贴图允许指定不同的 Mipmap 层级。
     */
    export class SimpleTexture extends TextureBase {
        protected _gfxTexture: GFXTexture | null;
        private _mipmapLevel;
        get mipmapLevel(): number;
        /**
         * 获取此贴图底层的 GFX 贴图对象。
         */
        getGFXTexture(): GFXTexture | null;
        destroy(): boolean;
        /**
         * 更新 0 级 Mipmap。
         */
        updateImage(): void;
        /**
         * 更新指定层级范围内的 Mipmap。当 Mipmap 数据发生了改变时应调用此方法提交更改。
         * 若指定的层级范围超出了实际已有的层级范围，只有覆盖的那些层级范围会被更新。
         * @param firstLevel 起始层级。
         * @param count 层级数量。
         */
        updateMipmaps(firstLevel?: number, count?: number): void;
        /**
         * 上传图像数据到指定层级的 Mipmap 中。
         * 图像的尺寸影响 Mipmap 的更新范围：
         * - 当图像是 `ArrayBuffer` 时，图像的尺寸必须和 Mipmap 的尺寸一致；否则，
         * - 若图像的尺寸与 Mipmap 的尺寸相同，上传后整个 Mipmap 的数据将与图像数据一致；
         * - 若图像的尺寸小于指定层级 Mipmap 的尺寸（不管是长或宽），则从贴图左上角开始，图像尺寸范围内的 Mipmap 会被更新；
         * - 若图像的尺寸超出了指定层级 Mipmap 的尺寸（不管是长或宽），都将引起错误。
         * @param source 图像数据源。
         * @param level Mipmap 层级。
         * @param arrayIndex 数组索引。
         */
        uploadData(source: HTMLCanvasElement | HTMLImageElement | ArrayBufferView, level?: number, arrayIndex?: number): void;
        protected _assignImage(image: ImageAsset, level: number, arrayIndex?: number): void;
        protected _checkTextureLoaded(): void;
        protected _textureReady(): void;
        /**
         * Set mipmap level of this texture.
         * The value is passes as presumed info to `this._getGfxTextureCreateInfo()`.
         * @param value The mipmap level.
         */
        protected _setMipmapLevel(value: number): void;
        /**
         * @en This method is overrided by derived classes to provide GFX texture info.
         * @zh 这个方法被派生类重写以提供GFX纹理信息。
         * @param presumed The presumed GFX texture info.
         */
        protected _getGfxTextureCreateInfo(presumed: PresumedGFXTextureInfo): IGFXTextureInfo | null;
        protected _tryReset(): void;
        protected _createTexture(device: GFXDevice): void;
        protected _tryDestroyTexture(): void;
    }
}
declare module "cocos/core/assets/texture-2d" {
    import { GFXTextureType } from "cocos/core/gfx/define";
    import { PixelFormat } from "cocos/core/assets/asset-enum";
    import { ImageAsset } from "cocos/core/assets/image-asset";
    import { PresumedGFXTextureInfo, SimpleTexture } from "cocos/core/assets/simple-texture";
    /**
     * 贴图创建选项。
     */
    export interface ITexture2DCreateInfo {
        /**
         * 像素宽度。
         */
        width: number;
        /**
         * 像素高度。
         */
        height: number;
        /**
         * 像素格式。
         * @default PixelFormat.RGBA8888
         */
        format?: PixelFormat;
        /**
         * mipmap 层级。
         * @default 1
         */
        mipmapLevel?: number;
    }
    /**
     * 二维贴图资源。
     * 二维贴图资源的每个 Mipmap 层级都为一张图像资源。
     */
    export class Texture2D extends SimpleTexture {
        /**
         * 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
         * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
         */
        get mipmaps(): ImageAsset[];
        set mipmaps(value: ImageAsset[]);
        /**
         * 0 级 Mipmap。
         * 注意，`this.image = i` 等价于 `this.mipmaps = [i]`，
         * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
         */
        get image(): ImageAsset | null;
        set image(value: ImageAsset | null);
        _mipmaps: ImageAsset[];
        initialize(): void;
        onLoaded(): void;
        /**
         * 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 `this.uploadData` 来上传贴图数据。
         * @param info 贴图重置选项。
         */
        reset(info: ITexture2DCreateInfo): void;
        /**
         * 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级的贴图。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 `this.uploadData` 来上传贴图数据。
         * @param width 像素宽度。
         * @param height 像素高度。
         * @param format 像素格式。
         * @param mipmapLevel mipmap 层级。
         * @deprecated 将在 V1.0.0 移除，请转用 `this.reset()`。
         */
        create(width: number, height: number, format?: PixelFormat, mipmapLevel?: number): void;
        /**
         * 返回此贴图的字符串表示。
         */
        toString(): string;
        updateMipmaps(firstLevel?: number, count?: number): void;
        /**
         * 若此贴图 0 级 Mipmap 的图像资源的实际源存在并为 HTML 元素则返回它，否则返回 `null`。
         * @returns HTML 元素或 `null`。
         * @deprecated 请转用 `this.image.data`。
         */
        getHtmlElementObj(): HTMLCanvasElement | HTMLImageElement | null;
        /**
         * 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
         */
        destroy(): boolean;
        /**
         * 返回此贴图的描述。
         * @returns 此贴图的描述。
         */
        description(): string;
        /**
         * 释放占用的 GPU 资源。
         * @deprecated 请转用 `this.destroy()`。
         */
        releaseTexture(): void;
        _serialize(exporting?: any): any;
        _deserialize(serializedData: any, handle: any): void;
        protected _getGfxTextureCreateInfo(presumed: PresumedGFXTextureInfo): {
            type: GFXTextureType;
            width: number;
            height: number;
        } & Pick<import("index").IGFXTextureInfo, "usage" | "flags" | "format" | "levelCount">;
        protected _checkTextureLoaded(): void;
    }
    export interface ITexture2DSerializeData {
        base: string;
        mipmaps: string[];
    }
}
declare module "cocos/core/assets/texture-cube" {
    import { ImageAsset } from "cocos/core/assets/image-asset";
    import { PresumedGFXTextureInfo, SimpleTexture } from "cocos/core/assets/simple-texture";
    import { ITexture2DCreateInfo, Texture2D } from "cocos/core/assets/texture-2d";
    import { IGFXTextureInfo } from "cocos/core/gfx/index";
    export type ITextureCubeCreateInfo = ITexture2DCreateInfo;
    /**
     * 立方体贴图的 Mipmap。
     */
    interface ITextureCubeMipmap {
        front: ImageAsset;
        back: ImageAsset;
        left: ImageAsset;
        right: ImageAsset;
        top: ImageAsset;
        bottom: ImageAsset;
    }
    /**
     * 立方体每个面的约定索引。
     */
    enum FaceIndex {
        right = 0,
        left = 1,
        top = 2,
        bottom = 3,
        front = 4,
        back = 5
    }
    /**
     * 立方体贴图资源。
     * 立方体贴图资源的每个 Mipmap 层级都为 6 张图像资源，分别代表了立方体贴图的 6 个面。
     */
    export class TextureCube extends SimpleTexture {
        static FaceIndex: typeof FaceIndex;
        /**
         * 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
         * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
         */
        get mipmaps(): ITextureCubeMipmap[];
        set mipmaps(value: ITextureCubeMipmap[]);
        /**
         * 0 级 Mipmap。<br>
         * 注意，`this.image = i` 等价于 `this.mipmaps = [i]`，
         * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
         */
        get image(): ITextureCubeMipmap | null;
        set image(value: ITextureCubeMipmap | null);
        /**
         * 通过二维贴图指定每个 Mipmap 的每个面创建立方体贴图。
         * @param textures 数组长度必须是6的倍数。
         * 每 6 个二维贴图依次构成立方体贴图的 Mipmap。6 个面应该按 `FaceIndex` 规定顺序排列。
         * @param out 出口立方体贴图，若未定义则将创建为新的立方体贴图。
         * @returns `out`
         * @example
         * ```ts
         * const textures = new Array<Texture2D>(6);
         * textures[TextureCube.FaceIndex.front] = frontImage;
         * textures[TextureCube.FaceIndex.back] = backImage;
         * textures[TextureCube.FaceIndex.left] = leftImage;
         * textures[TextureCube.FaceIndex.right] = rightImage;
         * textures[TextureCube.FaceIndex.top] = topImage;
         * textures[TextureCube.FaceIndex.bottom] = bottomImage;
         * const textureCube = TextureCube.fromTexture2DArray(textures);
         * ```
         */
        static fromTexture2DArray(textures: Texture2D[], out?: TextureCube): TextureCube;
        _mipmaps: ITextureCubeMipmap[];
        onLoaded(): void;
        /**
         * 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
         * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 `this.uploadData` 来上传贴图数据。
         * @param info 贴图重置选项。
         */
        reset(info: ITextureCubeCreateInfo): void;
        updateMipmaps(firstLevel?: number, count?: number): void;
        /**
         * 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
         */
        destroy(): boolean;
        /**
         * 释放占用的 GPU 资源。
         * @deprecated 请转用 `this.destroy()`。
         */
        releaseTexture(): void;
        _serialize(exporting?: any): {
            base: any;
            mipmaps: {
                front: string;
                back: string;
                left: string;
                right: string;
                top: string;
                bottom: string;
            }[];
        };
        _deserialize(serializedData: ITextureCubeSerializeData, handle: any): void;
        protected _getGfxTextureCreateInfo(presumed: PresumedGFXTextureInfo): IGFXTextureInfo;
    }
    interface ITextureCubeSerializeData {
        base: string;
        mipmaps: {
            front: string;
            back: string;
            left: string;
            right: string;
            top: string;
            bottom: string;
        }[];
    }
}
declare module "cocos/core/3d/builtin/effects" {
    const _default_1: ({
        name: string;
        _uuid: string;
        techniques: {
            passes: {
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendSrcAlpha: number;
                        blendDstAlpha: number;
                    }[];
                };
                rasterizerState: {
                    cullMode: number;
                };
                program: string;
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
            };
            defines: never[];
            blocks: never[];
            samplers: never[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            name: string;
            passes: {
                rasterizerState: {
                    cullMode: number;
                };
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendSrcAlpha: number;
                        blendDstAlpha: number;
                    }[];
                };
                program: string;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                };
                properties: {
                    mainTexture: {
                        value: string;
                        type: number;
                    };
                    mainTiling_Offset: {
                        value: number[];
                        type: number;
                    };
                    tintColor: {
                        value: number[];
                        type: number;
                    };
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range: number[];
            } | {
                name: string;
                type: string;
                range?: undefined;
            })[];
            blocks: {
                name: string;
                defines: string[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            name: string;
            passes: {
                rasterizerState: {
                    cullMode: number;
                };
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendSrcAlpha: number;
                        blendDstAlpha: number;
                    }[];
                };
                program: string;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                };
                properties: {
                    mainTexture: {
                        value: string;
                        type: number;
                    };
                    mainTiling_Offset: {
                        value: number[];
                        type: number;
                    };
                    frameTile_velLenScale: {
                        value: number[];
                        type: number;
                    };
                    tintColor: {
                        value: number[];
                        type: number;
                    };
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range: number[];
            } | {
                name: string;
                type: string;
                range?: undefined;
            })[];
            blocks: {
                name: string;
                defines: never[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            passes: {
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendDstAlpha: number;
                    }[];
                };
                rasterizerState: {
                    cullMode: number;
                };
                program: string;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: string[];
                    }[];
                    samplers: {
                        name: string;
                        defines: string[];
                    }[];
                };
            };
            defines: {
                name: string;
                type: string;
            }[];
            blocks: never[];
            samplers: never[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            name: string;
            passes: ({
                program: string;
                properties: {
                    tilingOffset: {
                        value: number[];
                        type: number;
                    };
                    mainColor: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    albedoScale: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    alphaThreshold: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    occlusion: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    roughness: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    metallic: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    normalStrenth: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    emissive: {
                        value: number[];
                        type: number;
                    };
                    emissiveScale: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    mainTexture: {
                        value: string;
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    normalMap: {
                        value: string;
                        type: number;
                    };
                    pbrMap: {
                        value: string;
                        type: number;
                    };
                    metallicRoughnessMap: {
                        value: string;
                        type: number;
                    };
                    occlusionMap: {
                        value: string;
                        type: number;
                    };
                    emissiveMap: {
                        value: string;
                        type: number;
                    };
                    albedo: {
                        type: number;
                        value: number[];
                    };
                    albedoScaleAndCutoff: {
                        type: number;
                        value: number[];
                    };
                    pbrParams: {
                        type: number;
                        value: number[];
                    };
                    emissiveScaleParam: {
                        type: number;
                        value: number[];
                    };
                    albedoMap: {
                        type: number;
                        value: string;
                    };
                };
                phase?: undefined;
                propertyIndex?: undefined;
                embeddedMacros?: undefined;
                blendState?: undefined;
                depthStencilState?: undefined;
                rasterizerState?: undefined;
            } | {
                phase: string;
                propertyIndex: number;
                embeddedMacros: {
                    CC_FORWARD_ADD: boolean;
                };
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendSrcAlpha: number;
                        blendDstAlpha: number;
                    }[];
                };
                program: string;
                depthStencilState: {
                    depthFunc: number;
                    depthTest: boolean;
                    depthWrite: boolean;
                };
                properties: {
                    tilingOffset: {
                        value: number[];
                        type: number;
                    };
                    mainColor: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    albedoScale: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    alphaThreshold: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    occlusion: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    roughness: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    metallic: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    normalStrenth: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    emissive: {
                        value: number[];
                        type: number;
                    };
                    emissiveScale: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    mainTexture: {
                        value: string;
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    normalMap: {
                        value: string;
                        type: number;
                    };
                    pbrMap: {
                        value: string;
                        type: number;
                    };
                    metallicRoughnessMap: {
                        value: string;
                        type: number;
                    };
                    occlusionMap: {
                        value: string;
                        type: number;
                    };
                    emissiveMap: {
                        value: string;
                        type: number;
                    };
                    albedo: {
                        type: number;
                        value: number[];
                    };
                    albedoScaleAndCutoff: {
                        type: number;
                        value: number[];
                    };
                    pbrParams: {
                        type: number;
                        value: number[];
                    };
                    emissiveScaleParam: {
                        type: number;
                        value: number[];
                    };
                    albedoMap: {
                        type: number;
                        value: string;
                    };
                };
                rasterizerState?: undefined;
            } | {
                phase: string;
                propertyIndex: number;
                rasterizerState: {
                    cullMode: number;
                };
                program: string;
                properties?: undefined;
                embeddedMacros?: undefined;
                blendState?: undefined;
                depthStencilState?: undefined;
            })[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: {
                        name: string;
                        defines: string[];
                    }[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: string[];
                    }[];
                    samplers: {
                        name: string;
                        defines: string[];
                    }[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range?: undefined;
                options?: undefined;
            } | {
                name: string;
                type: string;
                range: number[];
                options?: undefined;
            } | {
                name: string;
                type: string;
                options: string[];
                range?: undefined;
            })[];
            blocks: {
                name: string;
                defines: never[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: ({
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                location: number;
                isInstanced?: undefined;
            } | {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                isInstanced: boolean;
                location: number;
            })[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            name: string;
            passes: {
                program: string;
                properties: {
                    UVScale: {
                        value: number[];
                        type: number;
                    };
                    lightMapUVParam: {
                        value: number[];
                        type: number;
                    };
                    weightMap: {
                        value: string;
                        type: number;
                    };
                    detailMap0: {
                        value: string;
                        type: number;
                    };
                    detailMap1: {
                        value: string;
                        type: number;
                    };
                    detailMap2: {
                        value: string;
                        type: number;
                    };
                    detailMap3: {
                        value: string;
                        type: number;
                    };
                    lightMap: {
                        value: string;
                        type: number;
                    };
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range: number[];
            } | {
                name: string;
                type: string;
                range?: undefined;
            })[];
            blocks: {
                name: string;
                defines: never[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            name: string;
            passes: {
                program: string;
                properties: {
                    mainTexture: {
                        value: string;
                        type: number;
                    };
                    tilingOffset: {
                        value: number[];
                        type: number;
                    };
                    mainColor: {
                        value: number[];
                        type: number;
                    };
                    colorScale: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    alphaThreshold: {
                        value: number[];
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    color: {
                        type: number;
                        handleInfo: (string | number)[];
                    };
                    colorScaleAndCutoff: {
                        type: number;
                        value: number[];
                    };
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: string[];
                    }[];
                    samplers: {
                        name: string;
                        defines: string[];
                    }[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range?: undefined;
                options?: undefined;
            } | {
                name: string;
                type: string;
                range: number[];
                options?: undefined;
            } | {
                name: string;
                type: string;
                options: string[];
                range?: undefined;
            })[];
            blocks: {
                name: string;
                defines: string[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: ({
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                location: number;
                isInstanced?: undefined;
            } | {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                isInstanced: boolean;
                location: number;
            })[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            passes: {
                phase: string;
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendDstAlpha: number;
                    }[];
                };
                program: string;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                    stencilTestFront: boolean;
                    stencilFuncFront: number;
                    stencilPassOpFront: number;
                    stencilRefBack: number;
                    stencilRefFront: number;
                    stencilReadMaskBack: number;
                    stencilReadMaskFront: number;
                    stencilWriteMaskBack: number;
                    stencilWriteMaskFront: number;
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: {
                        name: string;
                        defines: string[];
                    }[];
                    samplers: {
                        name: string;
                        defines: string[];
                    }[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range?: undefined;
            } | {
                name: string;
                type: string;
                range: number[];
            })[];
            blocks: never[];
            samplers: never[];
            attributes: ({
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                location: number;
                isInstanced?: undefined;
            } | {
                name: string;
                type: number;
                count: number;
                defines: string[];
                stageFlags: number;
                format: number;
                isInstanced: boolean;
                location: number;
            })[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            passes: {
                rasterizerState: {
                    cullMode: number;
                };
                program: string;
                priority: number;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: {
                        name: string;
                        defines: never[];
                    }[];
                };
                locals: {
                    blocks: never[];
                    samplers: never[];
                };
            };
            defines: ({
                name: string;
                type: string;
                range: number[];
            } | {
                name: string;
                type: string;
                range?: undefined;
            })[];
            blocks: never[];
            samplers: never[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    } | {
        name: string;
        _uuid: string;
        techniques: {
            passes: {
                blendState: {
                    targets: {
                        blend: boolean;
                        blendSrc: number;
                        blendDst: number;
                        blendDstAlpha: number;
                    }[];
                };
                rasterizerState: {
                    cullMode: number;
                };
                program: string;
                depthStencilState: {
                    depthTest: boolean;
                    depthWrite: boolean;
                };
            }[];
        }[];
        shaders: {
            name: string;
            hash: number;
            glsl3: {
                vert: string;
                frag: string;
            };
            glsl1: {
                vert: string;
                frag: string;
            };
            glsl4: {
                vert: string;
                frag: string;
            };
            builtins: {
                globals: {
                    blocks: {
                        name: string;
                        defines: never[];
                    }[];
                    samplers: never[];
                };
                locals: {
                    blocks: never[];
                    samplers: never[];
                };
            };
            defines: {
                name: string;
                type: string;
            }[];
            blocks: {
                name: string;
                defines: never[];
                binding: number;
                stageFlags: number;
                members: {
                    name: string;
                    type: number;
                    count: number;
                }[];
            }[];
            samplers: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                binding: number;
            }[];
            attributes: {
                name: string;
                type: number;
                count: number;
                defines: never[];
                stageFlags: number;
                format: number;
                location: number;
            }[];
        }[];
    })[];
    export default _default_1;
}
declare module "cocos/core/3d/builtin/init" {
    import { Asset } from "cocos/core/assets/asset";
    import { GFXDevice } from "cocos/core/gfx/device";
    class BuiltinResMgr {
        protected _device: GFXDevice | null;
        protected _resources: Record<string, Asset>;
        initBuiltinRes(device: GFXDevice): void;
        get<T extends Asset>(uuid: string): T;
    }
    const builtinResMgr: BuiltinResMgr;
    export { builtinResMgr };
}
declare module "cocos/core/3d/builtin/index" {
    export * from "cocos/core/3d/builtin/init";
    export { default as effects } from "cocos/core/3d/builtin/effects";
}
declare module "cocos/core/renderer/scene/camera" {
    import { frustum, ray } from "cocos/core/geometry/index";
    import { GFXClearFlag, GFXColor } from "cocos/core/gfx/define";
    import { Mat4, Rect, Vec3 } from "cocos/core/math/index";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { Node } from "cocos/core/scene-graph/index";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { GFXDevice } from "cocos/core/gfx/index";
    import { RenderWindow } from "cocos/core/pipeline/index";
    export enum CameraFOVAxis {
        VERTICAL = 0,
        HORIZONTAL = 1
    }
    export enum CameraProjection {
        ORTHO = 0,
        PERSPECTIVE = 1
    }
    export enum CameraAperture {
        F1_8 = 0,
        F2_0 = 1,
        F2_2 = 2,
        F2_5 = 3,
        F2_8 = 4,
        F3_2 = 5,
        F3_5 = 6,
        F4_0 = 7,
        F4_5 = 8,
        F5_0 = 9,
        F5_6 = 10,
        F6_3 = 11,
        F7_1 = 12,
        F8_0 = 13,
        F9_0 = 14,
        F10_0 = 15,
        F11_0 = 16,
        F13_0 = 17,
        F14_0 = 18,
        F16_0 = 19,
        F18_0 = 20,
        F20_0 = 21,
        F22_0 = 22
    }
    export enum CameraISO {
        ISO100 = 0,
        ISO200 = 1,
        ISO400 = 2,
        ISO800 = 3
    }
    export enum CameraShutter {
        D1 = 0,
        D2 = 1,
        D4 = 2,
        D8 = 3,
        D15 = 4,
        D30 = 5,
        D60 = 6,
        D125 = 7,
        D250 = 8,
        D500 = 9,
        D1000 = 10,
        D2000 = 11,
        D4000 = 12
    }
    export interface ICameraInfo {
        name: string;
        node: Node;
        projection: number;
        targetDisplay?: number;
        window?: RenderWindow | null;
        priority: number;
        pipeline?: string;
        flows?: string[];
    }
    export const SKYBOX_FLAG: number;
    export class Camera {
        isWindowSize: boolean;
        screenScale: number;
        clearStencil: number;
        clearDepth: number;
        clearFlag: GFXClearFlag;
        private _device;
        private _scene;
        private _node;
        private _name;
        private _enabled;
        private _proj;
        private _width;
        private _height;
        private _aspect;
        private _orthoHeight;
        private _fovAxis;
        private _fov;
        private _nearClip;
        private _farClip;
        private _clearColor;
        private _viewport;
        private _isProjDirty;
        private _matView;
        private _matViewInv;
        private _matProj;
        private _matProjInv;
        private _matViewProj;
        private _matViewProjInv;
        private _frustum;
        private _forward;
        private _position;
        private _view;
        private _visibility;
        private _priority;
        private _aperture;
        private _apertureValue;
        private _shutter;
        private _shutterValue;
        private _iso;
        private _isoValue;
        private _ec;
        private _exposure;
        constructor(device: GFXDevice);
        initialize(info: ICameraInfo): void;
        destroy(): void;
        attachToScene(scene: RenderScene): void;
        detachFromScene(): void;
        resize(width: number, height: number): void;
        setFixedSize(width: number, height: number): void;
        update(forceUpdate?: boolean): void;
        getSplitFrustum(out: frustum, nearClip: number, farClip: number): void;
        set node(val: Node);
        get node(): Node;
        set enabled(val: boolean);
        get enabled(): boolean;
        get view(): RenderView;
        set orthoHeight(val: number);
        get orthoHeight(): number;
        set projectionType(val: CameraProjection);
        get projectionType(): CameraProjection;
        set fovAxis(axis: CameraFOVAxis);
        get fovAxis(): CameraFOVAxis;
        set fov(fov: number);
        get fov(): number;
        set nearClip(nearClip: number);
        get nearClip(): number;
        set farClip(farClip: number);
        get farClip(): number;
        set clearColor(val: GFXColor);
        get clearColor(): GFXColor;
        get viewport(): Rect;
        set viewport(val: Rect);
        get scene(): RenderScene | null;
        get name(): string | null;
        get width(): number;
        get height(): number;
        get aspect(): number;
        set matView(val: Mat4);
        get matView(): Mat4;
        set matViewInv(val: Mat4 | null);
        get matViewInv(): Mat4 | null;
        set matProj(val: Mat4);
        get matProj(): Mat4;
        set matProjInv(val: Mat4);
        get matProjInv(): Mat4;
        set matViewProj(val: Mat4);
        get matViewProj(): Mat4;
        set matViewProjInv(val: Mat4);
        get matViewProjInv(): Mat4;
        set frustum(val: frustum);
        get frustum(): frustum;
        set forward(val: Vec3);
        get forward(): Vec3;
        set position(val: Vec3);
        get position(): Vec3;
        set visibility(vis: number);
        get visibility(): number;
        get priority(): number;
        set priority(val: number);
        set aperture(val: CameraAperture);
        get aperture(): CameraAperture;
        get apertureValue(): number;
        set shutter(val: CameraShutter);
        get shutter(): CameraShutter;
        get shutterValue(): number;
        set iso(val: CameraISO);
        get iso(): CameraISO;
        get isoValue(): number;
        set ec(val: number);
        get ec(): number;
        get exposure(): number;
        set flows(val: string[]);
        changeTargetWindow(window?: RenderWindow | null): void;
        /**
         * transform a screen position to a world space ray
         */
        screenPointToRay(out: ray, x: number, y: number): ray;
        /**
         * transform a screen position to world space
         */
        screenToWorld(out: Vec3, screenPos: Vec3): Vec3;
        /**
         * transform a world space position to screen space
         */
        worldToScreen(out: Vec3, worldPos: Vec3): Vec3;
        private updateExposure;
    }
}
declare module "cocos/core/data/class-decorator" {
    export { ccclass } from "cocos/core/data/decorators/ccclass";
    export { property } from "cocos/core/data/decorators/property";
    export { requireComponent, executionOrder, disallowMultiple } from "cocos/core/data/decorators/component";
    export { executeInEditMode, menu, playOnFocus, inspector, icon, help } from "cocos/core/data/decorators/editable";
    export { type, integer, float, boolean, string } from "cocos/core/data/decorators/type";
}
declare module "cocos/core/components/missing-script" {
    import { Component } from "cocos/core/components/component";
    /**
     * @en
     * A temp fallback to contain the original serialized data which can not be loaded.
     * @zh
     * 包含无法加载的原始序列化数据的临时回退。
     */
    class MissingClass {
        _$erialized: null;
    }
    /**
     * @en
     * A temp fallback to contain the original component which can not be loaded.
     * @zh
     * 包含无法加载的原始组件的临时回退。
     */
    export default class MissingScript extends Component {
        static safeFindClass(id: string, data: any): any;
        static getMissingWrapper(id: any, data: any): typeof MissingClass;
        compiled: boolean;
        _$erialized: null;
        constructor();
        onLoad(): void;
    }
}
declare module "cocos/core/data/deserialize" {
    import * as js from "cocos/core/utils/js";
    /**
     * @en Contains information collected during deserialization
     * @zh 包含反序列化时的一些信息。
     * @class Details
     *
     */
    export class Details {
        static pool: js.Pool<{}>;
        assignAssetsBy: Function;
        uuidList: string[];
        uuidObjList: object[];
        uuidPropList: string[];
        private _stillUseUrl;
        constructor();
        /**
         * @zh
         * 重置。
         * @method reset
         */
        reset(): void;
        /**
         * @method push
         * @param {Object} obj
         * @param {String} propName
         * @param {String} uuid
         */
        push(obj: Object, propName: string, uuid: string, _stillUseUrl: any): void;
    }
    /**
     * @module cc
     */
    /**
     * @en Deserialize json to `Asset`.
     * @zh 将 JSON 反序列化为对象实例。
     *
     * 当指定了 target 选项时，如果 target 引用的其它 asset 的 uuid 不变，则不会改变 target 对 asset 的引用，
     * 也不会将 uuid 保存到 result 对象中。
     *
     * @method deserialize
     * @param {String|Object} data - the serialized `Asset` json string or json object.
     * @param {Details} [details] - additional loading result
     * @param {Object} [options]
     * @return {object} the main data(asset)
     */
    export function deserialize(data: any, details: any, options: any): any;
    /**
     * @module cc
     */
    /**
     * @en Deserialize json to `Asset`.
     * @zh 将 JSON 反序列化为对象实例。
     *
     * 当指定了 target 选项时，如果 target 引用的其它 asset 的 uuid 不变，则不会改变 target 对 asset 的引用，
     * 也不会将 uuid 保存到 result 对象中。
     *
     * @method deserialize
     * @param {String|Object} data - the serialized `Asset` json string or json object.
     * @param {Details} [details] - additional loading result
     * @param {Object} [options]
     * @return {object} the main data(asset)
     */
    export namespace deserialize {
        var Details: typeof import("cocos/core/data/deserialize").Details;
        var reportMissingClass: (id: any) => void;
    }
}
declare module "cocos/core/scene-graph/layers" {
    /**
     * @zh 节点层管理器，层数据是以掩码数据方式存储在 [[Node.layer]] 中，用于射线检测、物理碰撞和用户自定义脚本逻辑。
     * 每个节点可属于一个或多个层，可通过 “包含式” 或 “排除式” 两种检测器进行层检测。
     * @en Node's layer manager, it's stored as bit mask data in [[Node.layer]].
     * Layer information is widely used in raycast, physics and user logic.
     * Every node can be assigned to multiple layers with different bit masks, you can setup layer with inclusive or exclusive operation.
     */
    export class Layers {
        /**
         * @en All layers in an Enum
         * @zh 以 Enum 形式存在的所有层列表
         */
        static Enum: {
            NONE: number;
            IGNORE_RAYCAST: number;
            GIZMOS: number;
            EDITOR: number;
            UI_3D: number;
            SCENE_GIZMO: number;
            UI_2D: number;
            PROFILER: number;
            DEFAULT: number;
            ALL: number;
        };
        /**
         * @en All layers in [[BitMask]] type
         * @zh 包含所有层的 [[BitMask]]
         */
        static BitMask: {
            NONE: number;
            IGNORE_RAYCAST: number;
            GIZMOS: number;
            EDITOR: number;
            UI_3D: number;
            SCENE_GIZMO: number;
            UI_2D: number;
            PROFILER: number;
            DEFAULT: number;
            ALL: number;
        };
        /**
         * @en
         * Make a layer mask accepting nothing but the listed layers
         * @zh
         * 创建一个包含式层检测器，只接受列表中的层
         * @param includes All accepted layers
         * @return A filter which can detect all accepted layers
         */
        static makeMaskInclude(includes: number[]): number;
        /**
         * @en
         * Make a layer mask accepting everything but the listed layers
         * @zh
         * 创建一个排除式层检测器，只拒绝列表中的层
         * @param excludes All excluded layers
         * @return A filter which can detect for excluded layers
         */
        static makeMaskExclude(excludes: number[]): number;
        /**
         * @zh 添加一个新层，用户可编辑 0 - 19 位为用户自定义层
         * @en Add a new layer, user can use layers from bit position 0 to 19, other bits are reserved.
         * @param name Layer's name
         * @param bitNum Layer's bit position
         */
        static addLayer(name: string, bitNum: number): void;
        /**
         * @en Remove a layer, user can remove layers from bit position 0 to 19, other bits are reserved.
         * @zh 移除一个层，用户可编辑 0 - 19 位为用户自定义层
         * @param bitNum Layer's bit position
         */
        static deleteLayer(bitNum: number): void;
    }
}
declare module "cocos/core/scene-graph/node-enum" {
    /**
     * @category scene-graph
     */
    /**
     * @en Node's coordinate space
     * @zh 节点的坐标空间
     */
    export enum NodeSpace {
        LOCAL = 0,
        WORLD = 1
    }
    /**
     * @en Bit masks for node's transformation
     * @zh 节点的空间变换位标记
     */
    export enum TransformBit {
        /**
         * @zh
         * 无改变
         */
        NONE = 0,
        /**
         * @zh
         * 节点位置改变
         */
        POSITION = 1,
        /**
         * @zh
         * 节点旋转
         */
        ROTATION = 2,
        /**
         * @zh
         * 节点缩放
         */
        SCALE = 4,
        /**
         * @zh
         * 节点旋转及缩放
         */
        RS = 6,
        /**
         * @zh
         * 节点平移，旋转及缩放
         */
        TRS = 7,
        TRS_MASK = -8
    }
}
declare module "cocos/core/renderer/core/pass-utils" {
    /**
     * @category material
     */
    import { GFXType } from "cocos/core/gfx/define";
    import { Color, Mat3, Mat4, Vec2, Vec3, Vec4, Quat } from "cocos/core/math/index";
    export enum PropertyType {
        UBO = 0,
        SAMPLER = 1
    }
    export const genHandle: (pt: PropertyType, set: number, binding: number, type: GFXType, offset?: number) => number;
    export const getPropertyTypeFromHandle: (handle: number) => number;
    export const getTypeFromHandle: (handle: number) => number;
    export const getSetIndexFromHandle: (handle: number) => number;
    export const getBindingFromHandle: (handle: number) => number;
    export const getOffsetFromHandle: (handle: number) => number;
    export const customizeType: (handle: number, type: GFXType) => number;
    export type MaterialProperty = number | Vec2 | Vec3 | Vec4 | Color | Mat3 | Mat4 | Quat;
    export const type2reader: {
        0: (a: Float32Array, v: any, idx?: number) => void;
        5: (a: Float32Array, v: any, idx?: number) => number;
        6: (a: Float32Array, v: any, idx?: number) => any;
        7: (a: Float32Array, v: any, idx?: number) => any;
        8: (a: Float32Array, v: any, idx?: number) => any;
        13: (a: Float32Array, v: any, idx?: number) => number;
        14: (a: Float32Array, v: any, idx?: number) => any;
        15: (a: Float32Array, v: any, idx?: number) => any;
        16: (a: Float32Array, v: any, idx?: number) => any;
        21: (a: Float32Array, v: any, idx?: number) => any;
        25: (a: Float32Array, v: any, idx?: number) => any;
    };
    export const type2writer: {
        0: (a: Float32Array, v: any, idx?: number) => void;
        5: (a: Float32Array, v: any, idx?: number) => any;
        6: (a: Float32Array, v: any, idx?: number) => Float32Array;
        7: (a: Float32Array, v: any, idx?: number) => Float32Array;
        8: (a: Float32Array, v: any, idx?: number) => Float32Array;
        13: (a: Float32Array, v: any, idx?: number) => any;
        14: (a: Float32Array, v: any, idx?: number) => Float32Array;
        15: (a: Float32Array, v: any, idx?: number) => Float32Array;
        16: (a: Float32Array, v: any, idx?: number) => Float32Array;
        21: (a: Float32Array, v: any, idx?: number) => Float32Array;
        25: (a: Float32Array, v: any, idx?: number) => Float32Array;
    };
    export function getDefaultFromType(type: GFXType): readonly number[] | "default-texture" | "default-cube-texture";
    export type MacroRecord = Record<string, number | boolean | string>;
    export function overrideMacros(target: MacroRecord, source: MacroRecord): boolean;
}
declare module "cocos/core/renderer/core/native-pools" {
    /**
     * @hidden
     */
    export class NativeBufferPool {
        private _arrayBuffers;
        private _chunkSize;
        constructor(dataType: number, entryBits: number, stride: number);
        allocateNewChunk(): ArrayBuffer;
    }
    export class NativeObjectPool<T> {
        constructor(dataType: number, array: T[]);
    }
}
declare module "cocos/core/renderer/core/memory-pools" {
    import { GFXRasterizerState, GFXDepthStencilState, GFXBlendState, IGFXDescriptorSetInfo, GFXDevice, GFXDescriptorSet, GFXShaderInfo, GFXShader, IGFXInputAssemblerInfo, GFXInputAssembler, IGFXPipelineLayoutInfo, GFXPipelineLayout, GFXPrimitiveMode, GFXDynamicStateFlags } from "cocos/core/gfx/index";
    import { RenderPassStage } from "cocos/core/pipeline/define";
    import { BatchingSchemes } from "cocos/core/renderer/core/pass";
    interface ITypedArrayConstructor<T> {
        new (buffer: ArrayBufferLike, byteOffset: number, length?: number): T;
        readonly BYTES_PER_ELEMENT: number;
    }
    interface IBufferManifest {
        [key: string]: number | string;
        COUNT: number;
    }
    interface IHandle<T extends PoolType> extends Number {
        _: T;
    }
    type GeneralBufferElement = number | IHandle<any>;
    class BufferPool<P extends PoolType, T extends TypedArray, E extends IBufferManifest, H extends {
        [key in E[keyof E]]: GeneralBufferElement;
    }> {
        private _viewCtor;
        private _elementCount;
        private _entryBits;
        private _stride;
        private _entriesPerChunk;
        private _entryMask;
        private _chunkMask;
        private _poolFlag;
        private _arrayBuffers;
        private _freelists;
        private _bufferViews;
        private _nativePool;
        constructor(dataType: P, viewCtor: ITypedArrayConstructor<T>, enumType: E, entryBits?: number);
        alloc(): IHandle<P>;
        /**
         * Get the specified element out from buffer pool.
         *
         * Note the type inference does not work when `element` is not directly
         * an pre-declared enum value: (e.g. when doing arithmetic operations)
         * ```ts
         * SubModelPool.get(handle, SubModelView.SHADER_0 + passIndex); // the return value will have type GeneralBufferElement
         * ```
         *
         * To properly declare the variable type, you have two options:
         * ```ts
         * const hShader = SubModelPool.get(handle, SubModelView.SHADER_0 + passIndex) as ShaderHandle; // option #1
         * const hShader = SubModelPool.get<SubModelView.SHADER_0>(handle, SubModelView.SHADER_0 + passIndex); // option #2
         * ```
         */
        get<V extends E[keyof E]>(handle: IHandle<P>, element: V): H[V];
        set<V extends E[keyof E]>(handle: IHandle<P>, element: V, value: H[V]): void;
        free(handle: IHandle<P>): void;
    }
    class ObjectPool<T, P extends PoolType, A extends any[]> {
        private _ctor;
        private _dtor?;
        private _indexMask;
        private _poolFlag;
        private _array;
        private _freelist;
        private _nativePool;
        constructor(dataType: P, ctor: (args: A, obj?: T) => T, dtor?: (obj: T) => void);
        alloc(...args: A): IHandle<P>;
        get(handle: IHandle<P>): T;
        free(handle: IHandle<P>): void;
    }
    interface IBufferTypeManifest {
        [key: string]: GeneralBufferElement;
    }
    enum PoolType {
        RASTERIZER_STATE = 0,
        DEPTH_STENCIL_STATE = 1,
        BLEND_STATE = 2,
        DESCRIPTOR_SETS = 3,
        SHADER = 4,
        INPUT_ASSEMBLER = 5,
        PIPELINE_LAYOUT = 6,
        PASS = 7,
        SUB_MODEL = 8
    }
    export const NULL_HANDLE: IHandle<any>;
    export type RasterizerStateHandle = IHandle<PoolType.RASTERIZER_STATE>;
    export type DepthStencilStateHandle = IHandle<PoolType.DEPTH_STENCIL_STATE>;
    export type BlendStateHandle = IHandle<PoolType.BLEND_STATE>;
    export type DescriptorSetHandle = IHandle<PoolType.DESCRIPTOR_SETS>;
    export type ShaderHandle = IHandle<PoolType.SHADER>;
    export type InputAssemblerHandle = IHandle<PoolType.INPUT_ASSEMBLER>;
    export type PipelineLayoutHandle = IHandle<PoolType.PIPELINE_LAYOUT>;
    export type PassHandle = IHandle<PoolType.PASS>;
    export type SubModelHandle = IHandle<PoolType.SUB_MODEL>;
    export const RasterizerStatePool: ObjectPool<GFXRasterizerState, PoolType.RASTERIZER_STATE, any[]>;
    export const DepthStencilStatePool: ObjectPool<GFXDepthStencilState, PoolType.DEPTH_STENCIL_STATE, any[]>;
    export const BlendStatePool: ObjectPool<GFXBlendState, PoolType.BLEND_STATE, any[]>;
    export const ShaderPool: ObjectPool<GFXShader, PoolType.SHADER, [GFXDevice, GFXShaderInfo]>;
    export const DSPool: ObjectPool<GFXDescriptorSet, PoolType.DESCRIPTOR_SETS, [GFXDevice, IGFXDescriptorSetInfo]>;
    export const IAPool: ObjectPool<GFXInputAssembler, PoolType.INPUT_ASSEMBLER, [GFXDevice, IGFXInputAssemblerInfo]>;
    export const PipelineLayoutPool: ObjectPool<GFXPipelineLayout, PoolType.PIPELINE_LAYOUT, [GFXDevice, IGFXPipelineLayoutInfo]>;
    export enum PassView {
        PRIORITY = 0,
        STAGE = 1,
        PHASE = 2,
        BATCHING_SCHEME = 3,
        PRIMITIVE = 4,
        DYNAMIC_STATES = 5,
        HASH = 6,
        RASTERIZER_STATE = 7,
        DEPTH_STENCIL_STATE = 8,
        BLEND_STATE = 9,
        DESCRIPTOR_SET = 10,
        PIPELINE_LAYOUT = 11,
        COUNT = 12
    }
    interface IPassViewType extends IBufferTypeManifest {
        [PassView.PRIORITY]: number;
        [PassView.STAGE]: RenderPassStage;
        [PassView.PHASE]: number;
        [PassView.BATCHING_SCHEME]: BatchingSchemes;
        [PassView.PRIMITIVE]: GFXPrimitiveMode;
        [PassView.DYNAMIC_STATES]: GFXDynamicStateFlags;
        [PassView.HASH]: number;
        [PassView.RASTERIZER_STATE]: RasterizerStateHandle;
        [PassView.DEPTH_STENCIL_STATE]: DepthStencilStateHandle;
        [PassView.BLEND_STATE]: BlendStateHandle;
        [PassView.DESCRIPTOR_SET]: DescriptorSetHandle;
        [PassView.PIPELINE_LAYOUT]: PipelineLayoutHandle;
        [PassView.COUNT]: number;
    }
    export const PassPool: BufferPool<PoolType.PASS, Uint32Array, typeof PassView, IPassViewType>;
    export enum SubModelView {
        PRIORITY = 0,
        PASS_COUNT = 1,
        PASS_0 = 2,
        PASS_1 = 3,
        PASS_2 = 4,
        PASS_3 = 5,
        SHADER_0 = 6,
        SHADER_1 = 7,
        SHADER_2 = 8,
        SHADER_3 = 9,
        DESCRIPTOR_SET = 10,
        INPUT_ASSEMBLER = 11,
        COUNT = 12
    }
    interface ISubModelViewType extends IBufferTypeManifest {
        [SubModelView.PRIORITY]: number;
        [SubModelView.PASS_COUNT]: number;
        [SubModelView.PASS_0]: PassHandle;
        [SubModelView.PASS_1]: PassHandle;
        [SubModelView.PASS_2]: PassHandle;
        [SubModelView.PASS_3]: PassHandle;
        [SubModelView.SHADER_0]: ShaderHandle;
        [SubModelView.SHADER_1]: ShaderHandle;
        [SubModelView.SHADER_2]: ShaderHandle;
        [SubModelView.SHADER_3]: ShaderHandle;
        [SubModelView.DESCRIPTOR_SET]: DescriptorSetHandle;
        [SubModelView.INPUT_ASSEMBLER]: InputAssemblerHandle;
        [SubModelView.COUNT]: number;
    }
    export const SubModelPool: BufferPool<PoolType.SUB_MODEL, Uint32Array, typeof SubModelView, ISubModelViewType>;
}
declare module "cocos/core/renderer/core/pass-instance" {
    /**
     * @category material
     */
    import { IPassInfo } from "cocos/core/assets/effect-asset";
    import { MaterialInstance } from "cocos/core/renderer/core/material-instance";
    import { Pass, PassOverrides } from "cocos/core/renderer/core/pass";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    export class PassInstance extends Pass {
        get parent(): Pass;
        private _parent;
        private _owner;
        private _dontNotify;
        constructor(parent: Pass, owner: MaterialInstance);
        overridePipelineStates(original: IPassInfo, overrides: PassOverrides): void;
        tryCompile(defineOverrides?: MacroRecord): boolean | null;
        beginChangeStatesSilently(): void;
        endChangeStatesSilently(): void;
        protected _syncBatchingScheme(): void;
        protected _onStateChange(): void;
    }
}
declare module "cocos/core/renderer/core/material-instance" {
    /**
     * @category material
     */
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    import { Material } from "cocos/core/assets/material";
    import { PassInstance } from "cocos/core/renderer/core/pass-instance";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    import { PassOverrides } from "cocos/core/renderer/core/pass";
    export interface IMaterialInstanceInfo {
        parent: Material;
        owner?: RenderableComponent;
        subModelIdx?: number;
    }
    /**
     * @zh
     * 材质实例，当有材质修改需求时，根据材质资源创建的，可任意定制的实例。
     */
    export class MaterialInstance extends Material {
        get parent(): Material;
        get owner(): RenderableComponent | null;
        protected _passes: PassInstance[];
        private _parent;
        private _owner;
        private _subModelIdx;
        constructor(info: IMaterialInstanceInfo);
        recompileShaders(overrides: MacroRecord, passIdx?: number): void;
        overridePipelineStates(overrides: PassOverrides, passIdx?: number): void;
        destroy(): boolean;
        onPassStateChange(dontNotify: boolean): void;
        protected _createPasses(): PassInstance[];
    }
}
declare module "cocos/core/renderer/utils" {
    export function createIA(device: any, data: any): any;
}
declare module "cocos/core/renderer/config" {
    const _default_2: {
        addStage(name: any): void;
        stageID(name: any): any;
        stageIDs(nameList: any): number;
    };
    export default _default_2;
}
declare module "cocos/core/renderer/core/constants" {
    /**
     * @hidden
     */
    export enum RenderQueue {
        OPAQUE = 0,
        TRANSPARENT = 1,
        OVERLAY = 2
    }
    export enum PassStage {
        DEFAULT = 1,
        FORWARD = 2,
        SHADOWCAST = 4
    }
}
declare module "cocos/core/renderer/core/program-lib" {
    /**
     * @category material
     */
    import { IBlockInfo, IDefineInfo, ISamplerInfo, IShaderInfo } from "cocos/core/assets/effect-asset";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    import { ShaderHandle, PipelineLayoutHandle } from "cocos/core/renderer/core/memory-pools";
    import { GFXDescriptorSetLayout, IGFXDescriptorSetLayoutBinding } from "cocos/core/gfx/descriptor-set-layout";
    interface IDefineRecord extends IDefineInfo {
        _map: (value: any) => number;
        _offset: number;
    }
    interface IBlockInfoRT extends IBlockInfo {
        size: number;
    }
    export interface IProgramInfo extends IShaderInfo {
        blocks: IBlockInfoRT[];
        samplers: ISamplerInfo[];
        defines: IDefineRecord[];
        handleMap: Record<string, number>;
        bindings: IGFXDescriptorSetLayoutBinding[];
        samplerStartBinding: number;
        uber: boolean;
    }
    export interface IPipelineLayoutInfo {
        setLayouts: GFXDescriptorSetLayout[];
        hPipelineLayout: PipelineLayoutHandle;
    }
    /**
     * @zh
     * 维护 shader 资源实例的全局管理器。
     */
    class ProgramLib {
        protected _templates: Record<string, IProgramInfo>;
        protected _pipelineLayouts: Record<string, IPipelineLayoutInfo>;
        protected _cache: Record<string, ShaderHandle>;
        /**
         * @zh
         * 根据 effect 信息注册 shader 模板。
         */
        define(prog: IShaderInfo): void;
        getTemplate(name: string): IProgramInfo;
        getPipelineLayout(name: string): IPipelineLayoutInfo;
        /**
         * @en
         * Does this library has the specified program?
         * @zh
         * 当前是否有已注册的指定名字的 shader？
         * @param name 目标 shader 名
         */
        hasProgram(name: string): boolean;
        /**
         * @zh
         * 根据 shader 名和预处理宏列表获取 shader key。
         * @param name 目标 shader 名
         * @param defines 目标预处理宏列表
         */
        getKey(name: string, defines: MacroRecord): string;
        /**
         * @zh
         * 销毁所有完全满足指定预处理宏特征的 shader 实例。
         * @param defines 用于筛选的预处理宏列表
         */
        destroyShaderByDefines(defines: MacroRecord): void;
        /**
         * @zh
         * 获取指定 shader 的渲染资源实例
         * @param device 渲染设备 [[GFXDevice]]
         * @param name shader 名字
         * @param defines 预处理宏列表
         * @param pipeline 实际渲染命令执行时所属的 [[RenderPipeline]]
         */
        getGFXShader(device: GFXDevice, name: string, defines: MacroRecord, pipeline: RenderPipeline, key?: string): ShaderHandle;
    }
    export const programLib: ProgramLib;
}
declare module "cocos/core/renderer/core/texture-buffer-pool" {
    /**
     * @hidden
     */
    import { GFXFormat } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXTexture } from "cocos/core/gfx/texture";
    export function nearestPOT(num: number): number;
    export interface ITextureBuffer {
        texture: GFXTexture;
        size: number;
        start: number;
        end: number;
    }
    export interface ITextureBufferHandle {
        chunkIdx: number;
        start: number;
        end: number;
        texture: GFXTexture;
    }
    export interface ITextureBufferPoolInfo {
        format: GFXFormat;
        inOrderFree?: boolean;
        alignment?: number;
        roundUpFn?: (size: number, formatSize: number) => number;
    }
    export class TextureBufferPool {
        private _device;
        private _format;
        private _formatSize;
        private _chunks;
        private _chunkCount;
        private _handles;
        private _region0;
        private _region1;
        private _region2;
        private _roundUpFn;
        private _bufferViewCtor;
        private _channels;
        private _alignment;
        constructor(device: GFXDevice);
        initialize(info: ITextureBufferPoolInfo): void;
        destroy(): void;
        alloc(size: number, chunkIdx?: number): ITextureBufferHandle;
        free(handle: ITextureBufferHandle): void;
        createChunk(length: number): number;
        update(handle: ITextureBufferHandle, buffer: ArrayBuffer): void;
        private _findAvailableSpace;
        private _McDonaldAlloc;
    }
}
declare module "cocos/core/data/utils/compact-value-type-array" {
    export enum StorageUnit {
        Uint8 = 0,
        Uint16 = 1,
        Uint32 = 2,
        Int8 = 3,
        Int16 = 4,
        Int32 = 5,
        Float32 = 6,
        Float64 = 7
    }
    export enum ElementType {
        Scalar = 0,
        Vec2 = 1,
        Vec3 = 2,
        Vec4 = 3,
        Quat = 4,
        Mat4 = 5
    }
    export type StorageUnitElementType = number;
    export function combineStorageUnitElementType(unit: StorageUnit, elementType: ElementType): number;
    export function extractStorageUnitElementType(combined: StorageUnitElementType): {
        storageUnit: number;
        elementType: number;
    };
    export class CompactValueTypeArray {
        static StorageUnit: typeof StorageUnit;
        static ElementType: typeof ElementType;
        /**
         * Offset into buffer, in bytes.
         */
        private _byteOffset;
        /**
         * Unit count this CVTA occupies.
         */
        private _unitCount;
        /**
         * Element type this CVTA holds.
         */
        private _unitElement;
        /**
         * Element count this CVTA holds.
         */
        private _length;
        /**
         * Returns the length in bytes that a buffer needs to encode the specified value array in form of CVTA.
         * @param values The value array.
         * @param unit Target element type.
         */
        static lengthFor(values: any[], elementType: ElementType, unit: StorageUnit): number;
        /**
         * Compresses the specified value array in form of CVTA into target buffer.
         * @param values The value array.
         * @param unit Target element type.
         * @param arrayBuffer Target buffer.
         * @param byteOffset Offset into target buffer.
         */
        static compress(values: any[], elementType: ElementType, unit: StorageUnit, arrayBuffer: ArrayBuffer, byteOffset: number, presumedByteOffset: number): CompactValueTypeArray;
        /**
         * Decompresses this CVTA.
         * @param arrayBuffer The buffer this CVTA stored in.
         */
        decompress<T>(arrayBuffer: ArrayBuffer): T[];
    }
    export function isCompactValueTypeArray(value: any): value is CompactValueTypeArray;
}
declare module "cocos/core/renderer/data-pool-manager" {
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { Skeleton } from "cocos/core/assets/index";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { JointAnimationInfo, JointTexturePool } from "cocos/core/renderer/models/skeletal-animation-utils";
    export class DataPoolManager {
        jointTexturePool: JointTexturePool;
        jointAnimationInfo: JointAnimationInfo;
        constructor(device: GFXDevice);
        releaseSkeleton(skeleton: Skeleton): void;
        releaseAnimationClip(clip: AnimationClip): void;
        clear(): void;
    }
}
declare module "cocos/core/utils/binary-search" {
    /**
     * Searches the entire sorted Array for an element and returns the index of the element.
     *
     * @method binarySearch
     * @param {number[]} array
     * @param {number} value
     * @return {number} The index of item in the sorted Array, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of array's length.
     */
    /**
     * Searches the entire sorted Array for an element and returns the index of the element.
     * It accepts iteratee which is invoked for value and each element of array to compute their sort ranking.
     * The iteratee is invoked with one argument: (value).
     *
     * @method binarySearchBy
     * @param {number[]} array
     * @param {number} value
     * @param {function} iteratee - the iteratee invoked per element
     * @return {number} The index of item in the sorted Array, if item is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than item or, if there is no larger element, the bitwise complement of array's length.
     */
    export default function binarySearchEpsilon(array: any, value: any): number;
}
declare module "cocos/core/data/utils/binary-search" {
    export function binarySearchEpsilon(array: number[], value: number): number;
}
declare module "cocos/core/animation/bezier" {
    export type BezierControlPoints = [number, number, number, number];
    export function bezier(C1: number, C2: number, C3: number, C4: number, t: number): number;
    export function bezierByTime(controlPoints: BezierControlPoints, x: number): number;
}
declare module "cocos/core/animation/easing" {
    /**
     * @category animation
     */
    export function constant(): number;
    export function linear(k: number): number;
    export function quadIn(k: number): number;
    export function quadOut(k: number): number;
    export function quadInOut(k: number): number;
    export function cubicIn(k: number): number;
    export function cubicOut(k: number): number;
    export function cubicInOut(k: number): number;
    export function quartIn(k: number): number;
    export function quartOut(k: number): number;
    export function quartInOut(k: number): number;
    export function quintIn(k: number): number;
    export function quintOut(k: number): number;
    export function quintInOut(k: number): number;
    export function sineIn(k: number): number;
    export function sineOut(k: number): number;
    export function sineInOut(k: number): number;
    export function expoIn(k: number): number;
    export function expoOut(k: number): number;
    export function expoInOut(k: number): number;
    export function circIn(k: number): number;
    export function circOut(k: number): number;
    export function circInOut(k: number): number;
    export function elasticIn(k: number): number;
    export function elasticOut(k: number): number;
    export function elasticInOut(k: number): number;
    export function backIn(k: number): number;
    export function backOut(k: number): number;
    export function backInOut(k: number): number;
    export function bounceIn(k: number): number;
    export function bounceOut(k: number): number;
    export function bounceInOut(k: number): number;
    export function smooth(k: number): number;
    export function fade(k: number): number;
    export const quadOutIn: (k: number) => number;
    export const cubicOutIn: (k: number) => number;
    export const quartOutIn: (k: number) => number;
    export const quintOutIn: (k: number) => number;
    export const sineOutIn: (k: number) => number;
    export const expoOutIn: (k: number) => number;
    export const circOutIn: (k: number) => number;
    export const elasticOutIn: (k: number) => number;
    export const backOutIn: (k: number) => number;
    export const bounceOutIn: (k: number) => number;
}
declare module "cocos/core/animation/types" {
    export enum WrapModeMask {
        Default = 0,
        Normal = 1,
        Loop = 2,
        ShouldWrap = 4,
        Clamp = 8,
        PingPong = 22,
        Reverse = 36
    }
    /**
     * 动画使用的循环模式。
     */
    export enum WrapMode {
        /**
         * 向 Animation Component 或者 AnimationClip 查找 wrapMode
         */
        Default = 0,
        /**
         * 动画只播放一遍
         */
        Normal = 1,
        /**
         * 从最后一帧或结束位置开始反向播放，到第一帧或开始位置停止
         */
        Reverse = 36,
        /**
         * 循环播放
         */
        Loop = 2,
        /**
         * 反向循环播放
         */
        LoopReverse = 38,
        /**
         * 从第一帧播放到最后一帧，然后反向播放回第一帧，到第一帧后再正向播放，如此循环
         */
        PingPong = 22,
        /**
         * 从最后一帧开始反向播放，其他同 PingPong
         */
        PingPongReverse = 54
    }
    /**
     * For internal
     */
    export class WrappedInfo {
        ratio: number;
        time: number;
        direction: number;
        stopped: boolean;
        iterations: number;
        frameIndex: number;
        constructor(info?: WrappedInfo);
        set(info: WrappedInfo): void;
    }
    export interface ILerpable {
        /**
         * 在当前曲线值与目标曲线值之间插值。
         * @param to 目标曲线值。
         * @param t 插值比率。
         * @param dt 当前曲线值与目标曲线值的时间间隔，单位为秒。
         * @returns 插值结果。
         */
        lerp(to: any, t: number, dt: number): any;
        /**
         * 当直接使用曲线值作为采样结果时的结果值，它应该等同于插值比率为 0 时的插值结果。
         * @returns 插值比率为 0 时的插值结果。
         */
        getNoLerp?(): any;
    }
    export function isLerpable(object: any): object is ILerpable;
}
declare module "cocos/core/animation/animation-curve" {
    import { BezierControlPoints } from "cocos/core/animation/bezier";
    import * as easing from "cocos/core/animation/easing";
    /**
     * 表示曲线值，曲线值可以是任意类型，但必须符合插值方式的要求。
     */
    export type CurveValue = any;
    /**
     * 表示曲线的目标对象。
     */
    export type CurveTarget = Record<string, any>;
    /**
     * 内置帧时间渐变方式名称。
     */
    export type EasingMethodName = keyof (typeof easing);
    /**
     * 帧时间渐变方式。可能为内置帧时间渐变方式的名称或贝塞尔控制点。
     */
    export type EasingMethod = EasingMethodName | BezierControlPoints;
    type CompressedEasingMethods = Record<number, EasingMethod>;
    /**
     * 曲线数据。
     */
    export interface IPropertyCurveData {
        /**
         * 曲线使用的时间轴。
         * @see {AnimationClip.keys}
         */
        keys: number;
        /**
         * 曲线值。曲线值的数量应和 `keys` 所引用时间轴的帧数相同。
         */
        values: CurveValue[];
        /**
         * 曲线任意两帧时间的渐变方式。仅当 `easingMethods === undefined` 时本字段才生效。
         */
        easingMethod?: EasingMethod;
        /**
         * 描述了每一帧时间到下一帧时间之间的渐变方式。
         */
        easingMethods?: EasingMethod[] | CompressedEasingMethods;
        /**
         * 是否进行插值。
         * @default true
         */
        interpolate?: boolean;
        /**
         * For internal usage only.
         */
        _arrayLength?: number;
    }
    export class RatioSampler {
        ratios: number[];
        private _findRatio;
        constructor(ratios: number[]);
        sample(ratio: number): number;
    }
    /**
     * 动画曲线。
     */
    export class AnimCurve {
        static Linear: null;
        static Bezier(controlPoints: number[]): BezierControlPoints;
        types?: Array<(EasingMethod | null)>;
        type?: EasingMethod | null;
        /**
         * The values of the keyframes. (y)
         */
        private _values;
        /**
         * Lerp function used. If undefined, no lerp is performed.
         */
        private _lerp;
        private _duration;
        private _array?;
        constructor(propertyCurveData: Omit<IPropertyCurveData, 'keys'>, duration: number);
        hasLerp(): boolean;
        valueAt(index: number): any;
        valueBetween(ratio: number, from: number, fromRatio: number, to: number, toRatio: number): any;
        empty(): boolean;
        /**
         * Returns if this curve only yields constants.
         */
        constant(): boolean;
    }
    export class EventInfo {
        events: any[];
        /**
         * @param func event function
         * @param params event params
         */
        add(func: string, params: any[]): void;
    }
    /**
     * 采样动画曲线。
     * @param curve 动画曲线。
     * @param sampler 采样器。
     * @param ratio 采样比率。
     */
    export function sampleAnimationCurve(curve: AnimCurve, sampler: RatioSampler, ratio: number): any;
    /**
     * Compute a new ratio by curve type.
     * @param ratio - The origin ratio
     * @param type - If it's Array, then ratio will be computed with bezierByTime.
     * If it's string, then ratio will be computed with cc.easing function
     */
    export function computeRatioByType(ratio: number, type: EasingMethod): number;
}
declare module "cocos/core/animation/target-path" {
    import { Node } from "cocos/core/scene-graph/node";
    export type PropertyPath = string | number;
    export interface ICustomTargetPath {
        /**
         * If errors are encountered, `null` should be returned.
         * @param target
         */
        get(target: any): any;
    }
    export type TargetPath = PropertyPath | ICustomTargetPath;
    export function isPropertyPath(path: TargetPath): path is PropertyPath;
    export function isCustomPath<T extends ICustomTargetPath>(path: TargetPath, constructor: Constructor<T>): path is T;
    export class HierarchyPath implements ICustomTargetPath {
        path: string;
        constructor(path?: string);
        get(target: Node): Node | null;
    }
    export class ComponentPath implements ICustomTargetPath {
        component: string;
        constructor(component?: string);
        get(target: Node): import("cocos/core/components/component").Component | null;
    }
    /**
     * Evaluate a sequence of paths, in order, from specified root.
     * @param root The root object.
     * @param path The path sequence.
     */
    export function evaluatePath(root: any, ...paths: TargetPath[]): any;
}
declare module "cocos/core/animation/skeletal-animation-data-hub" {
    /**
     * @category animation
     */
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    type CurveData = Vec3[] | Quat[] | Mat4[];
    type ConvertedProps = Record<string, IPropertyCurve>;
    interface IPropertyCurve {
        keys: number;
        values: CurveData;
    }
    interface ISkeletalCurveInfo {
        frames: number;
        sample: number;
    }
    interface IConvertedData {
        info: ISkeletalCurveInfo;
        data: Record<string, ConvertedProps>;
    }
    /**
     * 骨骼动画数据转换中心。
     */
    export class SkelAnimDataHub {
        static getOrExtract(clip: AnimationClip): IConvertedData;
        static destroy(clip: AnimationClip): void;
        protected static pool: Map<AnimationClip, IConvertedData>;
    }
}
declare module "cocos/core/animation/value-proxy" {
    /**
     * @category animation
     */
    /**
     * 曲线值代理用来设置曲线值到目标，是广义的赋值。
     * 每个曲线值代理都关联着一个目标对象。
     */
    export interface IValueProxy {
        get?: () => any;
        /**
         * 设置曲线值到目标对象上。
         */
        set: (value: any) => void;
    }
    export interface IValueProxyFactory {
        /**
         * 返回指定目标的曲线值代理。
         * @param target
         */
        forTarget(target: any): IValueProxy;
    }
}
declare module "cocos/core/animation/animation-clip" {
    import { Asset } from "cocos/core/assets/asset";
    import { SpriteFrame } from "cocos/core/assets/sprite-frame";
    import { CompactValueTypeArray } from "cocos/core/data/utils/compact-value-type-array";
    import { AnimCurve, IPropertyCurveData, RatioSampler } from "cocos/core/animation/animation-curve";
    import { TargetPath } from "cocos/core/animation/target-path";
    import { WrapMode as AnimationWrapMode } from "cocos/core/animation/types";
    import { IValueProxyFactory } from "cocos/core/animation/value-proxy";
    export interface IObjectCurveData {
        [propertyName: string]: IPropertyCurveData;
    }
    export interface IComponentsCurveData {
        [componentName: string]: IObjectCurveData;
    }
    export interface INodeCurveData {
        props?: IObjectCurveData;
        comps?: IComponentsCurveData;
    }
    export type IRuntimeCurve = Pick<AnimationClip.ICurve, 'modifiers' | 'valueAdapter' | 'commonTarget'> & {
        /**
         * 属性曲线。
         */
        curve: AnimCurve;
        /**
         * 曲线采样器。
         */
        sampler: RatioSampler | null;
    };
    export interface IAnimationEvent {
        functionName: string;
        parameters: string[];
    }
    export interface IAnimationEventGroup {
        events: IAnimationEvent[];
    }
    export namespace AnimationClip {
        type PropertyCurveData = IPropertyCurveData;
        interface ICurve {
            commonTarget?: number;
            modifiers: TargetPath[];
            valueAdapter?: IValueProxyFactory;
            data: PropertyCurveData;
        }
        interface ICommonTarget {
            modifiers: TargetPath[];
            valueAdapter?: IValueProxyFactory;
        }
        interface IEvent {
            frame: number;
            func: string;
            params: string[];
        }
        namespace _impl {
            type MaybeCompactCurve = Omit<AnimationClip.ICurve, 'data'> & {
                data: Omit<AnimationClip.PropertyCurveData, 'values'> & {
                    values: any[] | CompactValueTypeArray;
                };
            };
            type MaybeCompactKeys = Array<number[] | CompactValueTypeArray>;
        }
    }
    /**
     * @zh 动画剪辑表示一段使用动画编辑器编辑的关键帧动画或是外部美术工具生产的骨骼动画。
     * 它的数据主要被分为几层：轨道、关键帧和曲线。
     * @en The animation clip represents a sequence of key frame animation created with the animation editor or skeletal animation other DCC tools.
     * The data is divided in different levels: tracks, key frames, curves.
     */
    export class AnimationClip extends Asset {
        static preventDeferredLoadDependents: boolean;
        static WrapMode: typeof AnimationWrapMode;
        /**
         * @en Crate clip with a set of sprite frames
         * @zh 使用一组序列帧图片来创建动画剪辑
         * @example
         * ```
         * import { AnimationClip } from 'cc';
         * const clip = AnimationClip.createWithSpriteFrames(spriteFrames, 10);
         * ```
         */
        static createWithSpriteFrames(spriteFrames: SpriteFrame[], sample: number): AnimationClip | null;
        /**
         * @zh 动画帧率，单位为帧/秒。注意此属性仅用于编辑器动画编辑。
         * @en Animation frame rate: frames per second.
         * Note this property is only used for animation editing in Editor.
         */
        sample: number;
        /**
         * @zh 动画的播放速度。
         * @en Animation playback speed.
         */
        speed: number;
        /**
         * @zh 动画的循环模式。
         * @en Animation loop mode.
         */
        wrapMode: AnimationWrapMode;
        /**
         * @zh 动画包含的事件数据。
         * @en Associated event data.
         */
        events: AnimationClip.IEvent[];
        private _duration;
        private _keys;
        private _stepness;
        private _curves;
        private _commonTargets;
        private _hash;
        private frameRate;
        private _ratioSamplers;
        private _runtimeCurves?;
        private _runtimeEvents?;
        private _data;
        /**
         * @zh 动画的周期。
         * @en Animation duration.
         */
        get duration(): number;
        set duration(value: number);
        /**
         * @zh 曲线可引用的所有时间轴。
         * @en Frame keys referenced by curves.
         */
        get keys(): number[][];
        set keys(value: number[][]);
        /**
         * @protected
         */
        get eventGroups(): readonly IAnimationEventGroup[];
        /**
         * @protected
         */
        get stepness(): number;
        /**
         * @protected
         */
        set stepness(value: number);
        get hash(): number;
        get curves(): AnimationClip.ICurve[];
        set curves(value: AnimationClip.ICurve[]);
        /**
         * 此动画的数据。
         */
        get data(): Uint8Array | null;
        get commonTargets(): AnimationClip.ICommonTarget[];
        set commonTargets(value: AnimationClip.ICommonTarget[]);
        onLoaded(): void;
        getPropertyCurves(): readonly IRuntimeCurve[];
        /**
         * @zh 提交事件数据的修改。
         * 当你修改了 `this.events` 时，必须调用 `this.updateEventDatas()` 使修改生效。
         * @en
         * Commit event data update.
         * You should call this function after you changed the `events` data to take effect.
         * @internal
         */
        updateEventDatas(): void;
        /**
         * @en Gets the event group shall be processed at specified ratio.
         * @zh 获取事件组应按指定比例处理。
         * @param ratio The ratio.
         * @internal
         */
        getEventGroupIndexAtRatio(ratio: number): number;
        /**
         * @zh 返回本动画是否包含事件数据。
         * @en Returns if this animation contains event data.
         * @protected
         */
        hasEvents(): boolean;
        destroy(): boolean;
        protected _createPropertyCurves(): void;
        protected _createRuntimeEvents(): void;
        protected _applyStepness(): void;
        private _decodeCVTAs;
    }
}
declare module "cocos/core/animation/transform-utils" {
    /**
     * @category animation
     */
    import { Mat4 } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    export function getPathFromRoot(target: Node | null, root: Node): string;
    export function getWorldTransformUntilRoot(target: Node, root: Node, outMatrix: Mat4): Mat4;
}
declare module "cocos/core/assets/skeleton" {
    import { Mat4 } from "cocos/core/math/index";
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @zh 骨骼资源。
     * 骨骼资源记录了每个关节（相对于 [[SkinnedMeshRenderer.skinningRoot]]）的路径以及它的绑定姿势矩阵。
     */
    export class Skeleton extends Asset {
        private _joints;
        private _bindposes;
        private _hash;
        private _invBindposes;
        /**
         * 所有关节的路径。该数组的长度始终与 `this.bindposes` 的长度相同。
         */
        get joints(): string[];
        set joints(value: string[]);
        /**
         * 所有关节的绑定姿势矩阵。该数组的长度始终与 `this.joints` 的长度相同。
         */
        get bindposes(): Mat4[];
        set bindposes(value: Mat4[]);
        get inverseBindposes(): Mat4[];
        get hash(): number;
        destroy(): boolean;
    }
}
declare module "cocos/core/renderer/models/skeletal-animation-utils" {
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { Mesh } from "cocos/core/assets/mesh";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { aabb } from "cocos/core/geometry/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXFormat } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { Mat4 } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    import { ITextureBufferHandle } from "cocos/core/renderer/core/texture-buffer-pool";
    export const uploadJointData: typeof uploadJointDataLBS;
    export const MINIMUM_JOINT_TEXTURE_SIZE: number;
    export function selectJointsMediumFormat(device: GFXDevice): GFXFormat;
    function uploadJointDataLBS(out: Float32Array, base: number, mat: Mat4, firstBone: boolean): void;
    export const jointTextureSamplerHash: number;
    interface IInternalJointAnimInfo {
        downstream?: Mat4;
        curveData?: Mat4[];
        bindposeIdx: number;
        bindposeCorrection?: Mat4;
    }
    export interface IJointTextureHandle {
        pixelOffset: number;
        refCount: number;
        clipHash: number;
        skeletonHash: number;
        readyToBeDeleted: boolean;
        handle: ITextureBufferHandle;
        bounds: Map<number, aabb[]>;
        animInfos?: IInternalJointAnimInfo[];
    }
    export interface IChunkContent {
        skeleton: number;
        clips: number[];
    }
    export interface ICustomJointTextureLayout {
        textureLength: number;
        contents: IChunkContent[];
    }
    export class JointTexturePool {
        private _device;
        private _pool;
        private _textureBuffers;
        private _formatSize;
        private _pixelsPerJoint;
        private _customPool;
        private _chunkIdxMap;
        get pixelsPerJoint(): number;
        constructor(device: GFXDevice);
        clear(): void;
        registerCustomTextureLayouts(layouts: ICustomJointTextureLayout[]): void;
        /**
         * @en
         * Get joint texture for the default pose.
         * @zh
         * 获取默认姿势的骨骼贴图。
         */
        getDefaultPoseTexture(skeleton: Skeleton, mesh: Mesh, skinningRoot: Node): IJointTextureHandle | null;
        /**
         * @en
         * Get joint texture for the specified animation clip.
         * @zh
         * 获取指定动画片段的骨骼贴图。
         */
        getSequencePoseTexture(skeleton: Skeleton, clip: AnimationClip, mesh: Mesh, skinningRoot: Node): IJointTextureHandle | null;
        releaseHandle(handle: IJointTextureHandle): void;
        releaseSkeleton(skeleton: Skeleton): void;
        releaseAnimationClip(clip: AnimationClip): void;
        private _createAnimInfos;
    }
    export interface IAnimInfo {
        buffer: GFXBuffer;
        data: Float32Array;
        dirty: boolean;
    }
    export class JointAnimationInfo {
        private _pool;
        private _device;
        constructor(device: GFXDevice);
        getData(nodeID?: string): IAnimInfo;
        destroy(nodeID: string): void;
        switchClip(info: IAnimInfo, clip: AnimationClip | null): IAnimInfo;
        clear(): void;
    }
}
declare module "cocos/core/renderer/scene/submodel" {
    import { RenderingSubMesh } from "cocos/core/assets/mesh";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { RenderPriority } from "cocos/core/pipeline/define";
    import { IMacroPatch, Pass } from "cocos/core/renderer/core/pass";
    import { SubModelHandle } from "cocos/core/renderer/core/memory-pools";
    import { GFXDescriptorSet } from "cocos/core/gfx/index";
    export class SubModel {
        protected _device: GFXDevice | null;
        protected _passes: Pass[] | null;
        protected _subMesh: RenderingSubMesh | null;
        protected _patches: IMacroPatch[] | null;
        protected _handle: SubModelHandle;
        protected _priority: RenderPriority;
        protected _inputAssembler: GFXInputAssembler | null;
        protected _descriptorSet: GFXDescriptorSet | null;
        set passes(passes: Pass[]);
        get passes(): Pass[];
        set subMesh(subMesh: RenderingSubMesh);
        get subMesh(): RenderingSubMesh;
        set priority(val: RenderPriority);
        get priority(): RenderPriority;
        get handle(): SubModelHandle;
        get inputAssembler(): GFXInputAssembler;
        get descriptorSet(): GFXDescriptorSet;
        initialize(subMesh: RenderingSubMesh, passes: Pass[], patches?: IMacroPatch[] | null): void;
        destroy(): void;
        update(): void;
        onPipelineStateChanged(): void;
        onMacroPatchesStateChanged(patches: any): void;
        protected _flushPassInfo(): void;
    }
}
declare module "cocos/core/renderer/scene/ambient" {
    import { Color } from "cocos/core/math/index";
    export class Ambient {
        static SUN_ILLUM: number;
        static SKY_ILLUM: number;
        get colorArray(): Float32Array;
        get albedoArray(): Float32Array;
        /**
         * @en Enable ambient
         * @zh 是否开启环境光
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @en Sky color
         * @zh 天空颜色
         */
        get skyColor(): Color;
        set skyColor(color: Color);
        /**
         * @en Sky illuminance
         * @zh 天空亮度
         */
        get skyIllum(): number;
        set skyIllum(illum: number);
        /**
         * @en Ground color
         * @zh 地面颜色
         */
        get groundAlbedo(): Color;
        set groundAlbedo(color: Color);
        protected _enabled: boolean;
        protected _skyColor: Color;
        protected _skyIllum: number;
        protected _groundAlbedo: Color;
        protected _albedoArray: Float32Array;
        protected _colorArray: Float32Array;
        activate(): void;
    }
}
declare module "cocos/core/renderer/scene/deprecated" {
    const CameraVisFlags: {};
    export { CameraVisFlags };
    const VisibilityFlags: {};
    export { VisibilityFlags };
}
declare module "cocos/core/renderer/scene/light" {
    import { Vec3 } from "cocos/core/math/index";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { Node } from "cocos/core/scene-graph/index";
    export function ColorTemperatureToRGB(rgb: Vec3, kelvin: number): void;
    export enum LightType {
        DIRECTIONAL = 0,
        SPHERE = 1,
        SPOT = 2,
        UNKNOWN = 3
    }
    export const nt2lm: (size: number) => number;
    export class Light {
        set color(color: Vec3);
        get color(): Vec3;
        set useColorTemperature(enable: boolean);
        get useColorTemperature(): boolean;
        set colorTemperature(val: number);
        get colorTemperature(): number;
        get colorTemperatureRGB(): Vec3;
        set node(n: Node | null);
        get node(): Node | null;
        get type(): LightType;
        get name(): string | null;
        get scene(): RenderScene | null;
        protected _color: Vec3;
        protected _useColorTemp: boolean;
        protected _colorTemp: number;
        protected _colorTempRGB: Vec3;
        protected _scene: RenderScene | null;
        protected _node: Node | null;
        protected _type: LightType;
        protected _name: string | null;
        constructor();
        initialize(name: string, node: Node): void;
        attachToScene(scene: RenderScene): void;
        detachFromScene(): void;
        destroy(): void;
        update(): void;
    }
}
declare module "cocos/core/renderer/scene/directional-light" {
    import { Vec3, Vec4 } from "cocos/core/math/index";
    import { Light } from "cocos/core/renderer/scene/light";
    export class DirectionalLight extends Light {
        set shadowRange(shadowRange: number);
        get shadowRange(): number;
        set shadowIntensitywRange(shadowIntensity: number);
        get shadowIntensity(): number;
        set shadowFadeDistance(shadowFadeDistance: number);
        get shadowFadeDistance(): number;
        set shadowDistance(shadowDistance: number);
        get shadowDistance(): number;
        set fadeStart(fadeStart: number);
        get fadeStart(): number;
        set splits(splits: Vec4);
        get splits(): Vec4;
        set biasAutoAdjust(biasAutoAdjust: number);
        get biasAutoAdjust(): number;
        protected _dir: Vec3;
        protected _illum: number;
        private _shadowRange;
        private _shadowIntensity;
        private _shadowFadeDistance;
        private _shadowDistance;
        private _fadeStart;
        private _splits;
        private _biasAutoAdjust;
        set direction(dir: Vec3);
        get direction(): Vec3;
        set illuminance(illum: number);
        get illuminance(): number;
        constructor();
        update(): void;
    }
}
declare module "cocos/core/renderer/scene/sphere-light" {
    import { aabb } from "cocos/core/geometry/index";
    import { Vec3 } from "cocos/core/math/index";
    import { Light } from "cocos/core/renderer/scene/light";
    export class SphereLight extends Light {
        protected _needUpdate: boolean;
        get position(): Vec3;
        set size(size: number);
        get size(): number;
        set range(range: number);
        get range(): number;
        set luminance(lum: number);
        get luminance(): number;
        get aabb(): aabb;
        protected _size: number;
        protected _range: number;
        protected _luminance: number;
        protected _pos: Vec3;
        protected _aabb: aabb;
        constructor();
        update(): void;
    }
}
declare module "cocos/core/pipeline/pipeline-state-manager" {
    /**
     * @hidden
     */
    import { GFXShader, GFXRenderPass, GFXInputAssembler, GFXDevice, GFXPipelineState } from "cocos/core/gfx/index";
    import { PassHandle } from "cocos/core/renderer/core/memory-pools";
    export class PipelineStateManager {
        private static _PSOHashMap;
        static getOrCreatePipelineState(device: GFXDevice, hPass: PassHandle, shader: GFXShader, renderPass: GFXRenderPass, ia: GFXInputAssembler): GFXPipelineState;
    }
}
declare module "cocos/core/renderer/scene/shadows" {
    import { Material } from "cocos/core/assets/material";
    import { frustum, sphere } from "cocos/core/geometry/index";
    import { Color, Mat4, Quat, Vec3, Vec2 } from "cocos/core/math/index";
    import { DirectionalLight } from "cocos/core/renderer/scene/directional-light";
    import { Model } from "cocos/core/renderer/scene/model";
    import { SphereLight } from "cocos/core/renderer/scene/sphere-light";
    import { GFXCommandBuffer, GFXDevice, GFXRenderPass, GFXDescriptorSet } from "cocos/core/gfx/index";
    import { InstancedBuffer } from "cocos/core/pipeline/instanced-buffer";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { ShaderHandle } from "cocos/core/renderer/core/memory-pools";
    /**
     * @zh 阴影类型。
     * @en The shadow type
     * @static
     * @enum Shadows.ShadowType
     */
    export const ShadowType: {
        /**
         * @zh 平面阴影。
         * @en Planar shadow
         * @property Planar
         * @readonly
         */
        Planar: number;
        /**
         * @zh 阴影贴图。
         * @en Shadow type
         * @property ShadowMap
         * @readonly
         */
        ShadowMap: number;
    };
    /**
     * @zh pcf阴影等级。
     * @en The pcf type
     * @static
     * @enum Shadows.ShadowType
     */
    export const PCFType: {
        /**
         * @zh x1 次采样
         * @en x1 times
         * @readonly
         */
        HARD: number;
        /**
         * @zh x5 次采样
         * @en x5 times
         * @readonly
         */
        FILTER_X5: number;
        /**
         * @zh x9 次采样
         * @en x9 times
         * @readonly
         */
        FILTER_X9: number;
        /**
         * @zh x25 次采样
         * @en x25 times
         * @readonly
         */
        FILTER_X25: number;
    };
    interface IShadowRenderData {
        model: Model;
        hShaders: ShaderHandle[];
        instancedBuffer: InstancedBuffer | null;
    }
    export class Shadows {
        /**
         * @en Whether activate planar shadow
         * @zh 是否启用平面阴影？
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * @en The normal of the plane which receives shadow
         * @zh 阴影接收平面的法线
         */
        get normal(): Vec3;
        set normal(val: Vec3);
        /**
         * @en The distance from coordinate origin to the receiving plane.
         * @zh 阴影接收平面与原点的距离
         */
        get distance(): number;
        set distance(val: number);
        /**
         * @en Shadow color
         * @zh 阴影颜色
         */
        get shadowColor(): Color;
        set shadowColor(color: Color);
        /**
         * @en Shadow type
         * @zh 阴影类型
         */
        get type(): number;
        set type(val: number);
        get matLight(): Mat4;
        get data(): Float32Array;
        get sphere(): sphere;
        protected _enabled: boolean;
        protected _type: number;
        protected _normal: Vec3;
        protected _distance: number;
        protected _shadowColor: Color;
        protected _matLight: Mat4;
        protected _data: Float32Array;
        protected _record: Map<Model, IShadowRenderData>;
        protected _pendingModels: IShadowRenderData[];
        protected _material: Material | null;
        protected _instancingMaterial: Material | null;
        protected _device: GFXDevice | null;
        protected _globalDescriptorSet: GFXDescriptorSet | null;
        protected _dirty: boolean;
        /**
         * @zh
         * 场景包围球
         */
        protected _sphere: sphere;
        /**
         * @en get or set shadow camera near
         * @zh 获取或者设置阴影相机近裁剪面
         */
        near: number;
        /**
         * @en get or set shadow camera far
         * @zh 获取或者设置阴影相机远裁剪面
         */
        far: number;
        /**
         * @en get or set shadow camera aspect
         * @zh 获取或者设置阴影相机的宽高比
         */
        aspect: number;
        /**
         * @en get or set shadow camera orthoSize
         * @zh 获取或者设置阴影相机正交大小
         */
        orthoSize: number;
        /**
         * @en get or set shadow camera orthoSize
         * @zh 获取或者设置阴影纹理大小
         */
        size: Vec2;
        /**
         * @en get or set shadow pcf
         * @zh 获取或者设置阴影pcf等级
         */
        pcf: number;
        activate(): void;
        getWorldMatrix(rotation: Quat, dir: Vec3): Mat4;
        protected _updatePlanarInfo(): void;
        protected _updatePipeline(): void;
        updateSphereLight(light: SphereLight): void;
        updateDirLight(light: DirectionalLight): void;
        updateShadowList(scene: RenderScene, frstm: frustum, shadowVisible?: boolean): void;
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
        createShadowData(model: Model): IShadowRenderData;
        destroyShadowData(model: Model): void;
        destroy(): void;
    }
}
declare module "cocos/core/scene-graph/find" {
    import { Node } from "cocos/core/scene-graph/node";
    /**
     * @en Finds a node by hierarchy path, the path is case-sensitive.
     * It will traverse the hierarchy by splitting the path using '/' character.
     * This function will still returns the node even if it is inactive.
     * It is recommended to not use this function every frame instead cache the result at startup.
     * @zh 通过路径从节点树中查找节点的方法，路径是大小写敏感的，并且通过 `/` 来分隔节点层级。
     * 即使节点的状态是未启用的也可以找到，建议将结果缓存，而不是每次需要都去查找。
     * @param path The path of the target node
     * @param referenceNode If given, the search will be limited in the sub node tree of the reference node
     */
    export function find(path: string, referenceNode?: Node): Node | null;
}
declare module "cocos/core/3d/misc/ppm" {
    /**
     * save a color buffer to a PPM file
     */
    export function toPPM(buffer: Uint8Array, w: number, h: number): string;
}
declare module "cocos/core/primitive/define" {
    /**
     * @category 3d/primitive
     */
    import { GFXPrimitiveMode } from "cocos/core/gfx/define";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    /**
     * @en
     * The definition of the parameter for building a primitive geometry.
     * @zh
     * 几何体参数选项。
     */
    export interface IGeometryOptions {
        /**
         * @en
         * Whether to include normal. Default to true.
         * @zh
         * 是否包含法线。默认为true。
         */
        includeNormal: boolean;
        /**
         * @en
         * Whether to include uv. Default to true.
         * @zh
         * 是否包含UV。默认为true。
         */
        includeUV: boolean;
    }
    /**
     * @en
     * Apply the options to default.
     * @zh
     * 应用默认的几何参数选项。
     */
    export function applyDefaultGeometryOptions<GeometryOptions = IGeometryOptions>(options?: RecursivePartial<IGeometryOptions>): GeometryOptions;
    /**
     * @en
     * The definition of the geometry, this struct can build a mesh.
     * @zh
     * 几何体信息。
     */
    export interface IGeometry {
        /**
         * @en
         * Vertex positions.
         * @zh
         * 顶点位置。
         */
        positions: number[];
        /**
         * @en
         * Vertex normals.
         * @zh
         * 顶点法线。
         */
        normals?: number[];
        /**
         * @en
         * Texture coordinates.
         * @zh
         * 纹理坐标。
         */
        uvs?: number[];
        /**
         * @en
         * Vertex Tangents.
         * @zh
         * 顶点切线。
         */
        tangents?: number[];
        /**
         * @en
         * Vertex colors.
         * @zh
         * 顶点颜色。
         */
        colors?: number[];
        /**
         * @en
         * specify vertex attributes, use (positions|normals|uvs|colors) as keys
         * @zh
         * 顶点属性。
         */
        attributes?: IGFXAttribute[];
        customAttributes?: {
            attr: IGFXAttribute;
            values: number[];
        }[];
        /**
         * @en
         * Bounding sphere radius.
         * @zh
         * 包围球半径。
         */
        boundingRadius?: number;
        /**
         * @en
         * Min position.
         * @zh
         * 最小位置。
         */
        minPos?: {
            x: number;
            y: number;
            z: number;
        };
        /**
         * @en
         * Max position.
         * @zh
         * 最大位置。
         */
        maxPos?: {
            x: number;
            y: number;
            z: number;
        };
        /**
         * @en
         * Geometry indices, if one needs indexed-draw.
         * @zh
         * 几何索引，当使用索引绘制时。
         */
        indices?: number[];
        /**
         * @en
         * Topology of the geometry vertices. Default is TRIANGLE_LIST.
         * @zh
         * 几何顶点的拓扑图元。默认值是TRIANGLE_LIST。
         */
        primitiveMode?: GFXPrimitiveMode;
        /**
         * @en
         * whether rays casting from the back face of this geometry could collide with it
         * @zh
         * 是否是双面，用于判断来自于几何体背面的射线检测。
         */
        doubleSided?: boolean;
    }
}
declare module "cocos/core/3d/misc/read-mesh" {
    import { Mesh } from "cocos/core/assets/mesh";
    import { IGeometry } from "cocos/core/primitive/define";
    export function readMesh(mesh: Mesh, iPrimitive?: number): IGeometry;
}
declare module "cocos/core/3d/misc/create-mesh" {
    import { Mesh } from "cocos/core/assets/mesh";
    import { IGeometry } from "cocos/core/primitive/define";
    export function createMesh(geometry: IGeometry, out?: Mesh, options?: createMesh.IOptions): Mesh;
    export namespace createMesh {
        interface IOptions {
            calculateBounds?: boolean;
        }
    }
}
declare module "cocos/core/3d/misc/utils" {
    export { find } from "cocos/core/scene-graph/find";
    export { toPPM } from "cocos/core/3d/misc/ppm";
    export { readMesh } from "cocos/core/3d/misc/read-mesh";
    export { createMesh } from "cocos/core/3d/misc/create-mesh";
    export { readBuffer, writeBuffer, mapBuffer } from "cocos/core/3d/misc/buffer";
}
declare module "cocos/core/primitive/utils" {
    import { IGeometry } from "cocos/core/primitive/define";
    /**
     * @deprecated
     */
    export function wireframe(indices: number[]): number[];
    /**
     * @deprecated
     */
    export function invWinding(indices: number[]): number[];
    /**
     * @deprecated
     */
    export function toWavefrontOBJ(primitive: IGeometry, scale?: number): string;
    /**
     * @deprecated
     */
    export function normals(positions: number[], nms: number[], length?: number): any[];
}
declare module "cocos/core/primitive/box" {
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @en
     * The definition of the parameter for building a box.
     * @zh
     * 立方体参数选项。
     */
    interface IBoxOptions extends RecursivePartial<IGeometryOptions> {
        /**
         * @en
         * Box extent on X-axis.
         * @zh
         * 立方体宽度。
         */
        width?: number;
        /**
         * @en
         * Box extent on Y-axis.
         * @zh
         * 立方体高度。
         */
        height?: number;
        /**
         * @en
         * Box extent on Z-axis.
         * @zh
         * 立方体长度。
         */
        length?: number;
        /**
         * @en
         * Segment count on X-axis.
         * @zh
         * 宽度线段数。
         */
        widthSegments?: number;
        /**
         * @en
         * Segment count on Y-axis.
         * @zh
         * 高度线段数。
         */
        heightSegments?: number;
        /**
         * @en
         * Segment count on Z-axis.
         * @zh
         * 长度线段数。
         */
        lengthSegments?: number;
    }
    /**
     * @en
     * This function generates a box with specified extents and centered at origin,
     * but may be repositioned through the `center` option.
     * @zh
     * 生成一个立方体，其大小是定义的范围且中心在原点。
     * @param options 参数选项。
     */
    export default function box(options?: IBoxOptions): IGeometry;
}
declare module "cocos/core/primitive/cylinder" {
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @en
     * The definition of the parameter for building a cylinder.
     * @zh
     * 圆柱参数选项。
     */
    export interface ICylinderOptions extends IGeometryOptions {
        radialSegments: number;
        heightSegments: number;
        capped: boolean;
        arc: number;
    }
    /**
     * @en
     * Generate a cylinder with radiusTop radiusBottom 0.5, height 2 and centered at origin,
     * but may be repositioned through the `center` option.
     * @zh
     * 生成一个圆柱。
     * @param radiusTop 顶部半径。
     * @param radiusBottom 底部半径。
     * @param opts 圆柱参数选项。
     */
    export default function cylinder(radiusTop?: number, radiusBottom?: number, height?: number, opts?: RecursivePartial<ICylinderOptions>): IGeometry;
}
declare module "cocos/core/primitive/cone" {
    /**
     * @category 3d/primitive
     */
    import { ICylinderOptions } from "cocos/core/primitive/cylinder";
    import { IGeometry } from "cocos/core/primitive/define";
    type IConeOptions = ICylinderOptions;
    /**
     * @en
     * Generate a cone with radius 0.5, height 1, centered at origin,
     * but may be repositioned through the `center` option.
     * @zh
     * 生成一个圆锥。
     * @param radius 圆锥半径。
     * @param height 圆锥高度。
     * @param opts 圆锥参数选项。
     */
    export default function cone(radius?: number, height?: number, opts?: RecursivePartial<IConeOptions>): IGeometry;
}
declare module "cocos/core/primitive/plane" {
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @en
     * The definition of the parameter for building a plane.
     * @zh
     * 平面参数选项。
     */
    interface IPlaneOptions extends RecursivePartial<IGeometryOptions> {
        /**
         * Plane extent on X-axis.
         */
        width: number;
        /**
         * Plane extent on Z-axis.
         */
        length: number;
        /**
         * Segment count on X-axis.
         */
        widthSegments: number;
        /**
         * Segment count on Z-axis.
         */
        lengthSegments: number;
    }
    /**
     * @en
     * This function generates a plane on XOZ plane with positive Y direction.
     * @zh
     * 生成一个平面，其位于XOZ平面，方向为Y轴正方向。
     * @param options 平面参数选项。
     */
    export default function plane(options?: IPlaneOptions): IGeometry;
}
declare module "cocos/core/primitive/quad" {
    /**
     * @category 3d/primitive
     */
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @en
     * Generate a quad with width and height both to 1, centered at origin.
     * @zh
     * 生成一个四边形，宽高都为1，中心在原点。
     * @param options 参数选项。
     */
    export default function quad(options?: IGeometryOptions): IGeometry;
}
declare module "cocos/core/primitive/sphere" {
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @zh
     * 球参数选项。
     */
    interface ISphereOptions extends IGeometryOptions {
        segments: number;
    }
    /**
     * @en
     * Generate a shpere with radius 0.5.
     * @zh
     * 生成一个球。
     * @param radius 球半径。
     * @param options 参数选项。
     */
    export default function sphere(radius?: number, opts?: RecursivePartial<ISphereOptions>): IGeometry;
}
declare module "cocos/core/primitive/torus" {
    /**
     * @category 3d/primitive
     */
    import { Vec3 } from "cocos/core/math/index";
    import { IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @zh
     * 环面参数选项。
     */
    interface ITorusOptions extends IGeometryOptions {
        radialSegments: number;
        tubularSegments: number;
        arc: number;
    }
    /**
     * @en
     * Generate a torus with raidus 0.4, tube 0.1 and centered at origin.
     * @zh
     * 生成一个环面。
     * @param radius 环面半径。
     * @param tube 管形大小。
     * @param opts 参数选项。
     */
    export default function torus(radius?: number, tube?: number, opts?: RecursivePartial<ITorusOptions>): {
        positions: number[];
        normals: number[];
        uvs: number[];
        indices: number[];
        minPos: Vec3;
        maxPos: Vec3;
        boundingRadius: number;
    };
}
declare module "cocos/core/primitive/capsule" {
    /**
     * @category 3d/primitive
     */
    import { Vec3 } from "cocos/core/math/index";
    /**
     * @en
     * The definition of the parameter for building a capsule.
     * @zh
     * 胶囊体参数选项。
     */
    export interface ICapsuteOptions {
        sides: number;
        heightSegments: number;
        capped: boolean;
        arc: number;
    }
    /**
     * Generate a capsule with radiusTop radiusBottom 0.5, height 2, centered at origin,
     * but may be repositioned through the `center` option.
     * @zh
     * 生成一个胶囊体。
     * @param radiusTop 顶部半径。
     * @param radiusBottom 底部半径。
     * @param opts 胶囊体参数选项。
     */
    export default function capsule(radiusTop?: number, radiusBottom?: number, height?: number, opts?: RecursivePartial<ICapsuteOptions>): {
        positions: number[];
        normals: number[];
        uvs: number[];
        indices: number[];
        minPos: Vec3;
        maxPos: Vec3;
        boundingRadius: number;
    };
}
declare module "cocos/core/primitive/circle" {
    import { IGeometry, IGeometryOptions } from "cocos/core/primitive/define";
    /**
     * @en
     * The definition of the parameter for building a circle.
     * @zh
     * 圆形参数选项。
     */
    interface ICircleOptions extends IGeometryOptions {
        segments: number;
    }
    /**
     * @en
     * Generate a circle with radius 1, centered at origin,
     * but may be repositioned through the `center` option.
     * @zh
     * 生成一个圆，其半径是单位1，中心点在原点。
     * @param options 参数选项。
     */
    export default function circle(options?: RecursivePartial<ICircleOptions> | ICircleOptions): IGeometry;
}
declare module "cocos/core/primitive/transform" {
    import { IGeometry } from "cocos/core/primitive/define";
    /**
     * @en
     * Translate the geometry.
     * @zh
     * 平移几何体。
     * @param geometry 几何体信息。
     * @param offset 偏移量。
     */
    export function translate(geometry: IGeometry, offset: {
        x?: number;
        y?: number;
        z?: number;
    }): IGeometry;
    /**
     * @en
     * Scale the geometry.
     * @zh
     * 缩放几何体。
     * @param geometry 几何体信息。
     * @param value 缩放量。
     */
    export function scale(geometry: IGeometry, value: {
        x?: number;
        y?: number;
        z?: number;
    }): IGeometry;
    /**
     * @en
     * Converts geometry to wireframe mode. Only geometry with triangle topology is supported.
     * @zh
     * 将几何体转换为线框模式，仅支持三角形拓扑的几何体。
     * @param geometry 几何体信息。
     */
    export function wireframed(geometry: IGeometry): IGeometry;
}
declare module "cocos/core/primitive/index" {
    /**
     * @category 3d/primitive
     */
    export * from "cocos/core/primitive/utils";
    export * from "cocos/core/primitive/define";
    export { default as box } from "cocos/core/primitive/box";
    export { default as cone } from "cocos/core/primitive/cone";
    export { default as cylinder } from "cocos/core/primitive/cylinder";
    export { default as plane } from "cocos/core/primitive/plane";
    export { default as quad } from "cocos/core/primitive/quad";
    export { default as sphere } from "cocos/core/primitive/sphere";
    export { default as torus } from "cocos/core/primitive/torus";
    export { default as capsule } from "cocos/core/primitive/capsule";
    export { default as circle } from "cocos/core/primitive/circle";
    export { translate, scale, wireframed } from "cocos/core/primitive/transform";
}
declare module "cocos/core/renderer/scene/skybox" {
    import { TextureCube } from "cocos/core/assets/texture-cube";
    import { Model } from "cocos/core/renderer/scene/model";
    import { GFXDescriptorSet } from "cocos/core/gfx/index";
    export class Skybox {
        get model(): Model | null;
        /**
         * @en Whether activate skybox in the scene
         * @zh 是否启用天空盒？
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * @en Whether use environment lighting
         * @zh 是否启用环境光照？
         */
        get useIBL(): boolean;
        set useIBL(val: boolean);
        /**
         * @en Whether enable RGBE data support in skybox shader
         * @zh 是否需要开启 shader 内的 RGBE 数据支持？
         */
        get isRGBE(): boolean;
        set isRGBE(val: boolean);
        /**
         * @en The texture cube used for the skybox
         * @zh 使用的立方体贴图
         */
        get envmap(): TextureCube | null;
        set envmap(val: TextureCube | null);
        protected _enabled: boolean;
        protected _isRGBE: boolean;
        protected _useIBL: boolean;
        protected _envmap: TextureCube | null;
        protected _globalDescriptorSet: GFXDescriptorSet | null;
        protected _model: Model | null;
        protected _default: TextureCube | null;
        activate(): void;
        protected _updatePipeline(): void;
        protected _updateGlobalBinding(): void;
    }
}
declare module "cocos/core/renderer/scene/spot-light" {
    import { aabb, frustum } from "cocos/core/geometry/index";
    import { Vec3 } from "cocos/core/math/index";
    import { Light } from "cocos/core/renderer/scene/light";
    export class SpotLight extends Light {
        protected _dir: Vec3;
        protected _size: number;
        protected _range: number;
        protected _luminance: number;
        protected _spotAngle: number;
        protected _pos: Vec3;
        protected _aabb: aabb;
        protected _frustum: frustum;
        protected _angle: number;
        protected _needUpdate: boolean;
        get position(): Vec3;
        set size(size: number);
        get size(): number;
        set range(range: number);
        get range(): number;
        set luminance(lum: number);
        get luminance(): number;
        get direction(): Vec3;
        get spotAngle(): number;
        set spotAngle(val: number);
        get aabb(): aabb;
        get frustum(): frustum;
        constructor();
        update(): void;
    }
}
declare module "cocos/core/renderer/scene/index" {
    export * from "cocos/core/renderer/scene/ambient";
    export * from "cocos/core/renderer/scene/camera";
    export * from "cocos/core/renderer/scene/deprecated";
    export * from "cocos/core/renderer/scene/directional-light";
    export * from "cocos/core/renderer/scene/light";
    export * from "cocos/core/renderer/scene/model";
    export * from "cocos/core/renderer/scene/shadows";
    export * from "cocos/core/renderer/scene/render-scene";
    export * from "cocos/core/renderer/scene/skybox";
    export * from "cocos/core/renderer/scene/sphere-light";
    export * from "cocos/core/renderer/scene/spot-light";
    export * from "cocos/core/renderer/scene/submodel";
}
declare module "cocos/core/pipeline/instanced-buffer" {
    /**
     * @hidden
     */
    import { GFXTexture } from "cocos/core/gfx/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { Pass } from "cocos/core/renderer/index";
    import { IInstancedAttributeBlock, SubModel } from "cocos/core/renderer/scene/index";
    import { ShaderHandle, DescriptorSetHandle, PassHandle } from "cocos/core/renderer/core/memory-pools";
    export interface IInstancedItem {
        count: number;
        capacity: number;
        vb: GFXBuffer;
        data: Uint8Array;
        ia: GFXInputAssembler;
        stride: number;
        hShader: ShaderHandle;
        hDescriptorSet: DescriptorSetHandle;
        lightingMap: GFXTexture;
    }
    export class InstancedBuffer {
        private static _buffers;
        static get(pass: Pass, extraKey?: number): InstancedBuffer;
        instances: IInstancedItem[];
        hPass: PassHandle;
        hasPendingModels: boolean;
        dynamicOffsets: number[];
        private _device;
        constructor(pass: Pass);
        destroy(): void;
        merge(subModel: SubModel, attrs: IInstancedAttributeBlock, passIdx: number, hShaderImplant?: ShaderHandle | null): void;
        uploadBuffers(): void;
        clear(): void;
    }
}
declare module "cocos/core/renderer/scene/model" {
    import { Material } from "cocos/core/assets/material";
    import { RenderingSubMesh } from "cocos/core/assets/mesh";
    import { aabb } from "cocos/core/geometry/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { Node } from "cocos/core/scene-graph/index";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { Texture2D } from "cocos/core/assets/texture-2d";
    import { SubModel } from "cocos/core/renderer/scene/submodel";
    import { Pass, IMacroPatch } from "cocos/core/renderer/core/pass";
    import { Vec3, Vec4 } from "cocos/core/math/index";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { IGFXAttribute, GFXDescriptorSet } from "cocos/core/gfx/index";
    import { GFXFormat } from "cocos/core/gfx/define";
    export interface IInstancedAttribute {
        name: string;
        format: GFXFormat;
        isNormalized?: boolean;
        view: ArrayBufferView;
    }
    export interface IInstancedAttributeBlock {
        buffer: Uint8Array;
        list: IInstancedAttribute[];
    }
    export enum ModelType {
        DEFAULT = 0,
        SKINNING = 1,
        BAKED_SKINNING = 2,
        UI_BATCH = 3,
        PARTICLE_BATCH = 4,
        LINE = 5
    }
    /**
     * A representation of a model
     */
    export class Model {
        get subModels(): SubModel[];
        get inited(): boolean;
        get worldBounds(): aabb | null;
        get modelBounds(): aabb | null;
        get localBuffer(): GFXBuffer | null;
        get updateStamp(): number;
        get isInstancingEnabled(): boolean;
        get receiveShadow(): boolean;
        set receiveShadow(val: boolean);
        type: ModelType;
        scene: RenderScene | null;
        node: Node;
        transform: Node;
        enabled: boolean;
        visFlags: number;
        castShadow: boolean;
        isDynamicBatching: boolean;
        instancedAttributes: IInstancedAttributeBlock;
        protected _worldBounds: aabb | null;
        protected _modelBounds: aabb | null;
        protected _subModels: SubModel[];
        protected _device: GFXDevice;
        protected _inited: boolean;
        protected _descriptorSetCount: number;
        protected _updateStamp: number;
        protected _transformUpdated: boolean;
        private _localData;
        private _localBuffer;
        private _instMatWorldIdx;
        private _lightmap;
        private _lightmapUVParam;
        private _receiveShadow;
        /**
         * Setup a default empty model
         */
        constructor();
        initialize(node: Node): void;
        destroy(): void;
        attachToScene(scene: RenderScene): void;
        detachFromScene(): void;
        updateTransform(stamp: number): void;
        updateUBOs(stamp: number): void;
        /**
         * Create the bounding shape of this model
         * @param minPos the min position of the model
         * @param maxPos the max position of the model
         */
        createBoundingShape(minPos?: Vec3, maxPos?: Vec3): void;
        initSubModel(idx: number, subMeshData: RenderingSubMesh, mat: Material): void;
        setSubModelMesh(idx: number, subMesh: RenderingSubMesh): void;
        setSubModelMaterial(idx: number, mat: Material): void;
        onGlobalPipelineStateChanged(): void;
        onMacroPatchesStateChanged(): void;
        updateLightingmap(texture: Texture2D | null, uvParam: Vec4): void;
        getMacroPatches(subModelIndex: number): IMacroPatch[] | null;
        protected _updateAttributesAndBinding(subModelIndex: number): void;
        protected _getInstancedAttributeIndex(name: string): number;
        protected _updateInstancedAttributes(attributes: IGFXAttribute[], pass: Pass): void;
        protected _initLocalDescriptors(subModelIndex: number): void;
        protected _updateLocalDescriptors(submodelIdx: number, descriptorSet: GFXDescriptorSet): void;
    }
}
declare module "cocos/core/assets/morph-rendering" {
    /**
     * @hidden
     */
    import { GFXDevice } from "cocos/core/gfx/index";
    import { Mesh } from "cocos/core/assets/mesh";
    import { MorphRendering, MorphRenderingInstance } from "cocos/core/assets/morph";
    /**
     * Standard morph rendering.
     * The standard morph rendering renders each of sub-mesh morph separately.
     * Sub-mesh morph rendering may select different technique according sub-mesh morph itself.
     */
    export class StdMorphRendering implements MorphRendering {
        private _mesh;
        private _subMeshRenderings;
        constructor(mesh: Mesh, gfxDevice: GFXDevice);
        createInstance(): MorphRenderingInstance;
    }
}
declare module "cocos/core/assets/morph" {
    /**
     * @hidden
     */
    import { GFXAttributeName, GFXDevice, GFXDescriptorSet } from "cocos/core/gfx/index";
    import { Mesh } from "cocos/core/assets/mesh";
    import { IMacroPatch } from "cocos/core/renderer/index";
    export interface Morph {
        /**
         * Morph data of each sub-mesh.
         */
        subMeshMorphs: (SubMeshMorph | null)[];
        /**
         * Common initial weights of each sub-mesh.
         */
        weights?: number[];
        /**
         * Name of each target of each sub-mesh morph.
         * This field is only meaningful if every sub-mesh has the same number of targets.
         */
        targetNames?: string[];
    }
    export interface MorphTarget {
        /**
         * Displacement of each target attribute.
         */
        displacements: Mesh.IBufferView[];
    }
    export interface SubMeshMorph {
        /**
         * Attributes to morph.
         */
        attributes: GFXAttributeName[];
        /**
         * Targets.
         */
        targets: MorphTarget[];
        /**
         * Initial weights of each target.
         */
        weights?: number[];
    }
    export function createMorphRendering(mesh: Mesh, gfxDevice: GFXDevice): MorphRendering | null;
    /**
     * Class which control rendering of a morph resource.
     */
    export interface MorphRendering {
        createInstance(): MorphRenderingInstance;
    }
    /**
     * This rendering instance of a morph resource.
     */
    export interface MorphRenderingInstance {
        /**
         * Sets weights of targets of specified sub mesh.
         * @param subMeshIndex
         * @param weights
         */
        setWeights(subMeshIndex: number, weights: number[]): void;
        /**
         * Adapts pipeline state to do the rendering.
         * @param subMeshIndex
         * @param pipelineState
         */
        adaptPipelineState(subMeshIndex: number, descriptorSet: GFXDescriptorSet): void;
        requiredPatches(subMeshIndex: number): IMacroPatch[] | undefined;
        /**
         * Destroy the rendering instance.
         */
        destroy(): void;
    }
}
declare module "cocos/core/renderer/models/morph-model" {
    import { Model } from "cocos/core/renderer/scene/model";
    import { MorphRenderingInstance } from "cocos/core/assets/morph";
    import { Material } from "cocos/core/assets/material";
    import { RenderingSubMesh } from "cocos/core/assets/mesh";
    import { GFXDescriptorSet } from "cocos/core/gfx/index";
    export class MorphModel extends Model {
        private _morphRenderingInstance;
        private _usedMaterials;
        getMacroPatches(subModelIndex: number): any;
        initSubModel(subModelIndex: number, subMeshData: RenderingSubMesh, material: Material): void;
        setSubModelMaterial(subModelIndex: number, material: Material): void;
        protected _updateLocalDescriptors(submodelIdx: number, descriptorSet: GFXDescriptorSet): void;
        private _launderMaterial;
        setMorphRendering(morphRendering: MorphRenderingInstance): void;
    }
}
declare module "cocos/core/renderer/models/skinning-model" {
    /**
     * @hidden
     */
    import { Material } from "cocos/core/assets/material";
    import { Mesh, RenderingSubMesh } from "cocos/core/assets/mesh";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { Mat4 } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/node";
    import { MorphModel } from "cocos/core/renderer/models/morph-model";
    import { GFXDescriptorSet } from "cocos/core/gfx/index";
    export interface IJointTransform {
        node: Node;
        local: Mat4;
        world: Mat4;
        stamp: number;
        parent: IJointTransform | null;
    }
    export function getWorldMatrix(transform: IJointTransform | null, stamp: number): Readonly<Mat4>;
    export function getTransform(node: Node, root: Node): IJointTransform | null;
    export function deleteTransform(node: Node): void;
    /**
     * @en
     * The skinning model that is using real-time pose calculation.
     * @zh
     * 实时计算动画的蒙皮模型。
     */
    export class SkinningModel extends MorphModel {
        uploadAnimation: null;
        private _buffers;
        private _dataArray;
        private _joints;
        private _bufferIndices;
        constructor();
        destroy(): void;
        bindSkeleton(skeleton?: Skeleton | null, skinningRoot?: Node | null, mesh?: Mesh | null): void;
        updateTransform(stamp: number): void;
        updateUBOs(stamp: number): boolean;
        initSubModel(idx: number, subMeshData: RenderingSubMesh, mat: Material): void;
        getMacroPatches(subModelIndex: number): any;
        _updateLocalDescriptors(submodelIdx: number, descriptorSet: GFXDescriptorSet): void;
        private _ensureEnoughBuffers;
    }
}
declare module "cocos/core/renderer/models/baked-skinning-model" {
    /**
     * @hidden
     */
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { Mesh } from "cocos/core/assets/mesh";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { Vec3 } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    import { Pass } from "cocos/core/renderer/core/pass";
    import { IJointTextureHandle } from "cocos/core/renderer/models/skeletal-animation-utils";
    import { MorphModel } from "cocos/core/renderer/models/morph-model";
    import { IGFXAttribute, GFXDescriptorSet } from "cocos/core/gfx/index";
    /**
     * @en
     * The skinning model that is using baked animation.
     * @zh
     * 预烘焙动画的蒙皮模型。
     */
    export class BakedSkinningModel extends MorphModel {
        uploadedAnim: AnimationClip | null | undefined;
        private _jointsMedium;
        private _skeleton;
        private _mesh;
        private _dataPoolManager;
        private _instAnimInfoIdx;
        constructor();
        destroy(): void;
        bindSkeleton(skeleton?: Skeleton | null, skinningRoot?: Node | null, mesh?: Mesh | null): void;
        updateTransform(stamp: number): void;
        updateUBOs(stamp: number): boolean;
        createBoundingShape(minPos?: Vec3, maxPos?: Vec3): void;
        uploadAnimation(anim: AnimationClip | null): void;
        protected _applyJointTexture(texture?: IJointTextureHandle | null): void;
        getMacroPatches(subModelIndex: number): any;
        protected _updateLocalDescriptors(submodelIdx: number, descriptorSet: GFXDescriptorSet): void;
        protected _updateInstancedAttributes(attributes: IGFXAttribute[], pass: Pass): void;
        private updateInstancedJointTextureInfo;
    }
}
declare module "cocos/core/renderer/models/index" {
    export * from "cocos/core/renderer/models/skeletal-animation-utils";
    export * from "cocos/core/renderer/models/skinning-model";
    export * from "cocos/core/renderer/models/baked-skinning-model";
    export * from "cocos/core/renderer/models/morph-model";
}
declare module "cocos/core/renderer/index" {
    export { createIA } from "cocos/core/renderer/utils";
    const addStage: (name: any) => void;
    export { addStage };
    export * from "cocos/core/renderer/core/constants";
    export * from "cocos/core/renderer/core/pass-utils";
    export * from "cocos/core/renderer/core/pass";
    export * from "cocos/core/renderer/core/program-lib";
    export * from "cocos/core/renderer/core/sampler-lib";
    export * from "cocos/core/renderer/core/texture-buffer-pool";
    export * from "cocos/core/renderer/core/material-instance";
    export * from "cocos/core/renderer/core/pass-instance";
    import * as models from "cocos/core/renderer/models/index";
    import * as scene from "cocos/core/renderer/scene/index";
    export { scene, models };
    import "cocos/core/renderer/scene/deprecated";
    import "cocos/core/renderer/ui/render-data";
}
declare module "cocos/core/3d/framework/renderable-component" {
    import { Material } from "cocos/core/assets/material";
    import { Component } from "cocos/core/components/component";
    import { MaterialInstance } from "cocos/core/renderer/core/material-instance";
    import { scene } from "cocos/core/renderer/index";
    export class RenderableComponent extends Component {
        protected _materials: (Material | null)[];
        protected _visFlags: number;
        get visibility(): number;
        set visibility(val: number);
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        /**
         * @en The materials of the model.
         * @zh 模型材质。
         */
        get materials(): (MaterialInstance | null)[];
        set materials(val: (MaterialInstance | null)[]);
        protected _materialInstances: (MaterialInstance | null)[];
        protected _models: scene.Model[];
        get sharedMaterial(): Material | null;
        /**
         * @en Get the shared material asset of the specified sub-model.
         * @zh 获取指定子模型的共享材质资源。
         */
        getMaterial(idx: number): Material | null;
        /**
         * @en Set the shared material asset of the specified sub-model,
         * new material instance will be created automatically if the sub-model is already using one.
         * @zh 设置指定子模型的 sharedMaterial，如果对应位置有材质实例则会创建一个对应的材质实例。
         */
        setMaterial(material: Material | null, index: number): void;
        get material(): Material | null;
        set material(val: Material | null);
        /**
         * @en Get the material instance of the specified sub-model.
         * @zh 获取指定子模型的材质实例。
         */
        getMaterialInstance(idx: number): Material | null;
        /**
         * @en Set the material instance of the specified sub-model.
         * @zh 获取指定子模型的材质实例。
         */
        setMaterialInstance(index: number, matInst: Material | null): void;
        /**
         * @en Get the actual rendering material of the specified sub-model.
         * (material instance if there is one, or the shared material asset)
         * @zh 获取指定位置可供渲染的材质，如果有材质实例则使用材质实例，如果没有则使用材质资源
         */
        getRenderMaterial(index: number): Material | null;
        _collectModels(): scene.Model[];
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected _onMaterialModified(index: number, material: Material | null): void;
        protected _onRebuildPSO(index: number, material: Material | null): void;
        protected _clearMaterials(): void;
        protected _onVisibilityChange(val: any): void;
    }
}
declare module "cocos/core/assets/material" {
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { MacroRecord, MaterialProperty } from "cocos/core/renderer/core/pass-utils";
    import { Pass, PassOverrides } from "cocos/core/renderer/core/pass";
    import { Asset } from "cocos/core/assets/asset";
    import { EffectAsset } from "cocos/core/assets/effect-asset";
    import { SpriteFrame } from "cocos/core/assets/sprite-frame";
    import { TextureBase } from "cocos/core/assets/texture-base";
    import { RenderTexture } from "cocos/core/assets/render-texture";
    /**
     * @en
     * The basic infos for material initialization.
     * @zh
     * 用来初始化材质的基本信息。
     */
    interface IMaterialInfo {
        /**
         * @en
         * The EffectAsset to use. Must provide if `effectName` is not specified.
         * @zh
         * 这个材质将使用的 EffectAsset，直接提供资源引用，和 `effectName` 至少要指定一个。
         */
        effectAsset?: EffectAsset | null;
        /**
         * @en
         * The name of the EffectAsset to use. Must provide if `effectAsset` is not specified.
         * @zh
         * 这个材质将使用的 EffectAsset，通过 effect 名指定，和 `effectAsset` 至少要指定一个。
         */
        effectName?: string;
        /**
         * @en
         * The index of the technique to use.
         * @zh
         * 这个材质将使用第几个 technique，默认为 0。
         */
        technique?: number;
        /**
         * @en
         * The shader macro definitions. Default to 0 or the specified value in [[EffectAsset]].
         * @zh
         * 这个材质定义的预处理宏，默认全为 0，或 [[EffectAsset]] 中的指定值。
         */
        defines?: MacroRecord | MacroRecord[];
        /**
         * @en
         * The override values on top of the pipeline states specified in [[EffectAsset]].
         * @zh
         * 这个材质的自定义管线状态，将覆盖 effect 中的属性。<br>
         * 注意在可能的情况下请尽量少的自定义管线状态，以减小对渲染效率的影响。
         */
        states?: PassOverrides | PassOverrides[];
    }
    type MaterialPropertyFull = MaterialProperty | TextureBase | SpriteFrame | RenderTexture | GFXTexture | null;
    /**
     * @en
     * The material asset, specifies in details how a model is drawn on screen.
     * @zh
     * 材质资源类，包含模型绘制方式的全部细节描述。
     */
    export class Material extends Asset {
        static getHash(material: Material): number;
        protected _effectAsset: EffectAsset | null;
        protected _techIdx: number;
        protected _defines: MacroRecord[];
        protected _states: PassOverrides[];
        protected _props: Record<string, MaterialPropertyFull | MaterialPropertyFull[]>[];
        protected _passes: Pass[];
        protected _hash: number;
        /**
         * @en The current [[EffectAsset]].
         * @zh 当前使用的 [[EffectAsset]] 资源。
         */
        get effectAsset(): EffectAsset | null;
        /**
         * @en Name of the current [[EffectAsset]].
         * @zh 当前使用的 [[EffectAsset]] 资源名。
         */
        get effectName(): string;
        /**
         * @en The current technique index.
         * @zh 当前的 technique 索引。
         */
        get technique(): number;
        /**
         * @en The passes defined in this material.
         * @zh 当前正在使用的 pass 数组。
         */
        get passes(): Pass[];
        /**
         * @en The hash value of this material.
         * @zh 材质的 hash。
         */
        get hash(): number;
        get parent(): Material | null;
        get owner(): RenderableComponent | null;
        constructor();
        /**
         * @en Initialize this material with the given information.
         * @zh 根据所给信息初始化这个材质，初始化正常结束后材质即可立即用于渲染。
         * @param info Material description info.
         */
        initialize(info: IMaterialInfo): void;
        reset(info: IMaterialInfo): void;
        /**
         * @en
         * Destroy the material definitively.<br>
         * Cannot re-initialize after destroy.<br>
         * For re-initialize purposes, call [[Material.initialize]] directly.
         * @zh
         * 彻底销毁材质，注意销毁后无法重新初始化。<br>
         * 如需重新初始化材质，不必先调用 destroy。
         */
        destroy(): boolean;
        /**
         * @en Recompile the shader with the specified macro overrides. Allowed only on material instances.
         * @zh 使用指定预处理宏重新编译当前 pass（数组）中的 shader。只允许对材质实例执行。
         * @param overrides The shader macro override values.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        recompileShaders(overrides: MacroRecord, passIdx?: number): void;
        /**
         * @en Override the passes with the specified pipeline states. Allowed only on material instances.
         * @zh 使用指定管线状态重载当前的 pass（数组）。只允许对材质实例执行。
         * @param overrides The pipeline state override values.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        overridePipelineStates(overrides: PassOverrides, passIdx?: number): void;
        /**
         * @en Callback function after material is loaded in [[Loader]]. Initialize the resources automatically.
         * @zh 通过 [[Loader]] 加载完成时的回调，将自动初始化材质资源。
         */
        onLoaded(): void;
        /**
         * @en Reset all the uniforms to the default value specified in [[EffectAsset]].
         * @zh 重置材质的所有 uniform 参数数据为 [[EffectAsset]] 中的默认初始值。
         * @param clearPasses Will the rendering data be cleared too?
         */
        resetUniforms(clearPasses?: boolean): void;
        /**
         * @en
         * Convenient property setter provided for quick material setup.<br>
         * [[Pass.setUniform]] should be used instead if you need to do per-frame uniform update.
         * @zh
         * 设置材质 uniform 参数的统一入口。<br>
         * 注意如果需要每帧更新 uniform，建议使用 [[Pass.setUniform]] 以获得更好的性能。
         * @param name The target uniform name.
         * @param val The target value.
         * @param passIdx The pass to apply to. Will apply to all passes if not specified.
         */
        setProperty(name: string, val: MaterialPropertyFull | MaterialPropertyFull[], passIdx?: number): void;
        /**
         * @en
         * Get the specified uniform value for this material.<br>
         * Note that only uniforms set through [[Material.setProperty]] can be acquired here.<br>
         * For the complete rendering data, use [[Pass.getUniform]] instead.
         * @zh
         * 获取当前材质的指定 uniform 参数的值。<br>
         * 注意只有通过 [[Material.setProperty]] 函数设置的参数才能从此函数取出，<br>
         * 如需取出完整的渲染数据，请使用 [[Pass.getUniform]]。
         * @param name The property or uniform name.
         * @param passIdx The target pass index. If not specified, return the first found value in all passes.
         */
        getProperty(name: string, passIdx?: number): number | import("index").Vec3 | import("index").Mat4 | import("index").Quat | import("index").Mat3 | import("index").Vec2 | import("index").Vec4 | import("index").Color | GFXTexture | TextureBase | SpriteFrame | RenderTexture | MaterialPropertyFull[] | null;
        /**
         * @en Copy the target material.
         * @zh 复制目标材质到当前实例。
         * @param mat The material to be copied.
         */
        copy(mat: Material): void;
        protected _prepareInfo(patch: object | object[], cur: object[]): void;
        protected _createPasses(): Pass[];
        protected _update(keepProps?: boolean): void;
        protected _uploadProperty(pass: Pass, name: string, val: MaterialPropertyFull | MaterialPropertyFull[]): boolean;
        protected _bindTexture(pass: Pass, binding: number, val: MaterialPropertyFull, index?: number): false | undefined;
        protected _doDestroy(): void;
    }
}
declare module "cocos/core/renderer/ui/render-data" {
    /**
     * @hidden
     */
    import { Material } from "cocos/core/assets/material";
    import { Color } from "cocos/core/math/index";
    export interface IRenderData {
        x: number;
        y: number;
        z: number;
        u: number;
        v: number;
        color: Color;
    }
    export class BaseRenderData {
        material: Material | null;
        vertexCount: number;
        indicesCount: number;
    }
    export class RenderData extends BaseRenderData {
        get dataLength(): number;
        set dataLength(length: number);
        get data(): IRenderData[];
        static add(): RenderData;
        static remove(data: RenderData): void;
        vData: Float32Array | null;
        uvDirty: boolean;
        vertDirty: boolean;
        private _data;
        private _indices;
        private _pivotX;
        private _pivotY;
        private _width;
        private _height;
        updateSizeNPivot(width: number, height: number, pivotX: number, pivotY: number): void;
        clear(): void;
    }
    export class MeshRenderData extends BaseRenderData {
        vData: Float32Array;
        iData: Uint16Array;
        vertexStart: number;
        indicesStart: number;
        byteStart: number;
        byteCount: number;
        private _formatByte;
        request(vertexCount: number, indicesCount: number): boolean;
        reset(): void;
    }
}
declare module "cocos/ui/assembler/utils" {
    /**
     * @hidden
     */
    import { Color } from "cocos/core/math/index";
    import { RenderData } from "cocos/core/renderer/ui/render-data";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { Node } from "cocos/core/index";
    export function fillVertices3D(node: Node, renderer: UI, renderData: RenderData, color: Color): void;
    export function fillMeshVertices3D(node: Node, renderer: UI, renderData: RenderData, color: Color): void;
    export function fillVerticesWithoutCalc3D(node: Node, renderer: UI, renderData: RenderData, color: Color): void;
}
declare module "cocos/core/renderer/ui/base" {
    /**
     * ui 相关模块
     * @category ui
     */
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    export interface IAssembler {
        [key: string]: any;
    }
    export interface IAssemblerManager {
        getAssembler(component: UIRenderable): IAssembler;
    }
}
declare module "cocos/core/components/ui-base/deprecated" {
    import { UITransform } from "cocos/core/components/ui-base/ui-transform";
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    import { Canvas } from "cocos/core/components/ui-base/canvas";
    /**
     * Alias of [[UITransform]]
     * @deprecated Since v1.2
     */
    export { UITransform as UITransformComponent };
    /**
     * Alias of [[UIRenderable]]
     * @deprecated Since v1.2
     */
    export { UIRenderable as RenderComponent };
    /**
     * Alias of [[Canvas]]
     * @deprecated Since v1.2
     */
    export { Canvas as CanvasComponent };
}
declare module "cocos/core/components/ui-base/index" {
    /**
     * @hidden
     */
    export * from "cocos/core/components/ui-base/canvas";
    export * from "cocos/core/components/ui-base/ui-component";
    export * from "cocos/core/components/ui-base/ui-renderable";
    export * from "cocos/core/components/ui-base/ui-transform";
    export * from "cocos/core/components/ui-base/deprecated";
}
declare module "cocos/core/utils/decode-uuid" {
    /**
     * @en
     * Decode uuid, returns the original uuid
     *
     * @zh
     * 解码 uuid，返回原始 uuid
     *
     * @method decodeUuid
     * @param  base64 - the encoded uuid
     * @returns the original uuid
     *
     * @example
     * ```ts
     * const uuid = 'fcmR3XADNLgJ1ByKhqcC5Z';
     * const originalUuid = decodeUuid(uuid); // fc991dd7-0033-4b80-9d41-c8a86a702e59
     * ```
     */
    export default function decodeUuid(base64: string): string;
}
declare module "cocos/core/load-pipeline/url" {
    /**
     * @class url
     * @static
     */
    let url: {
        /**
         * The base url of raw assets.
         * @private
         * @readOnly
         */
        _rawAssets: string;
        normalize: (url: any) => any;
        /**
         * Returns the url of raw assets, you will only need this if the raw asset is inside the "resources" folder.
         *
         * @method raw
         * @param {String} url
         * @return {String}
         * @example {@link cocos/core/platform/url/raw.js}
         */
        raw: (url: any) => string;
        _init: (assets: any) => void;
    };
    export default url;
}
declare module "cocos/core/assets/sprite-atlas" {
    import { Asset } from "cocos/core/assets/asset";
    import { SpriteFrame } from "cocos/core/assets/sprite-frame";
    interface ISpriteFrameList {
        [key: string]: SpriteFrame | null;
    }
    /**
     * @en
     * Class for sprite atlas handling.
     *
     * @zh
     * 精灵图集资源类。
     */
    export class SpriteAtlas extends Asset {
        spriteFrames: ISpriteFrameList;
        /**
         * @zh
         * 获取精灵图集的贴图。请注意，由于结构调整优化，在 v1.1 版本之前，此函数的返回值为 imageAsset，在 v1.1 版本之后修正为 texture，想要获取 imageAsset 可使用 getTexture().image 获取
         *
         * @returns - 精灵贴图。
         */
        getTexture(): import("cocos/core/assets/texture-base").TextureBase | import("index").RenderTexture | null;
        /**
         * @zh
         * 根据键值获取精灵。
         *
         * @param key - 精灵名。
         * @returns - 精灵。
         */
        getSpriteFrame(key: string): SpriteFrame | null;
        /**
         * @zh
         * 获取精灵图集所有精灵。
         *
         * @returns - 返回所有精灵。
         */
        getSpriteFrames(): (SpriteFrame | null)[];
        _serialize(exporting?: any): {
            name: string;
            spriteFrames: string[];
        };
        _deserialize(serializeData: any, handle: any): void;
    }
}
declare module "cocos/core/load-pipeline/asset-table" {
    export class AssetTable {
        private _pathToUuid;
        constructor();
        /**
         * Retrieve the asset uuid with the asset path and type
         */
        getUuid(path: string, type: Function): any;
        /**
         * Retrieve an uuid array with the asset path and type
         */
        getUuidArray(path: string, type: Function, out_urls: string[]): string[];
        /**
         * @en Add an asset entry with path as key and asset uuid & type as value to the table
         * @zh 以路径为 key，uuid 和资源类型为值添加到表中。
         * @param path - the path of the asset, should NOT include filename extensions.
         * @param uuid - The uuid of the asset
         * @param type - Constructor of the asset
         * @param isMainAsset
         * @private
         */
        add(path: string, uuid: string, type: Function, isMainAsset: boolean): void;
        _getInfo_DEBUG(uuid: any, out_info: any): boolean;
        reset(): void;
    }
}
declare module "cocos/core/load-pipeline/loading-items" {
    /**
     * @category loader
     */
    import { CallbacksInvoker } from "cocos/core/event/callbacks-invoker";
    export interface IItem {
        queueId: any;
        id: string;
        url: any;
        rawUrl: any;
        urlParam: any;
        type: string;
        error: Error | null;
        content: any;
        complete: boolean;
        states: object;
        deps: any;
        isScene: boolean;
    }
    /**
     * @en
     * LoadingItems is the queue of items which can flow them into the loading pipeline.<br/>
     * Please don't construct it directly, use [[create]] instead, because we use an internal pool to recycle the queues.<br/>
     * It hold a map of items, each entry in the map is a url to object key value pair.<br/>
     * Each item always contains the following property:<br/>
     * - id: The identification of the item, usually it's identical to url<br/>
     * - url: The url <br/>
     * - type: The type, it's the extension name of the url by default, could be specified manually too.<br/>
     * - error: The error happened in pipeline will be stored in this property.<br/>
     * - content: The content processed by the pipeline, the final result will also be stored in this property.<br/>
     * - complete: The flag indicate whether the item is completed by the pipeline.<br/>
     * - states: An object stores the states of each pipe the item go through, the state can be: Pipeline.ItemState.WORKING | Pipeline.ItemState.ERROR | Pipeline.ItemState.COMPLETE<br/>
     * <br/>
     * Item can hold other custom properties.<br/>
     * Each LoadingItems object will be destroyed for recycle after onComplete callback<br/>
     * So please don't hold its reference for later usage, you can copy properties in it though.
     * @zh
     * LoadingItems 是一个加载对象队列，可以用来输送加载对象到加载管线中。<br/>
     * 请不要直接使用 new 构造这个类的对象，你可以使用 [[create]] 来创建一个新的加载队列，这样可以允许我们的内部对象池回收并重利用加载队列。
     * 它有一个 map 属性用来存放加载项，在 map 对象中已 url 为 key 值。<br/>
     * 每个对象都会包含下列属性：<br/>
     * - id：该对象的标识，通常与 url 相同。<br/>
     * - url：路径 <br/>
     * - type: 类型，它这是默认的 URL 的扩展名，可以手动指定赋值。<br/>
     * - error：pipeline 中发生的错误将被保存在这个属性中。<br/>
     * - content: pipeline 中处理的临时结果，最终的结果也将被存储在这个属性中。<br/>
     * - complete：该标志表明该对象是否通过 pipeline 完成。<br/>
     * - states：该对象存储每个管道中对象经历的状态，状态可以是 Pipeline.ItemState.WORKING | Pipeline.ItemState.ERROR | Pipeline.ItemState.COMPLETE<br/>
     * <br/>
     * 对象可容纳其他自定义属性。<br/>
     * 每个 LoadingItems 对象都会在 onComplete 回调之后被销毁，所以请不要持有它的引用并在结束回调之后依赖它的内容执行任何逻辑，有这种需求的话你可以提前复制它的内容。
     */
    export class LoadingItems extends CallbacksInvoker {
        /**
         * @en The item states of the LoadingItems, its value could be {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
         * @zh LoadingItems 队列中的加载项状态，状态的值可能是 {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
         */
        static ItemState: any;
        /**
         * @en This is a callback which will be invoked while an item flow out the pipeline.
         * You can pass the callback function in LoadingItems.create or set it later.
         * @zh 这个回调函数将在 item 加载结束后被调用。你可以在构造时传递这个回调函数或者是在构造之后直接设置。
         * @param completedCount The number of the items that are already completed.
         * @param totalCount The total number of the items.
         * @param item The latest item which flow out the pipeline.
         * @example
         * ```
         * import { log } from 'cc';
         * loadingItems.onProgress (completedCount, totalCount, item) {
         *     let progress = (100 * completedCount / totalCount).toFixed(2);
         *     log(progress + '%');
         * }
         * ```
         */
        onProgress: ((completedCount: number, totalCount: number, IItem: any) => void) | undefined;
        /**
         * @en This is a callback which will be invoked while all items is completed,
         * You can pass the callback function in LoadingItems.create or set it later.
         * @zh 该函数将在加载队列全部完成时被调用。你可以在构造时传递这个回调函数或者是在构造之后直接设置。
         * @param errors All errored urls will be stored in this array, if no error happened, then it will be null
         * @param items All items.
         * @example
         * ```
         * import { log } from 'cc';
         * loadingItems.onComplete (errors, items) {
         *     if (error) {
         *         log('Completed with ' + errors.length + ' errors');
         *     } else {
         *         log('Completed ' + items.totalCount + ' items');
         *     }
         * }
         * ```
         */
        onComplete: ((errors: string[] | null, items: LoadingItems) => void) | undefined;
        /**
         * @en The map of all items.
         * @zh 存储所有加载项的对象。
         */
        map: Map<string, IItem>;
        /**
         * @en The map of completed items.
         * @zh 存储已经完成的加载项。
         */
        completed: {};
        /**
         * @en Total count of all items.
         * @zh 所有加载项的总数。
         */
        totalCount: number;
        /**
         * @en Total count of completed items.
         * @zh 所有完成加载项的总数。
         */
        completedCount: number;
        /**
         * @en Activated or not.
         * @zh 是否启用。
         */
        active: boolean;
        private _id;
        private _pipeline;
        private _errorUrls;
        private _appending;
        _ownerQueue: LoadingItems | null;
        constructor(pipeline: any, urlList: any, onProgress: any, onComplete: any);
        /**
         * @en The constructor function of LoadingItems, this will use recycled LoadingItems in the internal pool if possible.
         * You can pass onProgress and onComplete callbacks to visualize the loading process.
         * @zh LoadingItems 的构造函数，这种构造方式会重用内部对象缓冲池中的 LoadingItems 队列，以尽量避免对象创建。
         * 你可以传递 onProgress 和 onComplete 回调函数来获知加载进度信息。
         * @param {Pipeline} pipeline The pipeline to process the queue.
         * @param {Array} urlList The items array.
         * @param {Function} [onProgress] The progression callback, refer to [[onProgress]]
         * @param {Function} [onComplete] The completion callback, refer to [[LoadingItems.onComplete]]
         * @return {LoadingItems} The LoadingItems queue object
         * @example
         * ```
         * import { log, LoadingItems } from 'cc';
         * LoadingItems.create(loader, ['a.png', 'b.plist'], function (completedCount, totalCount, item) {
         *     let progress = (100 * completedCount / totalCount).toFixed(2);
         *     log(progress + '%');
         * }, function (errors, items) {
         *     if (errors) {
         *         for (let i = 0; i < errors.length; ++i) {
         *             log('Error url: ' + errors[i] + ', error: ' + items.getError(errors[i]));
         *         }
         *     }
         *     else {
         *         let result_a = items.getContent('a.png');
         *         // ...
         *     }
         * })
         * ```
         */
        static create(pipeline: any, urlList: any, onProgress?: any, onComplete?: any): LoadingItems;
        /**
         * @en Retrieve the LoadingItems queue object for an item.
         * @zh 通过 item 对象获取它的 LoadingItems 队列。
         * @param item The item to query
         * @return The LoadingItems queue object
         */
        static getQueue(item: IItem): LoadingItems | null;
        /**
         * @en Complete an item in the LoadingItems queue, please do not call this method unless you know what's happening.
         * @zh 通知 LoadingItems 队列一个 item 对象已完成，请不要调用这个函数，除非你知道自己在做什么。
         * @param item The item which has completed
         */
        static itemComplete(item: IItem): void;
        static initQueueDeps(queue: any): void;
        static registerQueueDep(owner: any, depId: any): false | undefined;
        static finishDep(depId: any): void;
        /**
         * @en Add urls to the LoadingItems queue.
         * @zh 向一个 LoadingItems 队列添加加载项。
         * @param urlList 要追加的url列表，url可以是对象或字符串
         * @param owner
         * @return 在已接受的url列表中，可以拒绝某些无效项
         */
        append(urlList: object[], owner?: any): IItem[];
        _childOnProgress(item: any): void;
        /**
         * @en Complete a LoadingItems queue, please do not call this method unless you know what's happening.
         * @zh 完成一个 LoadingItems 队列，请不要调用这个函数，除非你知道自己在做什么。
         */
        allComplete(): void;
        /**
         * @en Check whether all items are completed.
         * @zh 检查是否所有加载项都已经完成。
         */
        isCompleted(): boolean;
        /**
         * @en Check whether an item is completed.
         * @zh 通过 id 检查指定加载项是否已经加载完成。
         * @param id The item's id.
         */
        isItemCompleted(id: string): boolean;
        /**
         * @en Check whether an item exists.
         * @zh 通过 id 检查加载项是否存在。
         * @param id The item's id.
         */
        exists(id: string): boolean;
        /**
         * @en Returns the content of an internal item.
         * @zh 通过 id 获取指定对象的内容。
         * @param id The item's id.
         */
        getContent(id: string): any;
        /**
         * @en Returns the error of an internal item.
         * @zh 通过 id 获取指定对象的错误信息。
         * @param id The item's id.
         */
        getError(id: string): any;
        /**
         * @en Remove an item, can only remove completed item, ongoing item can not be removed.
         * @zh 移除加载项，这里只会移除已经完成的加载项，正在进行的加载项将不能被删除。
         * @param url
         */
        removeItem(url: string): void;
        /**
         * @en Complete an item in the LoadingItems queue, please do not call this method unless you know what's happening.
         * @zh 通知 LoadingItems 队列一个 item 对象已完成，请不要调用这个函数，除非你知道自己在做什么。
         * @param id The item url
         */
        itemComplete(id: string): void;
        /**
         * @en Destroy the LoadingItems queue, the queue object won't be garbage collected, it will be recycled, so every after destroy is not reliable.
         * @zh 销毁一个 LoadingItems 队列，这个队列对象会被内部缓冲池回收，所以销毁后的所有内部信息都是不可依赖的。
         */
        destroy(): void;
        /**
         * @en Add a listener for an item, the callback will be invoked when the item is completed.
         * @zh 监听加载项（通过 key 指定）的完成事件。
         * @param key - The item key
         * @param callback - Callback function when item loaded
         * @param target - Callback callee
         */
        addListener(key: string, callback: Function, target?: any): Function;
        /**
         * @en
         * Check if the specified key has any registered callback.
         * If a callback is also specified, it will only return true if the callback is registered.
         * @zh
         * 检查指定的加载项是否有完成事件监听器。
         * 如果同时还指定了一个回调方法，并且回调有注册，它只会返回 true。
         * @param key - The item key
         * @param callback - Callback function when item loaded
         * @param target - Callback callee
         * @return Whether the corresponding listener for the item is registered
         */
        hasListener(key: string, callback?: Function, target?: any): boolean;
        /**
         * @en
         * Removes a listener.
         * It will only remove when key, callback, target all match correctly.
         * @zh
         * 移除指定加载项已经注册的完成事件监听器。
         * 只会删除 key, callback, target 均匹配的监听器。
         * @param key - The item key
         * @param callback - Callback function when item loaded
         * @param target - Callback callee
         */
        removeListener(key: string, callback?: Function, target?: any): void;
        /**
         * @en Removes all callbacks registered in a certain event
         * type or all callbacks registered with a certain target.
         * @zh 删除指定目标的所有完成事件监听器。
         * @param {String|Object} key - The item key to be removed or the target to be removed
         */
        removeAllListeners(key: any): void;
    }
}
declare module "cocos/core/load-pipeline/pipeline" {
    import { IItem } from "cocos/core/load-pipeline/loading-items";
    export interface IPipe {
        id: string;
        async: boolean;
        handle(item: IItem, callback: any): any;
        next?: IPipe | null;
        pipeline?: Pipeline | null;
    }
    /**
     * @en
     * A pipeline describes a sequence of manipulations, each manipulation is called a pipe.<br/>
     * It's designed for loading process. so items should be urls, and the url will be the identity of each item during the process.<br/>
     * A list of items can flow in the pipeline and it will output the results of all pipes.<br/>
     * They flow in the pipeline like water in tubes, they go through pipe by pipe separately.<br/>
     * Finally all items will flow out the pipeline and the process is finished.
     *
     * @zh
     * pipeline 描述了一系列的操作，每个操作都被称为 pipe。<br/>
     * 它被设计来做加载过程的流程管理。所以 item 应该是 url，并且该 url 将是在处理中的每个 item 的身份标识。<br/>
     * 一个 item 列表可以在 pipeline 中流动，它将输出加载项经过所有 pipe 之后的结果。<br/>
     * 它们穿过 pipeline 就像水在管子里流动，将会按顺序流过每个 pipe。<br/>
     * 最后当所有加载项都流出 pipeline 时，整个加载流程就结束了。
     */
    export class Pipeline {
        /**
         * @en The item states of the LoadingItems, its value could be {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
         * @zh LoadingItems 队列中的加载项状态，状态的值可能是 {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
         */
        static ItemState: any;
        protected _pipes: Array<IPipe>;
        _cache: any;
        /**
         * @en The constructor of the Pipeline, the order of pipes will remain as given.
         * A pipe is an {{IPipe}} object which must have an `id` and a `handle` function, the `id` must be unique.
         * It should also include an `async` property to identify whether the pipe's `handle` function is asynchronous.
         * @zh 构造函数，通过一系列的 pipe 来构造一个新的 pipeline，pipes 将会在给定的顺序中被锁定。<br/>
         * 一个 pipe 就是一个对象，它包含了字符串类型的 ‘id’ 和 ‘handle’ 函数，在 pipeline 中 id 必须是唯一的。<br/>
         * 它还可以包括 ‘async’ 属性以确定它是否是一个异步过程。
         * @param pipes All pipes for constructing the pipeline
         * @example
         * ```
         *  let pipeline = new Pipeline([
         *      {
         *          id: 'Downloader',
         *          handle: function (item, callback) {},
         *          async: true
         *      },
         *      {id: 'Parser', handle: function (item) {}, async: false}
         *  ]);
         * ```
         */
        constructor(pipes: IPipe[]);
        /**
         * @en Insert a new pipe at the given index of the pipeline. <br/>
         * A pipe must contain an `id` in string and a `handle` function, the id must be unique in the pipeline.
         * @zh 在给定的索引位置插入一个新的 pipe。<br/>
         * 一个 pipe 必须包含一个字符串类型的 ‘id’ 和 ‘handle’ 函数，该 id 在 pipeline 必须是唯一标识。
         * @param pipe The pipe to be inserted
         * @param index The index to insert
         */
        insertPipe(pipe: IPipe, index: number): void;
        /**
         * @en Insert a pipe to the end of an existing pipe. The existing pipe must be a valid pipe in the pipeline.
         * @zh 在当前 pipeline 的一个已知 pipe 后面插入一个新的 pipe。
         * @param refPipe An existing pipe in the pipeline.
         * @param newPipe The pipe to be inserted.
         */
        insertPipeAfter(refPipe: IPipe, newPipe: IPipe): void;
        /**
         * @en Add a new pipe at the end of the pipeline. <br/>
         * A pipe must contain an `id` in string and a `handle` function, the id must be unique in the pipeline.
         * @zh 添加一个新的 pipe 到 pipeline 尾部。 <br/>
         * 该 pipe 必须包含一个字符串类型 ‘id’ 和 ‘handle’ 函数，该 id 在 pipeline 必须是唯一标识。
         * @param pipe The pipe to be appended
         */
        appendPipe(pipe: IPipe): void;
        /**
         * @en
         * Let new items flow into the pipeline. <br/>
         * Each item can be a simple url string or an object,
         * if it's an object, it must contain `id` property. <br/>
         * You can specify its type by `type` property, by default, the type is the extension name in url. <br/>
         * By adding a `skips` property including pipe ids, you can skip these pipe. <br/>
         * The object can contain any supplementary property as you want. <br/>
         * @zh
         * 让新的 item 流入 pipeline 中。<br/>
         * 这里的每个 item 可以是一个简单字符串类型的 url 或者是一个对象,
         * 如果它是一个对象的话，他必须要包含 ‘id’ 属性。<br/>
         * 你也可以指定它的 ‘type’ 属性类型，默认情况下，该类型是 ‘url’ 的后缀名。<br/>
         * 也通过添加一个 包含 ‘skips’ 属性的 item 对象，你就可以跳过 skips 中包含的 pipe。<br/>
         * 该对象可以包含任何附加属性。
         * @param items The {{IItem}} to be appended to the current pipeline
         * @example
         * ```
         *  pipeline.flowIn([
         *      'res/Background.png',
         *      {
         *          id: 'res/scene.json',
         *          type: 'scene',
         *          name: 'scene',
         *          skips: ['Downloader']
         *      }
         *  ]);
         * ```
         */
        flowIn(items: Array<IItem>): void;
        /**
         * @en
         * Let new items flow into the pipeline and give a callback when the list of items are all completed. <br/>
         * This is for loading dependencies for an existing item in flow, usually used in a pipe logic. <br/>
         * For example, we have a loader for scene configuration file in JSON, the scene will only be fully loaded  <br/>
         * after all its dependencies are loaded, then you will need to use function to flow in all dependencies  <br/>
         * found in the configuration file, and finish the loader pipe only after all dependencies are loaded (in the callback).
         * @zh
         * 让新 items 流入 pipeline 并且当 item 列表完成时进行回调函数。<br/>
         * 这个 API 的使用通常是为了加载依赖项。<br/>
         * 例如：<br/>
         * 我们需要加载一个场景配置的 JSON 文件，该场景会将所有的依赖项全部都加载完毕以后，进行回调表示加载完毕。
         * @param owner The owner item
         * @param urlList The list of urls to be appended as dependencies of the owner.
         * @param callback The callback to be invoked when all dependencies are completed.
         * @return Items accepted by the pipeline
         */
        flowInDeps(owner: IItem, urlList: object[], callback: Function): IItem[];
        /**
         * @en This function is invoked when an item has completed all pipes, it will flow out of the pipeline.
         * @zh 这个函数会在 `item` 完成了所有管道，它会被标记为 `complete` 并流出管线。
         * @param item The item which is completed
         */
        flowOut(item: IItem): void;
        /**
         * @en
         * Copy the item states from one source item to all destination items. <br/>
         * It's quite useful when a pipe generate new items from one source item,<br/>
         * then you should flowIn these generated items into pipeline, <br/>
         * but you probably want them to skip all pipes the source item already go through,<br/>
         * you can achieve it with this API. <br/>
         * <br/>
         * For example, an unzip pipe will generate more items, but you won't want them to pass unzip or download pipe again.
         * @zh
         * 从一个源 item 向所有目标 item 复制它的 pipe 状态，用于避免重复通过部分 pipe。<br/>
         * 当一个源 item 生成了一系列新的 items 时很有用，<br/>
         * 你希望让这些新的依赖项进入 pipeline，但是又不希望它们通过源 item 已经经过的 pipe，<br/>
         * 但是你可能希望他们源 item 已经通过并跳过所有 pipes，<br/>
         * 这个时候就可以使用这个 API。
         * @param srcItem The source item
         * @param dstItems A single destination item or an array of destination items
         */
        copyItemStates(srcItem: IItem, dstItems: IItem | Array<IItem>): void;
        /**
         * @en Returns an item in pipeline.
         * @zh 根据 id 获取一个 item
         * @param id The id of the item
         */
        getItem(id: string): IItem | null;
        /**
         * @en Removes an completed item in pipeline.
         * It will only remove the cache in the pipeline or loader, its dependencies won't be released.
         * `loader` provided another method to completely cleanup the resource and its dependencies,
         * please refer to {{Loader.release}}
         * @zh 移除指定的已完成 item。
         * 这将仅仅从 pipeline 或者 loader 中删除其缓存，并不会释放它所依赖的资源。
         * `loader` 中提供了另一种删除资源及其依赖的清理方法，请参考 {{Loader.release}}
         * @param id The id of the item
         * @return succeed or not
         */
        removeItem(id: string): boolean;
        /**
         * @en Clear the current pipeline, this function will clean up the items.
         * @zh 清空当前 pipeline，该函数将清理 items。
         */
        clear(): void;
    }
}
declare module "cocos/core/load-pipeline/md5-pipe" {
    /**
     * @category loader
     */
    import { IPipe } from "cocos/core/load-pipeline/pipeline";
    /**
     * @en The md5 pipe in {{loader}}, it can transform the url to the real url with md5 suffix
     * @zh {{loader}} 中的 md5 管道，可以将资源 url 转换到包含 md5 后缀版本
     */
    export default class MD5Pipe implements IPipe {
        static ID: string;
        id: string;
        async: boolean;
        pipeline: null;
        md5AssetsMap: any;
        md5NativeAssetsMap: any;
        libraryBase: any;
        constructor(md5AssetsMap: any, md5NativeAssetsMap: any, libraryBase: any);
        handle(item: any): any;
        /**
         * @en Transform an url to the real url with md5 suffix
         * @zh 将一个 url 转换到包含 md5 后缀版本
         * @param url The url to be parsed
         * @param hashPatchInFolder NA
         */
        transformURL(url: any, hashPatchInFolder?: boolean): any;
    }
}
declare module "cocos/core/load-pipeline/unpackers" {
    export class JsonUnpacker {
        jsons: {};
        load(indices: any, packedJson: any): void;
        retrieve(key: any): any;
    }
    export class TextureUnpacker {
        contents: {};
        load(indices: any, packedJson: any): void;
        retrieve(key: any): {
            __type__: any;
            content: any;
        } | null;
    }
}
declare module "cocos/core/load-pipeline/utils" {
    export function urlAppendTimestamp(url: any): any;
    export function decompressJson(data: any, keys: any): null;
}
declare module "cocos/core/load-pipeline/pack-downloader" {
    export function initPacks(packs: any): void;
    export function _loadNewPack(uuid: any, packUuid: any, callback: any): void;
    export function _doPreload(packUuid: any, packJson: any): void;
    export function _doLoadNewPack(uuid: any, packUuid: any, packedJson: any): any;
    export function _selectLoadedPack(packUuids: any): any;
    /**
     * @returns {Object} When returns undefined, the requested item is not in any pack, when returns null, the item is in a loading pack, when item json exists, it will return the result directly.
     */
    export function load(item: any, callback: any): any;
}
declare module "cocos/core/load-pipeline/subpackage-pipe" {
    import { IPipe } from "cocos/core/load-pipeline/pipeline";
    export class SubPackPipe implements IPipe {
        static ID: string;
        id: string;
        async: boolean;
        pipeline: null;
        constructor(subpackage: any);
        handle(item: any): null;
        transformURL(url: any): any;
    }
}
declare module "cocos/core/assets/asset-library" {
    /**
     * 管理项目中加载/卸载资源的资源库。
     * @class AssetLibrary
     * @static
     */
    const AssetLibrary: {
        /**
         * 这里保存所有已经加载的场景资源，防止同一个资源在内存中加载出多份拷贝。
         *
         * 这里用不了WeakMap，在浏览器中所有加载过的资源都只能手工调用 unloadAsset 释放。
         *
         * 参考：
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap
         * https://github.com/TooTallNate/node-weak
         *
         * @private
         */
        _uuidToAsset: {};
        /**
         * @callback loadCallback
         * @param {String} error - null or the error info
         * @param {Asset} data - the loaded asset or null
         */
        /**
         * @zh
         * 加载资源。
         * @param {String} uuid
         * @param {loadCallback} callback - 加载完成后执行的回调函数。
         * @param {Object} options
         * @param {Boolean} options.readMainCache - 默认为true。如果为false，则资源及其所有依赖资源将重新加载并从库中创建新实例。
         * @param {Boolean} options.writeMainCache - 默认为true。如果为true，则结果将缓存到 AssetLibrary，并且必须由用户手动卸载。
         * @param {Asset} options.existingAsset - 加载现有资源，此参数仅在编辑器中可用。
         */
        loadAsset(uuid: String, callback: Function, options?: any): void;
        /**
         * @zh
         * 获取资源的 url。
         */
        getLibUrlNoExt(uuid: any, inRawAssetsDir?: boolean | undefined): string;
        /**
         * @zh
         * 在编辑器中查询资源信息。
         * @param uuid 资源的 uuid。
         * @protected
         */
        _queryAssetInfoInEditor(uuid: any, callback: any): void;
        /**
         * @zh
         * 在运行时获取资源信息。
         */
        _getAssetInfoInRuntime(uuid: any, result?: any): any;
        /**
         * @zh
         * 在 setting 中的 uuid。
         */
        _uuidInSettings(uuid: any): boolean;
        /**
         * @zh
         * 获取资源信息。
         * @param {String} uuid 资源的 uuid。
         * @param {Function} callback
         * @param {Error} callback.error
         * @param {String} callback.url - the url of raw asset or imported asset
         * @param {Boolean} callback.raw - indicates whether the asset is raw asset
         * @param {Function} callback.ctorInEditor - the actual type of asset, used in editor only
         */
        queryAssetInfo(uuid: any, callback: any): void;
        /**
         * @en
         * parse uuid out of url
         * @zh
         * 从 url 解析 uuid。
         * @param url 资源地址。
         */
        parseUuidInEditor(url: any): string | undefined;
        /**
         * @zh
         * 加载 json。
         * @param {String} json
         * @param {loadCallback} callback
         * @return {LoadingHandle}
         * @private
         */
        loadJson(json: any, callback: any): void;
        /**
         * @en
         * Get the exists asset by uuid.
         * @zh
         * 根据 uuid 获取存在的资源。
         * @param {String} uuid
         * @return {Asset} - 返回存在的资源，若没有加载则返回 null
         * @private
         */
        getAssetByUuid(uuid: any): any;
        /**
         * @en
         * init the asset library
         * @zh
         * 初始化 AssetLibrary。
         * @method init
         * @param {Object} options
         * @param {String} options.libraryPath - 能接收的任意类型的路径，通常在编辑器里使用绝对的，在网页里使用相对的。
         * @param {Object} options.mountPaths - mount point of actual urls for raw assets (only used in editor)
         * @param {Object} [options.rawAssets] - uuid to raw asset's urls (only used in runtime)
         * @param {String} [options.rawAssetsBase] - base of raw asset's urls (only used in runtime)
         * @param {String} [options.packedAssets] - packed assets (only used in runtime)
         */
        init(options: any): void;
    };
    export default AssetLibrary;
}
declare module "cocos/physics/framework/physics-config" {
    import { IVec3Like } from "cocos/core/index";
    export interface ICollisionMatrix {
        [x: string]: number;
    }
    export interface IPhysicsMaterial {
        friction: number;
        rollingFriction: number;
        spinningFriction: number;
        restitution: number;
    }
    export interface IPhysicsConfig {
        gravity: IVec3Like;
        allowSleep: boolean;
        fixedTimeStep: number;
        maxSubSteps: number;
        sleepThreshold: number;
        collisionMatrix: ICollisionMatrix;
        defaultMaterial: IPhysicsMaterial;
        autoSimulation: boolean;
        useCollsionMatrix: boolean;
        useNodeChains: boolean;
        physicsEngine: 'builtin' | 'cannon.js' | 'ammo.js' | string;
    }
}
declare module "cocos/core/splash-screen" {
    import { Root } from "cocos/core/root";
    import { GFXColor } from "cocos/core/gfx/define";
    export type SplashEffectType = 'NONE' | 'FADE-INOUT';
    export interface ISplashSetting {
        readonly totalTime: number;
        readonly base64src: string;
        readonly effect: SplashEffectType;
        readonly clearColor: GFXColor;
        readonly displayRatio: number;
        readonly displayWatermark: boolean;
    }
    export class SplashScreen {
        private set splashFinish(value);
        set loadFinish(v: boolean);
        private handle;
        private callBack;
        private cancelAnimate;
        private startTime;
        private setting;
        private image;
        private root;
        private device;
        private sampler;
        private cmdBuff;
        private assmebler;
        private vertexBuffers;
        private indicesBuffers;
        private shader;
        private framebuffer;
        private renderArea;
        private region;
        private material;
        private texture;
        private clearColors;
        private _splashFinish;
        private _loadFinish;
        private _directCall;
        /** text */
        private textImg;
        private textRegion;
        private textTexture;
        private textVB;
        private textIB;
        private textAssmebler;
        private textMaterial;
        private textShader;
        private screenWidth;
        private screenHeight;
        main(root: Root): void;
        setOnFinish(cb: Function): any;
        private _tryToStart;
        private init;
        private hide;
        private frame;
        private initText;
        private initCMD;
        private initIA;
        private initPSO;
        private destroy;
        private static _ins;
        static get instance(): SplashScreen;
        private constructor();
    }
}
declare module "cocos/core/game" {
    import { EventTarget } from "cocos/core/event/event-target";
    import { GFXDevice } from "cocos/core/gfx/index";
    import { ICustomJointTextureLayout } from "cocos/core/renderer/models/index";
    import { IPhysicsConfig } from "cocos/physics/framework/physics-config";
    /**
     * @zh
     * AssetLibrary 配置。
     * @en
     * AssetLibrary configuration.
     */
    export interface IAssetOptions {
        /**
         * @zh
         * 导入 Library 的资源根目录（相对于构建目录）
         * @en
         * The root path (relative to the build destination folder) of the imported library assets
         */
        libraryPath: string;
        /**
         * @zh
         * RawAssets 类资源的根目录前缀（相对于构建目录），
         * 这个路径尾部和 "assets" 拼接后就是完整路径
         * @en
         * The prefix of the root path (relative to the build destination folder) of the raw assets,
         * This will be joint with "assets" to form the complete path
         */
        rawAssetsBase: string;
        /**
         * @zh
         * RawAssets 列表，从 Settings 中获取
         * @en
         * The list of raw assets, normally retrieved from Settings
         */
        rawAssets: object;
        /**
         * @zh
         * 合并后的资源合集列表
         * @en
         * The list of asset packs
         */
        packedAssets?: object;
        /**
         * @zh
         * 资源及其 md5 前缀关系
         * @en
         * The map of assets and their md5 prefix
         */
        md5AssetsMap?: object;
        /**
         * @zh
         * 子包列表
         * @en
         * The list of sub packages
         */
        subPackages?: [];
    }
    interface ISceneInfo {
        url: string;
        uuid: string;
    }
    /**
     * @zh
     * 游戏配置。
     * @en
     * Game configuration.
     */
    export interface IGameConfig {
        /**
         * @zh
         * 设置 debug 模式，在浏览器中这个选项会被忽略。
         * 各种设置选项的意义：
         *  - 0 - 没有消息被打印出来。
         *  - 1 - `error`，`assert`，`warn`，`log` 将打印在 console 中。
         *  - 2 - `error`，`assert`，`warn` 将打印在 console 中。
         *  - 3 - `error`，`assert` 将打印在 console 中。
         *  - 4 - `error`，`assert`，`warn`，`log` 将打印在 canvas 中（仅适用于 web 端）。
         *  - 5 - `error`，`assert`，`warn` 将打印在 canvas 中（仅适用于 web 端）。
         *  - 6 - `error`，`assert` 将打印在 canvas 中（仅适用于 web 端）。
         * @en
         * Set debug mode, only valid in non-browser environment.
         * Possible values:
         * 0 - No message will be printed.
         * 1 - `error`，`assert`，`warn`，`log` will print in console.
         * 2 - `error`，`assert`，`warn` will print in console.
         * 3 - `error`，`assert` will print in console.
         * 4 - `error`，`assert`，`warn`，`log` will print on canvas, available only on web.
         * 5 - `error`，`assert`，`warn` will print on canvas, available only on web.
         * 6 - `error`，`assert` will print on canvas, available only on web.
         */
        debugMode?: 0 | 1 | 2 | 3 | 4 | 5 | 6;
        /**
         * @zh
         * 当 showFPS 为 true 的时候界面的左下角将显示 fps 的信息，否则被隐藏。
         * @en
         * Left bottom corner fps information will show when "showFPS" equals true, otherwise it will be hide.
         */
        showFPS?: boolean;
        /**
         * @zh
         * 暴露类名让 Chrome DevTools 可以识别，如果开启会稍稍降低类的创建过程的性能，但对对象构造没有影响。
         * @en
         * Expose class name to chrome debug tools, the class intantiate performance is a little bit slower when exposed.
         */
        exposeClassName?: boolean;
        /**
         * @zh
         * 设置想要的帧率你的游戏，但真正的FPS取决于你的游戏实现和运行环境。
         * @en
         * Set the wanted frame rate for your game, but the real fps depends on your game implementation and the running environment.
         */
        frameRate?: number;
        /**
         * @zh
         * Web 页面上的 Canvas Element ID，仅适用于 web 端。
         * @en
         * Sets the id of your canvas element on the web page, it's useful only on web.
         */
        id?: string | HTMLElement;
        /**
         * @zh
         * 渲染模式。
         * 设置渲染器类型，仅适用于 web 端：
         * - 0 - 通过引擎自动选择。
         * - 1 - 强制使用 canvas 渲染。
         * - 2 - 强制使用 WebGL 渲染，但是在部分 Android 浏览器中这个选项会被忽略。
         * @en
         * Sets the renderer type, only useful on web:
         * - 0 - Automatically chosen by engine.
         * - 1 - Forced to use canvas renderer.
         * - 2 - Forced to use WebGL renderer, but this will be ignored on mobile browsers.
         */
        renderMode?: 0 | 1 | 2;
        /**
         * @zh
         * 当前包中可用场景。
         * @en
         * Include available scenes in the current bundle.
         */
        scenes?: ISceneInfo[];
        /**
         * For internal use.
         */
        registerSystemEvent?: boolean;
        /**
         * For internal use.
         */
        collisionMatrix?: never[];
        /**
         * For internal use.
         */
        groupList?: any[];
        /**
         * For internal use.
         */
        jsList?: string[];
        /**
         * Render pipeline resources
         */
        renderPipeline?: string;
        /**
         * Asset library initialization options
         */
        assetOptions?: IAssetOptions;
        /**
         * GPU instancing options
         */
        customJointTextureLayouts?: ICustomJointTextureLayout[];
        /**
         * Physics system config
         */
        physics?: IPhysicsConfig;
    }
    /**
     * @en An object to boot the game.
     * @zh 包含游戏主体信息并负责驱动游戏的游戏对象。
     * @class game
     * @static
     */
    export class Game extends EventTarget {
        /**
         * @en Event triggered when game hide to background.<br>
         * Please note that this event is not 100% guaranteed to be fired on Web platform,<br>
         * on native platforms, it corresponds to enter background event, os status bar or notification center may not trigger this event.
         * @zh 游戏进入后台时触发的事件。<br>
         * 请注意，在 WEB 平台，这个事件不一定会 100% 触发，这完全取决于浏览器的回调行为。<br>
         * 在原生平台，它对应的是应用被切换到后台事件，下拉菜单和上拉状态栏等不一定会触发这个事件，这取决于系统行为。
         * @example
         * ```ts
         * import { game, audioEngine } from 'cc';
         * game.on(Game.EVENT_HIDE, function () {
         *     audioEngine.pauseMusic();
         *     audioEngine.pauseAllEffects();
         * });
         * ```
         */
        static EVENT_HIDE: string;
        /**
         * @en Event triggered when game back to foreground<br>
         * Please note that this event is not 100% guaranteed to be fired on Web platform,<br>
         * on native platforms, it corresponds to enter foreground event.
         * @zh 游戏进入前台运行时触发的事件。<br>
         * 请注意，在 WEB 平台，这个事件不一定会 100% 触发，这完全取决于浏览器的回调行为。<br>
         * 在原生平台，它对应的是应用被切换到前台事件。
         */
        static readonly EVENT_SHOW: string;
        /**
         * @en Event triggered after game inited, at this point all engine objects and game scripts are loaded
         * @zh 游戏启动后的触发事件，此时加载所有的引擎对象和游戏脚本。
         */
        static EVENT_GAME_INITED: string;
        /**
         * @en Event triggered after engine inited, at this point you will be able to use all engine classes.<br>
         * It was defined as EVENT_RENDERER_INITED in cocos creator v1.x and renamed in v2.0.
         * In cocos creator 3d, EVENT_RENDERER_INITED is a new event, look up define for details.
         * @zh 在引擎初始化之后触发的事件，此时您能够使用引擎所有的类。<br>
         * 它在 cocos creator v1.x 版本中名字为 EVENT_RENDERER_INITED ,在 v2.0 版本中更名为 EVENT_ENGINE_INITED
         * 并在 cocos creator 3d 版本中将 EVENT_RENDERER_INITED 用作为渲染器初始化的事件。
         */
        static EVENT_ENGINE_INITED: string;
        /**
         * @en Event triggered after renderer inited, at this point you will be able to use all gfx renderer feature.<br>
         * @zh 在渲染器初始化之后触发的事件，此事件在 EVENT_ENGINE_INITED 之前触发，此时开始可使用 gfx 渲染框架。
         */
        static readonly EVENT_RENDERER_INITED: string;
        /**
         * @en Event triggered when game restart
         * @zh 调用restart后，触发事件
         */
        static EVENT_RESTART: string;
        /**
         * @en Web Canvas 2d API as renderer backend.
         * @zh 使用 Web Canvas 2d API 作为渲染器后端。
         */
        static RENDER_TYPE_CANVAS: number;
        /**
         * @en WebGL API as renderer backend.
         * @zh 使用 WebGL API 作为渲染器后端。
         */
        static RENDER_TYPE_WEBGL: number;
        /**
         * @en OpenGL API as renderer backend.
         * @zh 使用 OpenGL API 作为渲染器后端。
         */
        static RENDER_TYPE_OPENGL: number;
        /**
         * @en The outer frame of the game canvas; parent of game container.
         * @zh 游戏画布的外框，container 的父容器。
         */
        frame: Object | null;
        /**
         * @en The container of game canvas.
         * @zh 游戏画布的容器。
         */
        container: HTMLDivElement | null;
        /**
         * @en The canvas of the game.
         * @zh 游戏的画布。
         */
        canvas: HTMLCanvasElement | null;
        /**
         * @en The renderer backend of the game.
         * @zh 游戏的渲染器类型。
         */
        renderType: number;
        eventTargetOn: <TFunction extends Function>(type: string, callback: TFunction, thisArg?: any, once?: boolean | undefined) => TFunction;
        eventTargetOnce: <TFunction extends Function>(type: string, callback: TFunction, thisArg?: any) => TFunction;
        /**
         * @en
         * The current game configuration,
         * please be noticed any modification directly on this object after the game initialization won't take effect.
         * @zh
         * 当前的游戏配置
         * 注意：请不要直接修改这个对象，它不会有任何效果。
         */
        config: IGameConfig;
        /**
         * @en Callback when the scripts of engine have been load.
         * @zh 当引擎完成启动后的回调函数。
         * @method onStart
         */
        onStart: Function | null;
        /**
         * @en Indicates whether the engine has inited
         * @zh 引擎是否以完成初始化
         */
        get inited(): boolean;
        _persistRootNodes: {};
        _paused: boolean;
        _configLoaded: boolean;
        _isCloning: boolean;
        _inited: boolean;
        _rendererInitialized: boolean;
        _gfxDevice: GFXDevice | null;
        _intervalId: number | null;
        _lastTime: Date | null;
        _frameTime: number | null;
        _sceneInfos: ISceneInfo[];
        collisionMatrix: never[];
        groupList: any[];
        /**
         * @en Set frame rate of game.
         * @zh 设置游戏帧率。
         * @param {Number} frameRate
         */
        setFrameRate(frameRate: number): void;
        /**
         * @en Get frame rate set for the game, it doesn't represent the real frame rate.
         * @zh 获取设置的游戏帧率（不等同于实际帧率）。
         * @return {Number} frame rate
         */
        getFrameRate(): number;
        /**
         * @en Run the game frame by frame.
         * @zh 执行一帧游戏循环。
         */
        step(): void;
        /**
         * @en Pause the game main loop. This will pause:<br>
         * game logic execution, rendering process, event manager, background music and all audio effects.<br>
         * This is different with `director.pause` which only pause the game logic execution.<br>
         * @zh 暂停游戏主循环。包含：游戏逻辑，渲染，事件处理，背景音乐和所有音效。这点和只暂停游戏逻辑的 `director.pause` 不同。
         */
        pause(): void;
        /**
         * @en Resume the game from pause. This will resume:<br>
         * game logic execution, rendering process, event manager, background music and all audio effects.<br>
         * @zh 恢复游戏主循环。包含：游戏逻辑，渲染，事件处理，背景音乐和所有音效。
         */
        resume(): void;
        /**
         * @en Check whether the game is paused.
         * @zh 判断游戏是否暂停。
         * @return {Boolean}
         */
        isPaused(): boolean;
        /**
         * @en Restart game.
         * @zh 重新开始游戏
         */
        restart(): void;
        /**
         * @en End game, it will close the game window
         * @zh 退出游戏
         */
        end(): void;
        /**
         * @en
         * Register an callback of a specific event type on the game object.<br>
         * This type of event should be triggered via `emit`.<br>
         * @zh
         * 注册 game 的特定事件类型回调。这种类型的事件应该被 `emit` 触发。<br>
         *
         * @param {String} type - A string representing the event type to listen for.
         * @param {Function} callback - The callback that will be invoked when the event is dispatched.<br>
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param {any} [callback.arg1] arg1
         * @param {any} [callback.arg2] arg2
         * @param {any} [callback.arg3] arg3
         * @param {any} [callback.arg4] arg4
         * @param {any} [callback.arg5] arg5
         * @param {Object} [target] - The target (this object) to invoke the callback, can be null
         * @return {Function} - Just returns the incoming callback so you can save the anonymous function easier.
         */
        on(type: string, callback: Function, target?: object, once?: boolean): any;
        /**
         * @en
         * Register an callback of a specific event type on the game object,<br>
         * the callback will remove itself after the first time it is triggered.<br>
         * @zh
         * 注册 game 的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param {String} type - A string representing the event type to listen for.
         * @param {Function} callback - The callback that will be invoked when the event is dispatched.<br>
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param {any} [callback.arg1] arg1
         * @param {any} [callback.arg2] arg2
         * @param {any} [callback.arg3] arg3
         * @param {any} [callback.arg4] arg4
         * @param {any} [callback.arg5] arg5
         * @param {Object} [target] - The target (this object) to invoke the callback, can be null
         */
        once(type: string, callback: Function, target?: object): void;
        /**
         * @en Init game with configuration object.
         * @zh 使用指定的配置初始化引擎。
         * @param {Object} config - Pass configuration object
         */
        init(config: IGameConfig): boolean;
        /**
         * @en Run game with configuration object and onStart function.
         * @zh 运行游戏，并且指定引擎配置和 onStart 的回调。
         * @param {Function} onStart - function to be executed after game initialized
         */
        run(onStart: Function | null, legacyOnStart?: Function | null): void;
        /**
         * @en
         * Add a persistent root node to the game, the persistent node won't be destroyed during scene transition.<br>
         * The target node must be placed in the root level of hierarchy, otherwise this API won't have any effect.
         * @zh
         * 声明常驻根节点，该节点不会被在场景切换中被销毁。<br>
         * 目标节点必须位于为层级的根节点，否则无效。
         * @param {Node} node - The node to be made persistent
         */
        addPersistRootNode(node: {
            uuid: any;
            parent: any;
            _persistNode: boolean;
        }): void;
        /**
         * @en Remove a persistent root node.
         * @zh 取消常驻根节点。
         * @param {Node} node - The node to be removed from persistent node list
         */
        removePersistRootNode(node: {
            uuid: string;
            _persistNode: boolean;
        }): void;
        /**
         * @en Check whether the node is a persistent root node.
         * @zh 检查节点是否是常驻根节点。
         * @param {Node} node - The node to be checked
         * @return {Boolean}
         */
        isPersistRootNode(node: {
            _persistNode: any;
        }): any;
        private _initEngine;
        private _setAnimFrame;
        private _stTime;
        private _ctTime;
        private _runMainLoop;
        private _initConfig;
        private _determineRenderType;
        private _initDevice;
        private _initEvents;
        private setRenderPipeline;
        private _safeEmit;
    }
    export const game: Game;
}
declare module "cocos/core/platform/visible-rect" {
    /**
     * @hidden
     */
    import { Rect } from "cocos/core/math/index";
    /**
     * `visibleRect` is a singleton object which defines the actual visible rect of the current view,
     * it should represent the same rect as `view.getViewportRect()`
     */
    const visibleRect: {
        /**
         * Top left coordinate of the screen related to the game scene.
         */
        topLeft: any;
        /**
         * Top right coordinate of the screen related to the game scene.
         */
        topRight: any;
        /**
         * Top center coordinate of the screen related to the game scene.
         */
        top: any;
        /**
         * Bottom left coordinate of the screen related to the game scene.
         */
        bottomLeft: any;
        /**
         * Bottom right coordinate of the screen related to the game scene.
         */
        bottomRight: any;
        /**
         * Bottom center coordinate of the screen related to the game scene.
         */
        bottom: any;
        /**
         * Center coordinate of the screen related to the game scene.
         */
        center: any;
        /**
         * Left center coordinate of the screen related to the game scene.
         */
        left: any;
        /**
         * Right center coordinate of the screen related to the game scene.
         */
        right: any;
        /**
         * Width of the screen.
         */
        width: number;
        /**
         * Height of the screen.
         */
        height: number;
        /**
         * initialize
         */
        init(visibleRect_: Rect): void;
    };
    export default visibleRect;
}
declare module "cocos/core/platform/view" {
    /**
     * @category core
     */
    import "cocos/core/data/class";
    import { EventTarget } from "cocos/core/event/event-target";
    import "cocos/core/game";
    import { Rect, Size, Vec2 } from "cocos/core/math/index";
    /**
     * @en View represents the game window.<br/>
     * It's main task include: <br/>
     *  - Apply the design resolution policy to the UI Canvas<br/>
     *  - Provide interaction with the window, like resize event on web, retina display support, etc...<br/>
     *  - Manage the scale and translation of canvas related to the frame on Web<br/>
     * <br/>
     * With {{view}} as its singleton initialized by the engine, you don't need to call any constructor or create functions,<br/>
     * the standard way to use it is by calling:<br/>
     *  - view.methodName(); <br/>
     * @zh View 代表游戏窗口视图，它的核心功能包括：
     *  - 对所有 UI Canvas 进行设计分辨率适配。
     *  - 提供窗口视图的交互，比如监听 resize 事件，控制 retina 屏幕适配，等等。
     *  - 控制 Canvas 节点相对于外层 DOM 节点的缩放和偏移。
     * 引擎会自动初始化它的单例对象 {{view}}，所以你不需要实例化任何 View，只需要直接使用 `view.methodName();`
     */
    export class View extends EventTarget {
        static instance: View;
        _resizeWithBrowserSize: boolean;
        _designResolutionSize: Size;
        _originalDesignResolutionSize: Size;
        private _frameSize;
        private _scaleX;
        private _scaleY;
        private _viewportRect;
        private _visibleRect;
        private _autoFullScreen;
        private _devicePixelRatio;
        private _maxPixelRatio;
        private _retinaEnabled;
        private _resizeCallback;
        private _resizing;
        private _orientationChanging;
        private _isRotated;
        private _orientation;
        private _isAdjustViewport;
        private _antiAliasEnabled;
        private _resolutionPolicy;
        private _rpExactFit;
        private _rpShowAll;
        private _rpNoBorder;
        private _rpFixedHeight;
        private _rpFixedWidth;
        constructor();
        init(): void;
        /**
         * @en
         * Sets whether resize canvas automatically when browser's size changed.<br/>
         * Useful only on web.
         * @zh 设置当发现浏览器的尺寸改变时，是否自动调整 canvas 尺寸大小。
         * 仅在 Web 模式下有效。
         * @param enabled - Whether enable automatic resize with browser's resize event
         */
        resizeWithBrowserSize(enabled: boolean): void;
        /**
         * @en
         * Sets the callback function for `view`'s resize action,<br/>
         * this callback will be invoked before applying resolution policy, <br/>
         * so you can do any additional modifications within the callback.<br/>
         * Useful only on web.
         * @zh 设置 `view` 调整视窗尺寸行为的回调函数，
         * 这个回调函数会在应用适配模式之前被调用，
         * 因此你可以在这个回调函数内添加任意附加改变，
         * 仅在 Web 平台下有效。
         * @param callback - The callback function
         */
        setResizeCallback(callback: Function | null): void;
        /**
         * @en
         * Sets the orientation of the game, it can be landscape, portrait or auto.
         * When set it to landscape or portrait, and screen w/h ratio doesn't fit,
         * `view` will automatically rotate the game canvas using CSS.
         * Note that this function doesn't have any effect in native,
         * in native, you need to set the application orientation in native project settings
         * @zh 设置游戏屏幕朝向，它能够是横版，竖版或自动。
         * 当设置为横版或竖版，并且屏幕的宽高比例不匹配时，
         * `view` 会自动用 CSS 旋转游戏场景的 canvas，
         * 这个方法不会对 native 部分产生任何影响，对于 native 而言，你需要在应用设置中的设置排版。
         * @param orientation - Possible values: macro.ORIENTATION_LANDSCAPE | macro.ORIENTATION_PORTRAIT | macro.ORIENTATION_AUTO
         */
        setOrientation(orientation: number): void;
        /**
         * @en
         * Sets whether the engine modify the "viewport" meta in your web page.<br/>
         * It's enabled by default, we strongly suggest you not to disable it.<br/>
         * And even when it's enabled, you can still set your own "viewport" meta, it won't be overridden<br/>
         * Only useful on web
         * @zh 设置引擎是否调整 viewport meta 来配合屏幕适配。
         * 默认设置为启动，我们强烈建议你不要将它设置为关闭。
         * 即使当它启动时，你仍然能够设置你的 viewport meta，它不会被覆盖。
         * 仅在 Web 模式下有效
         * @param enabled - Enable automatic modification to "viewport" meta
         */
        adjustViewportMeta(enabled: boolean): void;
        /**
         * @en
         * Retina support is enabled by default for Apple device but disabled for other devices,<br/>
         * it takes effect only when you called setDesignResolutionPolicy<br/>
         * Only useful on web
         * @zh 对于 Apple 这种支持 Retina 显示的设备上默认进行优化而其他类型设备默认不进行优化，
         * 它仅会在你调用 setDesignResolutionPolicy 方法时有影响。
         * 仅在 Web 模式下有效。
         * @param enabled - Enable or disable retina display
         */
        enableRetina(enabled: boolean): void;
        /**
         * @en
         * Check whether retina display is enabled.<br/>
         * Only useful on web
         * @zh 检查是否对 Retina 显示设备进行优化。
         * 仅在 Web 模式下有效。
         */
        isRetinaEnabled(): boolean;
        /**
         * @en Whether to Enable on anti-alias
         * @zh 控制抗锯齿是否开启
         * @param enabled - Enable or not anti-alias
         */
        enableAntiAlias(enabled: boolean): void;
        /**
         * @en Returns whether the current enable on anti-alias
         * @zh 返回当前是否抗锯齿
         */
        isAntiAliasEnabled(): boolean;
        /**
         * @en
         * If enabled, the application will try automatically to enter full screen mode on mobile devices<br/>
         * You can pass true as parameter to enable it and disable it by passing false.<br/>
         * Only useful on web
         * @zh 启动时，移动端游戏会在移动端自动尝试进入全屏模式。
         * 你能够传入 true 为参数去启动它，用 false 参数来关闭它。
         * @param enabled - Enable or disable auto full screen on mobile devices
         */
        enableAutoFullScreen(enabled: boolean): void;
        /**
         * @en
         * Check whether auto full screen is enabled.<br/>
         * Only useful on web
         * @zh 检查自动进入全屏模式是否启动。
         * 仅在 Web 模式下有效。
         * @return Auto full screen enabled or not
         */
        isAutoFullScreenEnabled(): boolean;
        setCanvasSize(width: number, height: number): void;
        /**
         * @en
         * Returns the canvas size of the view.<br/>
         * On native platforms, it returns the screen size since the view is a fullscreen view.<br/>
         * On web, it returns the size of the canvas element.
         * @zh 返回视图中 canvas 的尺寸。
         * 在 native 平台下，它返回全屏视图下屏幕的尺寸。
         * 在 Web 平台下，它返回 canvas 元素尺寸。
         */
        getCanvasSize(): Size;
        /**
         * @en
         * Returns the frame size of the view.<br/>
         * On native platforms, it returns the screen size since the view is a fullscreen view.<br/>
         * On web, it returns the size of the canvas's outer DOM element.
         * @zh 返回视图中边框尺寸。
         * 在 native 平台下，它返回全屏视图下屏幕的尺寸。
         * 在 web 平台下，它返回 canvas 元素的外层 DOM 元素尺寸。
         */
        getFrameSize(): Size;
        /**
         * @en On native, it sets the frame size of view.<br/>
         * On web, it sets the size of the canvas's outer DOM element.
         * @zh 在 native 平台下，设置视图框架尺寸。
         * 在 web 平台下，设置 canvas 外层 DOM 元素尺寸。
         * @param {Number} width
         * @param {Number} height
         */
        setFrameSize(width: number, height: number): void;
        /**
         * @en Returns the visible area size of the view port.
         * @zh 返回视图窗口可见区域尺寸。
         */
        getVisibleSize(): Size;
        /**
         * @en Returns the visible area size of the view port.
         * @zh 返回视图窗口可见区域像素尺寸。
         */
        getVisibleSizeInPixel(): Size;
        /**
         * @en Returns the visible origin of the view port.
         * @zh 返回视图窗口可见区域原点。
         */
        getVisibleOrigin(): Vec2;
        /**
         * @en Returns the visible origin of the view port.
         * @zh 返回视图窗口可见区域像素原点。
         */
        getVisibleOriginInPixel(): Vec2;
        /**
         * @en Returns the current resolution policy
         * @zh 返回当前分辨率方案
         * @see {{ResolutionPolicy}}
         */
        getResolutionPolicy(): ResolutionPolicy;
        /**
         * @en Sets the current resolution policy
         * @zh 设置当前分辨率模式
         * @see {{ResolutionPolicy}}
         */
        setResolutionPolicy(resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Sets the resolution policy with designed view size in points.<br/>
         * The resolution policy include: <br/>
         * [1] ResolutionExactFit       Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.<br/>
         * [2] ResolutionNoBorder       Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.<br/>
         * [3] ResolutionShowAll        Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown.<br/>
         * [4] ResolutionFixedHeight    Scale the content's height to screen's height and proportionally scale its width<br/>
         * [5] ResolutionFixedWidth     Scale the content's width to screen's width and proportionally scale its height<br/>
         * [ResolutionPolicy]        [Web only feature] Custom resolution policy, constructed by ResolutionPolicy<br/>
         * @zh 通过设置设计分辨率和匹配模式来进行游戏画面的屏幕适配。
         * @param width Design resolution width.
         * @param height Design resolution height.
         * @param resolutionPolicy The resolution policy desired
         */
        setDesignResolutionSize(width: number, height: number, resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Returns the designed size for the view.
         * Default resolution size is the same as 'getFrameSize'.
         * @zh 返回视图的设计分辨率。
         * 默认下分辨率尺寸同 `getFrameSize` 方法相同
         */
        getDesignResolutionSize(): Size;
        /**
         * @en Sets the container to desired pixel resolution and fit the game content to it.
         * This function is very useful for adaptation in mobile browsers.
         * In some HD android devices, the resolution is very high, but its browser performance may not be very good.
         * In this case, enabling retina display is very costy and not suggested, and if retina is disabled, the image may be blurry.
         * But this API can be helpful to set a desired pixel resolution which is in between.
         * This API will do the following:
         *     1. Set viewport's width to the desired width in pixel
         *     2. Set body width to the exact pixel resolution
         *     3. The resolution policy will be reset with designed view size in points.
         * @zh 设置容器（container）需要的像素分辨率并且适配相应分辨率的游戏内容。
         * @param width Design resolution width.
         * @param height Design resolution height.
         * @param resolutionPolicy The resolution policy desired
         */
        setRealPixelResolution(width: number, height: number, resolutionPolicy: ResolutionPolicy | number): void;
        /**
         * @en Returns the view port rectangle.
         * @zh 返回视窗剪裁区域。
         */
        getViewportRect(): Rect;
        /**
         * @en Returns scale factor of the horizontal direction (X axis).
         * @zh 返回横轴的缩放比，这个缩放比是将画布像素分辨率放到设计分辨率的比例。
         */
        getScaleX(): number;
        /**
         * @en Returns scale factor of the vertical direction (Y axis).
         * @zh 返回纵轴的缩放比，这个缩放比是将画布像素分辨率缩放到设计分辨率的比例。
         */
        getScaleY(): number;
        /**
         * @en Returns device pixel ratio for retina display.
         * @zh 返回设备或浏览器像素比例。
         */
        getDevicePixelRatio(): number;
        /**
         * @en Returns the real location in view for a translation based on a related position
         * @zh 将屏幕坐标转换为游戏视图下的坐标。
         * @param tx - The X axis translation
         * @param ty - The Y axis translation
         * @param relatedPos - The related position object including "left", "top", "width", "height" informations
         * @param out - The out object to save the conversion result
         */
        convertToLocationInView(tx: number, ty: number, relatedPos: any, out: Vec2): Vec2;
        private _convertPointWithScale;
        private _resizeEvent;
        private _orientationChange;
        private _initFrameSize;
        private _adjustSizeKeepCanvasSize;
        private _setViewportMeta;
        private _adjustViewportMeta;
        private _convertMouseToLocation;
        private _convertTouchWidthScale;
        private _convertTouchesWithScale;
    }
    /**
     * !en
     * Emit when design resolution changed.
     * !zh
     * 当设计分辨率改变时发送。
     * @event design-resolution-changed
     */
    interface AdaptResult {
        scale: number[];
        viewport?: null | Rect;
    }
    /**
     * ContainerStrategy class is the root strategy class of container's scale strategy,
     * it controls the behavior of how to scale the cc.game.container and cc.game.canvas object
     */
    class ContainerStrategy {
        static EQUAL_TO_FRAME: any;
        static PROPORTION_TO_FRAME: any;
        name: string;
        /**
         * @en Manipulation before appling the strategy
         * @zh 在应用策略之前的操作
         * @param view - The target view
         */
        preApply(_view: View): void;
        /**
         * @en Function to apply this strategy
         * @zh 策略应用方法
         * @param view
         * @param designedResolution
         */
        apply(_view: View, designedResolution: Size): void;
        /**
         * @en
         * Manipulation after applying the strategy
         * @zh 策略调用之后的操作
         * @param view  The target view
         */
        postApply(_view: View): void;
        protected _setupContainer(_view: any, w: any, h: any): void;
        protected _fixContainer(): void;
    }
    /**
     * @en
     * Emit when canvas resize.
     * @zh
     * 当画布大小改变时发送。
     * @event canvas-resize
     */
    /**
     * ContentStrategy class is the root strategy class of content's scale strategy,
     * it controls the behavior of how to scale the scene and setup the viewport for the game
     *
     * @class ContentStrategy
     */
    class ContentStrategy {
        static EXACT_FIT: any;
        static SHOW_ALL: any;
        static NO_BORDER: any;
        static FIXED_HEIGHT: any;
        static FIXED_WIDTH: any;
        name: string;
        private _result;
        constructor();
        /**
         * @en Manipulation before applying the strategy
         * @zh 策略应用前的操作
         * @param view - The target view
         */
        preApply(_view: View): void;
        /**
         * @en Function to apply this strategy
         * The return value is {scale: [scaleX, scaleY], viewport: {new Rect}},
         * The target view can then apply these value to itself, it's preferred not to modify directly its private variables
         * @zh 调用策略方法
         * @return The result scale and viewport rect
         */
        apply(_view: View, designedResolution: Size): AdaptResult;
        /**
         * @en Manipulation after applying the strategy
         * @zh 策略调用之后的操作
         * @param view - The target view
         */
        postApply(_view: View): void;
        _buildResult(containerW: any, containerH: any, contentW: any, contentH: any, scaleX: any, scaleY: any): AdaptResult;
    }
    /**
     * ResolutionPolicy class is the root strategy class of scale strategy,
     * its main task is to maintain the compatibility with Cocos2d-x</p>
     */
    export class ResolutionPolicy {
        /**
         * The entire application is visible in the specified area without trying to preserve the original aspect ratio.<br/>
         * Distortion can occur, and the application may appear stretched or compressed.
         */
        static EXACT_FIT: number;
        /**
         * The entire application fills the specified area, without distortion but possibly with some cropping,<br/>
         * while maintaining the original aspect ratio of the application.
         */
        static NO_BORDER: number;
        /**
         * The entire application is visible in the specified area without distortion while maintaining the original<br/>
         * aspect ratio of the application. Borders can appear on two sides of the application.
         */
        static SHOW_ALL: number;
        /**
         * The application takes the height of the design resolution size and modifies the width of the internal<br/>
         * canvas so that it fits the aspect ratio of the device<br/>
         * no distortion will occur however you must make sure your application works on different<br/>
         * aspect ratios
         */
        static FIXED_HEIGHT: number;
        /**
         * The application takes the width of the design resolution size and modifies the height of the internal<br/>
         * canvas so that it fits the aspect ratio of the device<br/>
         * no distortion will occur however you must make sure your application works on different<br/>
         * aspect ratios
         */
        static FIXED_WIDTH: number;
        /**
         * Unknown policy
         */
        static UNKNOWN: number;
        static ContainerStrategy: typeof ContainerStrategy;
        static ContentStrategy: typeof ContentStrategy;
        name: string;
        private _containerStrategy;
        private _contentStrategy;
        /**
         * Constructor of ResolutionPolicy
         * @param containerStg
         * @param contentStg
         */
        constructor(containerStg: ContainerStrategy, contentStg: ContentStrategy);
        get canvasSize(): any;
        /**
         * @en Manipulation before applying the resolution policy
         * @zh 策略应用前的操作
         * @param _view The target view
         */
        preApply(_view: View): void;
        /**
         * @en Function to apply this resolution policy
         * The return value is {scale: [scaleX, scaleY], viewport: {new Rect}},
         * The target view can then apply these value to itself, it's preferred not to modify directly its private variables
         * @zh 调用策略方法
         * @param _view - The target view
         * @param designedResolution - The user defined design resolution
         * @return An object contains the scale X/Y values and the viewport rect
         */
        apply(_view: View, designedResolution: Size): AdaptResult;
        /**
         * @en Manipulation after appyling the strategy
         * @zh 策略应用之后的操作
         * @param _view - The target view
         */
        postApply(_view: View): void;
        /**
         * @en Setup the container's scale strategy
         * @zh 设置容器的适配策略
         * @param containerStg The container strategy
         */
        setContainerStrategy(containerStg: ContainerStrategy): void;
        /**
         * @en Setup the content's scale strategy
         * @zh 设置内容的适配策略
         * @param contentStg The content strategy
         */
        setContentStrategy(contentStg: ContentStrategy): void;
    }
    /**
     * @en view is the singleton view object.
     * @zh view 是全局的视图单例对象。
     */
    export const view: View;
}
declare module "cocos/core/renderer/scene/fog" {
    import { Color } from "cocos/core/math/index";
    /**
     * @zh
     * 全局雾类型。
     * @en
     * The global fog type
     * @static
     * @enum FogInfo.FogType
     */
    export const FogType: {
        /**
         * @zh
         * 线性雾。
         * @en
         * Linear fog
         * @readonly
         */
        LINEAR: number;
        /**
         * @zh
         * 指数雾。
         * @en
         * Exponential fog
         * @readonly
         */
        EXP: number;
        /**
         * @zh
         * 指数平方雾。
         * @en
         * Exponential square fog
         * @readonly
         */
        EXP_SQUARED: number;
        /**
         * @zh
         * 层叠雾。
         * @en
         * Layered fog
         * @readonly
         */
        LAYERED: number;
    };
    export class Fog {
        /**
         * @zh 是否启用全局雾效
         * @en Enable global fog
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @zh 全局雾颜色
         * @en Global fog color
         */
        set fogColor(val: Color);
        get fogColor(): Color;
        /**
         * @zh 全局雾类型
         * @en Global fog type
         */
        get type(): number;
        set type(val: number);
        /**
         * @zh 全局雾浓度
         * @en Global fog density
         */
        get fogDensity(): number;
        set fogDensity(val: number);
        /**
         * @zh 雾效起始位置，只适用于线性雾
         * @en Global fog start position, only for linear fog
         */
        get fogStart(): number;
        set fogStart(val: number);
        /**
         * @zh 雾效结束位置，只适用于线性雾
         * @en Global fog end position, only for linear fog
         */
        get fogEnd(): number;
        set fogEnd(val: number);
        /**
         * @zh 雾效衰减
         * @en Global fog attenuation
         */
        get fogAtten(): number;
        set fogAtten(val: number);
        /**
         * @zh 雾效顶部范围，只适用于层级雾
         * @en Global fog top range, only for layered fog
         */
        get fogTop(): number;
        set fogTop(val: number);
        /**
         * @zh 雾效范围，只适用于层级雾
         * @en Global fog range, only for layered fog
         */
        get fogRange(): number;
        set fogRange(val: number);
        /**
         * @zh 当前雾化类型。
         * @en The current global fog type.
         * @returns {FogType}
         * Returns the current global fog type
         * - 0:Disable global Fog
         * - 1:Linear fog
         * - 2:Exponential fog
         * - 3:Exponential square fog
         * - 4:Layered fog
         */
        get currType(): number;
        get colorArray(): Float32Array;
        protected _type: number;
        protected _fogColor: Color;
        protected _enabled: boolean;
        protected _fogDensity: number;
        protected _fogStart: number;
        protected _fogEnd: number;
        protected _fogAtten: number;
        protected _fogTop: number;
        protected _fogRange: number;
        protected _currType: number;
        protected _colorArray: Float32Array;
        activate(): void;
        protected _updatePipeline(): void;
    }
}
declare module "cocos/core/scene-graph/scene-globals" {
    /**
     * @category scene-graph
     */
    import { TextureCube } from "cocos/core/assets/texture-cube";
    import { Color, Vec3, Vec2 } from "cocos/core/math/index";
    import { Ambient } from "cocos/core/renderer/scene/ambient";
    import { Shadows } from "cocos/core/renderer/scene/shadows";
    import { Skybox } from "cocos/core/renderer/scene/skybox";
    import { Fog } from "cocos/core/renderer/scene/fog";
    import { Node } from "cocos/core/scene-graph/node";
    /**
     * @en Environment lighting information in the Scene
     * @zh 场景的环境光照相关信息
     */
    export class AmbientInfo {
        protected _skyColor: Color;
        protected _skyIllum: number;
        protected _groundAlbedo: Color;
        protected _resource: Ambient | null;
        /**
         * @en Sky color
         * @zh 天空颜色
         */
        set skyColor(val: Color);
        get skyColor(): Color;
        /**
         * @en Sky illuminance
         * @zh 天空亮度
         */
        set skyIllum(val: number);
        get skyIllum(): number;
        /**
         * @en Ground color
         * @zh 地面颜色
         */
        set groundAlbedo(val: Color);
        get groundAlbedo(): Color;
        activate(resource: Ambient): void;
    }
    /**
     * @en Skybox related information
     * @zh 天空盒相关信息
     */
    export class SkyboxInfo {
        protected _envmap: TextureCube | null;
        protected _isRGBE: boolean;
        protected _enabled: boolean;
        protected _useIBL: boolean;
        protected _resource: Skybox | null;
        /**
         * @en Whether activate skybox in the scene
         * @zh 是否启用天空盒？
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @en Whether use environment lighting
         * @zh 是否启用环境光照？
         */
        set useIBL(val: boolean);
        get useIBL(): boolean;
        /**
         * @en The texture cube used for the skybox
         * @zh 使用的立方体贴图
         */
        set envmap(val: TextureCube | null);
        get envmap(): TextureCube | null;
        /**
         * @en Whether enable RGBE data support in skybox shader
         * @zh 是否需要开启 shader 内的 RGBE 数据支持？
         */
        set isRGBE(val: boolean);
        get isRGBE(): boolean;
        activate(resource: Skybox): void;
    }
    /**
     * @zh 全局雾相关信息
     * @en Global fog info
     */
    export class FogInfo {
        static FogType: {
            LINEAR: number;
            EXP: number;
            EXP_SQUARED: number;
            LAYERED: number;
        };
        protected _type: number;
        protected _fogColor: Color;
        protected _enabled: boolean;
        protected _fogDensity: number;
        protected _fogStart: number;
        protected _fogEnd: number;
        protected _fogAtten: number;
        protected _fogTop: number;
        protected _fogRange: number;
        protected _resource: Fog | null;
        /**
         * @zh 是否启用全局雾效
         * @en Enable global fog
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        /**
         * @zh 全局雾颜色
         * @en Global fog color
         */
        set fogColor(val: Color);
        get fogColor(): Color;
        /**
         * @zh 全局雾类型
         * @en Global fog type
         */
        get type(): number;
        set type(val: number);
        /**
         * @zh 全局雾浓度
         * @en Global fog density
         */
        get fogDensity(): number;
        set fogDensity(val: number);
        /**
         * @zh 雾效起始位置，只适用于线性雾
         * @en Global fog start position, only for linear fog
         */
        get fogStart(): number;
        set fogStart(val: number);
        /**
         * @zh 雾效结束位置，只适用于线性雾
         * @en Global fog end position, only for linear fog
         */
        get fogEnd(): number;
        set fogEnd(val: number);
        /**
         * @zh 雾效衰减
         * @en Global fog attenuation
         */
        get fogAtten(): number;
        set fogAtten(val: number);
        /**
         * @zh 雾效顶部范围，只适用于层级雾
         * @en Global fog top range, only for layered fog
         */
        get fogTop(): number;
        set fogTop(val: number);
        /**
         * @zh 雾效范围，只适用于层级雾
         * @en Global fog range, only for layered fog
         */
        get fogRange(): number;
        set fogRange(val: number);
        activate(resource: Fog): void;
    }
    /**
     * @en Scene level planar shadow related information
     * @zh 平面阴影相关信息
     */
    export class ShadowsInfo {
        protected _type: number;
        protected _enabled: boolean;
        protected _normal: Vec3;
        protected _distance: number;
        protected _shadowColor: Color;
        protected _pcf: number;
        protected _near: number;
        protected _far: number;
        protected _aspect: number;
        protected _orthoSize: number;
        protected _size: Vec2;
        protected _resource: Shadows | null;
        /**
         * @en Whether activate planar shadow
         * @zh 是否启用平面阴影？
         */
        set enabled(val: boolean);
        get enabled(): boolean;
        set type(val: number);
        get type(): number;
        /**
         * @en Shadow color
         * @zh 阴影颜色
         */
        set shadowColor(val: Color);
        get shadowColor(): Color;
        /**
         * @en The normal of the plane which receives shadow
         * @zh 阴影接收平面的法线
         */
        set normal(val: Vec3);
        get normal(): Vec3;
        /**
         * @en The distance from coordinate origin to the receiving plane.
         * @zh 阴影接收平面与原点的距离
         */
        set distance(val: number);
        get distance(): number;
        /**
         * @en The normal of the plane which receives shadow
         * @zh 阴影接收平面的法线
         */
        set pcf(val: number);
        get pcf(): number;
        /**
         * @en get or set shadow camera near
         * @zh 获取或者设置阴影相机近裁剪面
         */
        set near(val: number);
        get near(): number;
        /**
         * @en get or set shadow camera far
         * @zh 获取或者设置阴影相机远裁剪面
         */
        set far(val: number);
        get far(): number;
        /**
         * @en get or set shadow camera orthoSize
         * @zh 获取或者设置阴影相机正交大小
         */
        set orthoSize(val: number);
        get orthoSize(): number;
        /**
         * @en get or set shadow camera orthoSize
         * @zh 获取或者设置阴影纹理大小
         */
        set shadowMapSize(val: Vec2);
        get shadowMapSize(): Vec2;
        /**
         * @en get or set shadow camera orthoSize
         * @zh 获取或者设置阴影纹理大小
         */
        set aspect(val: number);
        get aspect(): number;
        /**
         * @en Set plane which receives shadow with the given node's world transformation
         * @zh 根据指定节点的世界变换设置阴影接收平面的信息
         * @param node The node for setting up the plane
         */
        setPlaneFromNode(node: Node): void;
        activate(resource: Shadows): void;
    }
    /**
     * @en All scene related global parameters, it affects all content in the corresponding scene
     * @zh 各类场景级别的渲染参数，将影响全场景的所有物体
     */
    export class SceneGlobals {
        /**
         * @en The environment light information
         * @zh 场景的环境光照相关信息
         */
        ambient: AmbientInfo;
        /**
         * @en Scene level planar shadow related information
         * @zh 平面阴影相关信息
         */
        shadows: ShadowsInfo;
        _skybox: SkyboxInfo;
        fog: FogInfo;
        /**
         * @en Skybox related information
         * @zh 天空盒相关信息
         */
        get skybox(): SkyboxInfo;
        set skybox(value: SkyboxInfo);
        activate(): void;
    }
}
declare module "cocos/core/scene-graph/scene" {
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { BaseNode } from "cocos/core/scene-graph/base-node";
    import { Component } from "cocos/core/components/component";
    import { SceneGlobals } from "cocos/core/scene-graph/scene-globals";
    /**
     * @en
     * Scene is a subclass of [[BaseNode]], composed by nodes, representing the root of a runnable environment in the game.
     * It's managed by [[Director]] and user can switch from a scene to another using [[Director.loadScene]]
     * @zh
     * Scene 是 [[BaseNode]] 的子类，由节点所构成，代表着游戏中可运行的某一个整体环境。
     * 它由 [[Director]] 管理，用户可以使用 [[Director.loadScene]] 来切换场景
     */
    export class Scene extends BaseNode {
        /**
         * @en The renderer scene, normally user don't need to use it
         * @zh 渲染层场景，一般情况下用户不需要关心它
         */
        get renderScene(): RenderScene | null;
        get globals(): SceneGlobals;
        /**
         * @en Indicates whether all (directly or indirectly) static referenced assets of this scene are releasable by default after scene unloading.
         * @zh 指示该场景中直接或间接静态引用到的所有资源是否默认在场景切换后自动释放。
         */
        autoReleaseAssets: boolean;
        /**
         * @en Per-scene level rendering info
         * @zh 场景级别的渲染信息
         */
        _globals: SceneGlobals;
        _renderScene: RenderScene | null;
        dependAssets: null;
        protected _inited: boolean;
        protected _prefabSyncedInLiveReload: boolean;
        protected _pos: Readonly<Vec3>;
        protected _rot: Readonly<Quat>;
        protected _scale: Readonly<Vec3>;
        protected _mat: Readonly<Mat4>;
        protected _dirtyFlags: number;
        constructor(name: string);
        /**
         * @en Destroy the current scene and all its nodes, this action won't destroy related assets
         * @zh 销毁当前场景中的所有节点，这个操作不会销毁资源
         */
        destroy(): boolean;
        /**
         * @en Only for compatibility purpose, user should not add any component to the scene
         * @zh 仅为兼容性保留，用户不应该在场景上直接添加任何组件
         */
        addComponent(typeOrClassName: string | Function): Component;
        _onHierarchyChanged(): void;
        _onBatchCreated(): void;
        _onBatchRestored(): void;
        /**
         * Refer to [[Node.getPosition]]
         */
        getPosition(out?: Vec3): Vec3;
        /**
         * Refer to [[Node.getRotation]]
         */
        getRotation(out?: Quat): Quat;
        /**
         * Refer to [[Node.getScale]]
         */
        getScale(out?: Vec3): Vec3;
        /**
         * Refer to [[Node.getWorldPosition]]
         */
        getWorldPosition(out?: Vec3): Vec3;
        /**
         * Refer to [[Node.getWorldRotation]]
         */
        getWorldRotation(out?: Quat): Quat;
        /**
         * Refer to [[Node.getWorldScale]]
         */
        getWorldScale(out?: Vec3): Vec3;
        /**
         * Refer to [[Node.getWorldMatrix]]
         */
        getWorldMatrix(out?: Mat4): Mat4;
        /**
         * Refer to [[Node.getWorldRS]]
         */
        getWorldRS(out?: Mat4): Mat4;
        /**
         * Refer to [[Node.getWorldRT]]
         */
        getWorldRT(out?: Mat4): Mat4;
        /**
         * Refer to [[Node.position]]
         */
        get position(): Readonly<Vec3>;
        /**
         * Refer to [[Node.worldPosition]]
         */
        get worldPosition(): Readonly<Vec3>;
        /**
         * Refer to [[Node.rotation]]
         */
        get rotation(): Readonly<Quat>;
        /**
         * Refer to [[Node.worldRotation]]
         */
        get worldRotation(): Readonly<Quat>;
        /**
         * Refer to [[Node.scale]]
         */
        get scale(): Readonly<Vec3>;
        /**
         * Refer to [[Node.worldScale]]
         */
        get worldScale(): Readonly<Vec3>;
        /**
         * Refer to [[Node.eulerAngles]]
         */
        get eulerAngles(): Readonly<Vec3>;
        /**
         * Refer to [[Node.worldMatrix]]
         */
        get worldMatrix(): Readonly<Mat4>;
        /**
         * Refer to [[Node.updateWorldTransform]]
         */
        updateWorldTransform(): void;
        protected _instantiate(): void;
        protected _load(): void;
        protected _activate(active: boolean): void;
    }
}
declare module "cocos/core/3d/framework/camera-component" {
    import { RenderTexture } from "cocos/core/assets/render-texture";
    import { Component } from "cocos/core/components/component";
    import { ray } from "cocos/core/geometry/index";
    import { GFXClearFlag } from "cocos/core/gfx/define";
    import { Color, Rect, Vec3 } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    import { Node } from "cocos/core/scene-graph/node";
    import { Scene } from "cocos/core/scene-graph/scene";
    /**
     * @en The projection type.
     * @zh 投影类型。
     */
    const ProjectionType: typeof scene.CameraProjection;
    const FOVAxis: typeof scene.CameraFOVAxis;
    const Aperture: typeof scene.CameraAperture;
    const Shutter: typeof scene.CameraShutter;
    const ISO: typeof scene.CameraISO;
    const ClearFlag: {
        SKYBOX: number;
        SOLID_COLOR: GFXClearFlag;
        DEPTH_ONLY: GFXClearFlag;
        DONT_CLEAR: GFXClearFlag;
    };
    export namespace Camera {
        type ProjectionType = EnumAlias<typeof ProjectionType>;
        type FOVAxis = EnumAlias<typeof FOVAxis>;
        type ClearFlag = EnumAlias<typeof ClearFlag>;
        type Aperture = EnumAlias<typeof Aperture>;
        type Shutter = EnumAlias<typeof Shutter>;
        type ISO = EnumAlias<typeof ISO>;
    }
    /**
     * @en The Camera Component.
     * @zh 相机组件。
     */
    export class Camera extends Component {
        static ProjectionType: typeof scene.CameraProjection;
        static FOVAxis: typeof scene.CameraFOVAxis;
        static ClearFlag: {
            SKYBOX: number;
            SOLID_COLOR: GFXClearFlag;
            DEPTH_ONLY: GFXClearFlag;
            DONT_CLEAR: GFXClearFlag;
        };
        static Aperture: typeof scene.CameraAperture;
        static Shutter: typeof scene.CameraShutter;
        static ISO: typeof scene.CameraISO;
        protected _projection: scene.CameraProjection;
        protected _priority: number;
        protected _fov: number;
        protected _fovAxis: scene.CameraFOVAxis;
        protected _orthoHeight: number;
        protected _near: number;
        protected _far: number;
        protected _color: Color;
        protected _depth: number;
        protected _stencil: number;
        protected _clearFlags: GFXClearFlag;
        protected _rect: Rect;
        protected _aperture: scene.CameraAperture;
        protected _shutter: scene.CameraShutter;
        protected _iso: scene.CameraISO;
        protected _screenScale: number;
        protected _visibility: number;
        protected _targetTexture: RenderTexture | null;
        protected _camera: scene.Camera | null;
        protected _inEditorMode: boolean;
        protected _flows: string[] | undefined;
        get camera(): scene.Camera;
        /**
         * @en Render priority of the camera, in ascending-order.
         * @zh 相机的渲染优先级，值越小越优先渲染。
         */
        get priority(): number;
        set priority(val: number);
        /**
         * @en Visibility mask, declaring a set of node layers that will be visible to this camera.
         * @zh 可见性掩码，声明在当前相机中可见的节点层级集合。
         */
        get visibility(): number;
        set visibility(val: number);
        /**
         * @en Clearing flags of the camera, specifies which part of the framebuffer will be actually cleared every frame.
         * @zh 相机的缓冲清除标志位，指定帧缓冲的哪部分要每帧清除。
         */
        get clearFlags(): GFXClearFlag;
        set clearFlags(val: GFXClearFlag);
        /**
         * @en Clearing color of the camera.
         * @zh 相机的颜色缓冲默认值。
         */
        get clearColor(): Readonly<Color>;
        set clearColor(val: Readonly<Color>);
        /**
         * @en Clearing depth of the camera.
         * @zh 相机的深度缓冲默认值。
         */
        get clearDepth(): number;
        set clearDepth(val: number);
        /**
         * @en Clearing stencil of the camera.
         * @zh 相机的模板缓冲默认值。
         */
        get clearStencil(): number;
        set clearStencil(val: number);
        /**
         * @en Projection type of the camera.
         * @zh 相机的投影类型。
         */
        get projection(): scene.CameraProjection;
        set projection(val: scene.CameraProjection);
        /**
         * @en The axis on which the FOV would be fixed regardless of screen aspect changes.
         * @zh 指定视角的固定轴向，在此轴上不会跟随屏幕长宽比例变化。
         */
        get fovAxis(): scene.CameraFOVAxis;
        set fovAxis(val: scene.CameraFOVAxis);
        /**
         * @en Field of view of the camera.
         * @zh 相机的视角大小。
         */
        get fov(): number;
        set fov(val: number);
        /**
         * @en Viewport height in orthographic mode.
         * @zh 正交模式下的相机视角高度。
         */
        get orthoHeight(): number;
        set orthoHeight(val: number);
        /**
         * @en Near clipping distance of the camera, should be as large as possible within acceptable range.
         * @zh 相机的近裁剪距离，应在可接受范围内尽量取最大。
         */
        get near(): number;
        set near(val: number);
        /**
         * @en Far clipping distance of the camera, should be as small as possible within acceptable range.
         * @zh 相机的远裁剪距离，应在可接受范围内尽量取最小。
         */
        get far(): number;
        set far(val: number);
        /**
         * @en Camera aperture, controls the exposure parameter.
         * @zh 相机光圈，影响相机的曝光参数。
         */
        get aperture(): scene.CameraAperture;
        set aperture(val: scene.CameraAperture);
        /**
         * @en Camera shutter, controls the exposure parameter.
         * @zh 相机快门，影响相机的曝光参数。
         */
        get shutter(): scene.CameraShutter;
        set shutter(val: scene.CameraShutter);
        /**
         * @en Camera ISO, controls the exposure parameter.
         * @zh 相机感光度，影响相机的曝光参数。
         */
        get iso(): scene.CameraISO;
        set iso(val: scene.CameraISO);
        /**
         * @en Screen viewport of the camera wrt. the sceen size.
         * @zh 此相机最终渲染到屏幕上的视口位置和大小。
         */
        get rect(): Rect;
        set rect(val: Rect);
        /**
         * @en Output render texture of the camera. Default to null, which outputs directly to screen.
         * @zh 指定此相机的渲染输出目标贴图，默认为空，直接渲染到屏幕。
         */
        get targetTexture(): RenderTexture | null;
        set targetTexture(value: RenderTexture | null);
        /**
         * @en Scale of the internal buffer size,
         * set to 1 to keep the same with the canvas size.
         * @zh 相机内部缓冲尺寸的缩放值, 1 为与 canvas 尺寸相同。
         */
        get screenScale(): number;
        set screenScale(val: number);
        get inEditorMode(): boolean;
        set inEditorMode(value: boolean);
        set flows(val: any);
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        screenPointToRay(x: number, y: number, out?: ray): ray;
        worldToScreen(worldPos: Vec3, out?: Vec3): Vec3;
        screenToWorld(screenPos: Vec3, out?: Vec3): Vec3;
        /**
         * @en 3D node to UI local node coordinates. The converted value is the offset under the UI node.
         *
         * @zh 3D 节点转 UI 本地节点坐标。转换后的值是该 UI 节点下的偏移。
         * @param wpos 3D 节点世界坐标
         * @param uiNode UI 节点
         * @param out 返回在当前传入的 UI 节点下的偏移量
         *
         * @example
         * ```ts
         * this.convertToUINode(target.worldPosition, uiNode.parent, out);
         * uiNode.position = out;
         * ```
         */
        convertToUINode(wpos: Vec3, uiNode: Node, out?: Vec3): Vec3;
        protected _createCamera(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected onSceneChanged(scene: Scene): void;
        protected _chechTargetTextureEvent(old: RenderTexture | null): void;
        protected _updateTargetTexture(): void;
    }
}
declare module "cocos/core/scheduler" {
    import System from "cocos/core/components/system";
    export interface ISchedulable {
        id?: string;
        uuid?: string;
    }
    /**
     * @en
     * Scheduler is responsible of triggering the scheduled callbacks.<br>
     * You should not use NSTimer. Instead use this class.<br>
     * <br>
     * There are 2 different types of callbacks (selectors):<br>
     *     - update callback: the 'update' callback will be called every frame. You can customize the priority.<br>
     *     - custom callback: A custom callback will be called every frame, or with a custom interval of time<br>
     * <br>
     * The 'custom selectors' should be avoided when possible. It is faster,<br>
     * and consumes less memory to use the 'update callback'. *
     * @zh
     * Scheduler 是负责触发回调函数的类。<br>
     * 通常情况下，建议使用 `director.getScheduler()` 来获取系统定时器。<br>
     * 有两种不同类型的定时器：<br>
     *     - update 定时器：每一帧都会触发。您可以自定义优先级。<br>
     *     - 自定义定时器：自定义定时器可以每一帧或者自定义的时间间隔触发。<br>
     * 如果希望每帧都触发，应该使用 update 定时器，使用 update 定时器更快，而且消耗更少的内存。
     *
     * @class Scheduler
     */
    export class Scheduler extends System {
        /**
         * @en Priority level reserved for system services.
         * @zh 系统服务的优先级。
         */
        static PRIORITY_SYSTEM: number;
        /**
         * @en Minimum priority level for user scheduling.
         * @zh 用户调度最低优先级。
         */
        static PRIORITY_NON_SYSTEM: number;
        static ID: string;
        private _timeScale;
        private _updatesNegList;
        private _updates0List;
        private _updatesPosList;
        private _hashForUpdates;
        private _hashForTimers;
        private _currentTarget;
        private _currentTargetSalvaged;
        private _updateHashLocked;
        private _arrayForTimers;
        /**
         * @en This method should be called for any target which needs to schedule tasks, and this method should be called before any scheduler API usage.<bg>
         * This method will add a `id` property if it doesn't exist.
         * @zh 任何需要用 Scheduler 管理任务的对象主体都应该调用这个方法，并且应该在调用任何 Scheduler API 之前调用这个方法。<bg>
         * 这个方法会给对象添加一个 `id` 属性，如果这个属性不存在的话。
         * @param {Object} target
         */
        static enableForTarget(target: ISchedulable): void;
        constructor();
        /**
         * @en
         * Modifies the time of all scheduled callbacks.<br>
         * You can use this property to create a 'slow motion' or 'fast forward' effect.<br>
         * Default is 1.0. To create a 'slow motion' effect, use values below 1.0.<br>
         * To create a 'fast forward' effect, use values higher than 1.0.<br>
         * Note：It will affect EVERY scheduled selector / action.
         * @zh
         * 设置时间间隔的缩放比例。<br>
         * 您可以使用这个方法来创建一个 “slow motion（慢动作）” 或 “fast forward（快进）” 的效果。<br>
         * 默认是 1.0。要创建一个 “slow motion（慢动作）” 效果,使用值低于 1.0。<br>
         * 要使用 “fast forward（快进）” 效果，使用值大于 1.0。<br>
         * 注意：它影响该 Scheduler 下管理的所有定时器。
         * @param {Number} timeScale
         */
        setTimeScale(timeScale: any): void;
        /**
         * @en Returns time scale of scheduler.
         * @zh 获取时间间隔的缩放比例。
         * @return {Number}
         */
        getTimeScale(): number;
        /**
         * @en 'update' the scheduler. (You should NEVER call this method, unless you know what you are doing.)
         * @zh update 调度函数。(不应该直接调用这个方法，除非完全了解这么做的结果)
         * @param {Number} dt delta time
         */
        update(dt: any): void;
        /**
         * @en
         * <p>
         *   The scheduled method will be called every 'interval' seconds.<br/>
         *   If paused is YES, then it won't be called until it is resumed.<br/>
         *   If 'interval' is 0, it will be called every frame, but if so, it recommended to use 'scheduleUpdateForTarget:' instead.<br/>
         *   If the callback function is already scheduled, then only the interval parameter will be updated without re-scheduling it again.<br/>
         *   repeat let the action be repeated repeat + 1 times, use `macro.REPEAT_FOREVER` to let the action run continuously<br/>
         *   delay is the amount of time the action will wait before it'll start<br/>
         * </p>
         * @zh
         * 指定回调函数，调用对象等信息来添加一个新的定时器。<br/>
         * 如果 paused 值为 true，那么直到 resume 被调用才开始计时。<br/>
         * 当时间间隔达到指定值时，设置的回调函数将会被调用。<br/>
         * 如果 interval 值为 0，那么回调函数每一帧都会被调用，但如果是这样，
         * 建议使用 scheduleUpdateForTarget 代替。<br/>
         * 如果回调函数已经被定时器使用，那么只会更新之前定时器的时间间隔参数，不会设置新的定时器。<br/>
         * repeat 值可以让定时器触发 repeat + 1 次，使用 `macro.REPEAT_FOREVER`
         * 可以让定时器一直循环触发。<br/>
         * delay 值指定延迟时间，定时器会在延迟指定的时间之后开始计时。
         * @param {Function} callback
         * @param {Object} target
         * @param {Number} interval
         * @param {Number} [repeat]
         * @param {Number} [delay=0]
         * @param {Boolean} [paused=fasle]
         */
        schedule(callback: Function, target: ISchedulable, interval: number, repeat?: number, delay?: number, paused?: boolean): void;
        /**
         * @en
         * Schedules the update callback for a given target,
         * During every frame after schedule started, the "update" function of target will be invoked.
         * @zh
         * 使用指定的优先级为指定的对象设置 update 定时器。<br>
         * update 定时器每一帧都会被触发，触发时自动调用指定对象的 "update" 函数。<br>
         * 优先级的值越低，定时器被触发的越早。
         * @param {Object} target
         * @param {Number} priority
         * @param {Boolean} paused
         */
        scheduleUpdate(target: ISchedulable, priority: Number, paused: Boolean): void;
        /**
         * @en
         * Unschedules a callback for a callback and a given target.<br>
         * If you want to unschedule the "update", use `unscheduleUpdate()`
         * @zh
         * 根据指定的回调函数和调用对象。<br>
         * 如果需要取消 update 定时器，请使用 unscheduleUpdate()。
         * @param {Function} callback The callback to be unscheduled
         * @param {Object} target The target bound to the callback.
         */
        unschedule(callback: any, target: ISchedulable): void;
        /**
         * @en Unschedules the update callback for a given target.
         * @zh 取消指定对象的 update 定时器。
         * @param {Object} target The target to be unscheduled.
         */
        unscheduleUpdate(target: ISchedulable): void;
        /**
         * @en
         * Unschedules all scheduled callbacks for a given target.
         * This also includes the "update" callback.
         * @zh 取消指定对象的所有定时器，包括 update 定时器。
         * @param {Object} target The target to be unscheduled.
         */
        unscheduleAllForTarget(target: any): void;
        /**
         * @en
         * Unschedules all scheduled callbacks from all targets including the system callbacks.<br/>
         * You should NEVER call this method, unless you know what you are doing.
         * @zh
         * 取消所有对象的所有定时器，包括系统定时器。<br/>
         * 不用调用此函数，除非你确定你在做什么。
         */
        unscheduleAll(): void;
        /**
         * @en
         * Unschedules all callbacks from all targets with a minimum priority.<br/>
         * You should only call this with `PRIORITY_NON_SYSTEM_MIN` or higher.
         * @zh
         * 取消所有优先级的值大于指定优先级的定时器。<br/>
         * 你应该只取消优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
         * @param {Number} minPriority The minimum priority of selector to be unscheduled. Which means, all selectors which
         *        priority is higher than minPriority will be unscheduled.
         */
        unscheduleAllWithMinPriority(minPriority: number): void;
        /**
         * @en Checks whether a callback for a given target is scheduled.
         * @zh 检查指定的回调函数和回调对象组合是否存在定时器。
         * @param {Function} callback The callback to check.
         * @param {Object} target The target of the callback.
         * @return {Boolean} True if the specified callback is invoked, false if not.
         */
        isScheduled(callback: any, target: ISchedulable): boolean | undefined;
        /**
         * @en
         * Pause all selectors from all targets.<br/>
         * You should NEVER call this method, unless you know what you are doing.
         * @zh
         * 暂停所有对象的所有定时器。<br/>
         * 不要调用这个方法，除非你知道你正在做什么。
         */
        pauseAllTargets(): any;
        /**
         * @en
         * Pause all selectors from all targets with a minimum priority. <br/>
         * You should only call this with kCCPriorityNonSystemMin or higher.
         * @zh
         * 暂停所有优先级的值大于指定优先级的定时器。<br/>
         * 你应该只暂停优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
         * @param {Number} minPriority
         */
        pauseAllTargetsWithMinPriority(minPriority: number): any;
        /**
         * @en
         * Resume selectors on a set of targets.<br/>
         * This can be useful for undoing a call to pauseAllCallbacks.
         * @zh
         * 恢复指定数组中所有对象的定时器。<br/>
         * 这个函数是 pauseAllCallbacks 的逆操作。
         * @param {Array} targetsToResume
         */
        resumeTargets(targetsToResume: any): void;
        /**
         * @en
         * Pauses the target.<br/>
         * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.<br/>
         * If the target is not present, nothing happens.
         * @zh
         * 暂停指定对象的定时器。<br/>
         * 指定对象的所有定时器都会被暂停。<br/>
         * 如果指定的对象没有定时器，什么也不会发生。
         * @param {Object} target
         */
        pauseTarget(target: ISchedulable): void;
        /**
         * @en
         * Resumes the target.<br/>
         * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.<br/>
         * If the target is not present, nothing happens.
         * @zh
         * 恢复指定对象的所有定时器。<br/>
         * 指定对象的所有定时器将继续工作。<br/>
         * 如果指定的对象没有定时器，什么也不会发生。
         * @param {Object} target
         */
        resumeTarget(target: ISchedulable): void;
        /**
         * @en Returns whether or not the target is paused.
         * @zh 返回指定对象的定时器是否处于暂停状态。
         * @param {Object} target
         * @return {Boolean}
         */
        isTargetPaused(target: ISchedulable): any;
        private _removeHashElement;
        private _removeUpdateFromHash;
        private _priorityIn;
        private _appendIn;
    }
}
declare module "cocos/core/components/system" {
    /**
     * @hidden
     */
    import { ISchedulable } from "cocos/core/scheduler";
    export default class System implements ISchedulable {
        protected _id: string;
        protected _priority: number;
        protected _executeInEditMode: boolean;
        set priority(value: number);
        get priority(): number;
        set id(id: string);
        get id(): string;
        static sortByPriority(a: System, b: System): 1 | 0 | -1;
        init(): void;
        update(dt: number): void;
        postUpdate(dt: number): void;
    }
}
declare module "cocos/core/load-pipeline/auto-release-utils" {
    export function autoRelease(oldSceneAssets: any, nextSceneAssets: any, persistNodes: any): void;
    export function getDependsRecursively(key: any): string[];
}
declare module "cocos/core/scene-graph/component-scheduler" {
    import { MutableForwardIterator } from "cocos/core/utils/array";
    function stableRemoveInactive(iterator: any, flagToClear: any): void;
    export class LifeCycleInvoker {
        static stableRemoveInactive: typeof stableRemoveInactive;
        protected _zero: MutableForwardIterator<any>;
        protected _neg: MutableForwardIterator<any>;
        protected _pos: MutableForwardIterator<any>;
        protected _invoke: any;
        constructor(invokeFunc: any);
    }
    export class OneOffInvoker extends LifeCycleInvoker {
        add(comp: any): void;
        remove(comp: any): void;
        cancelInactive(flagToClear: any): void;
        invoke(): void;
    }
    class ReusableInvoker extends LifeCycleInvoker {
        add(comp: any): void;
        remove(comp: any): void;
        invoke(dt: any): void;
    }
    export function createInvokeImplJit(code: string, useDt?: any, ensureFlag?: any): (iterator: any, dt: any) => void;
    export function createInvokeImpl(singleInvoke: any, fastPath: any, ensureFlag?: any): (iterator: any, dt: any) => void;
    export const invokeOnEnable: (iterator: any) => void;
    /**
     * @en The Manager for Component's life-cycle methods.
     * It collaborates with [[NodeActivator]] to schedule and invoke life cycle methods for components
     * @zh 组件生命周期函数的调度器。
     * 它和 [[NodeActivator]] 一起调度并执行组件的生命周期函数。
     */
    export class ComponentScheduler {
        /**
         * @en The invoker of `start` callback
         * @zh `start` 回调的调度器
         */
        startInvoker: OneOffInvoker;
        /**
         * @en The invoker of `update` callback
         * @zh `update` 回调的调度器
         */
        updateInvoker: ReusableInvoker;
        /**
         * @en The invoker of `lateUpdate` callback
         * @zh `lateUpdate` 回调的调度器
         */
        lateUpdateInvoker: ReusableInvoker;
        private _deferredComps;
        private _updating;
        constructor();
        /**
         * @en Cancel all future callbacks, including `start`, `update` and `lateUpdate`
         * @zh 取消所有未来的函数调度，包括 `start`，`update` 和 `lateUpdate`
         */
        unscheduleAll(): void;
        _onEnabled(comp: any): void;
        _onDisabled(comp: any): void;
        /**
         * @en Enable a component
         * @zh 启用一个组件
         * @param comp The component to be enabled
         * @param invoker The invoker which is responsible to schedule the `onEnable` call
         */
        enableComp(comp: any, invoker?: any): void;
        /**
         * @en Disable a component
         * @zh 禁用一个组件
         * @param comp The component to be disabled
         */
        disableComp(comp: any): void;
        /**
         * @en Process start phase for registered components
         * @zh 为当前注册的组件执行 start 阶段任务
         */
        startPhase(): void;
        /**
         * @en Process update phase for registered components
         * @zh 为当前注册的组件执行 update 阶段任务
         * @param dt 距离上一帧的时间
         */
        updatePhase(dt: number): void;
        /**
         * @en Process late update phase for registered components
         * @zh 为当前注册的组件执行 late update 阶段任务
         * @param dt 距离上一帧的时间
         */
        lateUpdatePhase(dt: number): void;
        private _startForNewComps;
        private _scheduleImmediate;
        private _deferredSchedule;
    }
}
declare module "cocos/core/scene-graph/node-activator" {
    /**
     * @en The class used to perform activating and deactivating operations of node and component.
     * @zh 用于执行节点和组件的激活和停用操作的管理器。
     */
    export default class NodeActivator {
        resetComp: any;
        protected _activatingStack: any[];
        constructor();
        /**
         * @en Reset all activation or des-activation tasks
         * @zh 重置所有激活或非激活任务
         */
        reset(): void;
        /**
         * @en Activate or des-activate a node
         * @zh 激活或者停用某个节点
         * @param node Target node
         * @param active Which state to set the node to
         */
        activateNode(node: any, active: any): void;
        /**
         * @en Activate or des-activate a component
         * @zh 激活或者停用某个组件
         * @param comp Target component
         * @param preloadInvoker The invoker for `_preload` method, normally from [[ComponentScheduler]]
         * @param onLoadInvoker The invoker for `onLoad` method, normally from [[ComponentScheduler]]
         * @param onEnableInvoker The invoker for `onEnable` method, normally from [[ComponentScheduler]]
         */
        activateComp(comp: any, preloadInvoker?: any, onLoadInvoker?: any, onEnableInvoker?: any): void;
        /**
         * @en Destroy a component
         * @zh 销毁一个组件
         * @param comp Target component
         */
        destroyComp(comp: any): void;
        protected _activateNodeRecursively(node: any, preloadInvoker: any, onLoadInvoker: any, onEnableInvoker: any): void;
        protected _deactivateNodeRecursively(node: any): void;
    }
}
declare module "cocos/core/director" {
    /**
     * @category core
     */
    import { SceneAsset } from "cocos/core/assets/index";
    import System from "cocos/core/components/system";
    import { EventTarget } from "cocos/core/event/event-target";
    import { Color, Vec2 } from "cocos/core/math/index";
    import { Root } from "cocos/core/root";
    import { Scene } from "cocos/core/scene-graph/index";
    import { ComponentScheduler } from "cocos/core/scene-graph/component-scheduler";
    import NodeActivator from "cocos/core/scene-graph/node-activator";
    import { Scheduler } from "cocos/core/scheduler";
    /**
     * @en
     * <p>
     *    ATTENTION: USE `director` INSTEAD OF `Director`.<br/>
     *    `director` is a singleton object which manage your game's logic flow.<br/>
     *    Since the `director` is a singleton, you don't need to call any constructor or create functions,<br/>
     *    the standard way to use it is by calling:<br/>
     *      - `director.methodName();` <br/>
     *
     *    It creates and handle the main Window and manages how and when to execute the Scenes.<br/>
     *    <br/>
     *    The `director` is also responsible for:<br/>
     *      - initializing the OpenGL context<br/>
     *      - setting the OpenGL pixel format (default on is RGB565)<br/>
     *      - setting the OpenGL buffer depth (default on is 0-bit)<br/>
     *      - setting the color for clear screen (default one is BLACK)<br/>
     *      - setting the projection (default one is 3D)<br/>
     *      - setting the orientation (default one is Portrait)<br/>
     *      <br/>
     *    <br/>
     *    The `director` also sets the default OpenGL context:<br/>
     *      - GL_TEXTURE_2D is enabled<br/>
     *      - GL_VERTEX_ARRAY is enabled<br/>
     *      - GL_COLOR_ARRAY is enabled<br/>
     *      - GL_TEXTURE_COORD_ARRAY is enabled<br/>
     * </p>
     * <p>
     *   `director` also synchronizes timers with the refresh rate of the display.<br/>
     *   Features and Limitations:<br/>
     *      - Scheduled timers & drawing are synchronizes with the refresh rate of the display<br/>
     *      - Only supports animation intervals of 1/60 1/30 & 1/15<br/>
     * </p>
     *
     * @zh
     * <p>
     *     注意：用 `director` 代替 `Director`。<br/>
     *     `director` 一个管理你的游戏的逻辑流程的单例对象。<br/>
     *     由于 `director` 是一个单例，你不需要调用任何构造函数或创建函数，<br/>
     *     使用它的标准方法是通过调用：<br/>
     *       - `director.methodName();`
     *     <br/>
     *     它创建和处理主窗口并且管理什么时候执行场景。<br/>
     *     <br/>
     *     `director` 还负责：<br/>
     *      - 初始化 OpenGL 环境。<br/>
     *      - 设置OpenGL像素格式。(默认是 RGB565)<br/>
     *      - 设置OpenGL缓冲区深度 (默认是 0-bit)<br/>
     *      - 设置空白场景的颜色 (默认是 黑色)<br/>
     *      - 设置投影 (默认是 3D)<br/>
     *      - 设置方向 (默认是 Portrait)<br/>
     *    <br/>
     *    `director` 设置了 OpenGL 默认环境 <br/>
     *      - GL_TEXTURE_2D   启用。<br/>
     *      - GL_VERTEX_ARRAY 启用。<br/>
     *      - GL_COLOR_ARRAY  启用。<br/>
     *      - GL_TEXTURE_COORD_ARRAY 启用。<br/>
     * </p>
     * <p>
     *   `director` 也同步定时器与显示器的刷新速率。
     *   <br/>
     *   特点和局限性: <br/>
     *      - 将计时器 & 渲染与显示器的刷新频率同步。<br/>
     *      - 只支持动画的间隔 1/60 1/30 & 1/15。<br/>
     * </p>
     *
     * @class Director
     * @extends EventTarget
     */
    export class Director extends EventTarget {
        /**
         * @en The event which will be triggered when the singleton of Director initialized.
         * @zh Director 单例初始化时触发的事件
         * @event Director.EVENT_INIT
         */
        /**
         * @en The event which will be triggered when the singleton of Director initialized.
         * @zh Director 单例初始化时触发的事件
         */
        static readonly EVENT_INIT = "director_init";
        /**
         * @en The event which will be triggered when the singleton of Director reset.
         * @zh Director 单例重置时触发的事件
         * @event Director.EVENT_RESET
         */
        /**
         * @en The event which will be triggered when the singleton of Director reset.
         * @zh Director 单例重置时触发的事件
         */
        static readonly EVENT_RESET = "director_reset";
        /**
         * @en The event which will be triggered before loading a new scene.
         * @zh 加载新场景之前所触发的事件。
         * @event Director.EVENT_BEFORE_SCENE_LOADING
         * @param {String} sceneName - The loading scene name
         */
        /**
         * @en The event which will be triggered before loading a new scene.
         * @zh 加载新场景之前所触发的事件。
         */
        static readonly EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
        /**
         * @en The event which will be triggered before launching a new scene.
         * @zh 运行新场景之前所触发的事件。
         * @event Director.EVENT_BEFORE_SCENE_LAUNCH
         * @param {String} sceneName - New scene which will be launched
         */
        /**
         * @en The event which will be triggered before launching a new scene.
         * @zh 运行新场景之前所触发的事件。
         */
        static readonly EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
        /**
         * @en The event which will be triggered after launching a new scene.
         * @zh 运行新场景之后所触发的事件。
         * @event Director.EVENT_AFTER_SCENE_LAUNCH
         * @param {String} sceneName - New scene which is launched
         */
        /**
         * @en The event which will be triggered after launching a new scene.
         * @zh 运行新场景之后所触发的事件。
         */
        static readonly EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
        /**
         * @en The event which will be triggered at the beginning of every frame.
         * @zh 每个帧的开始时所触发的事件。
         * @event Director.EVENT_BEFORE_UPDATE
         */
        /**
         * @en The event which will be triggered at the beginning of every frame.
         * @zh 每个帧的开始时所触发的事件。
         */
        static readonly EVENT_BEFORE_UPDATE = "director_before_update";
        /**
         * @en The event which will be triggered after engine and components update logic.
         * @zh 将在引擎和组件 “update” 逻辑之后所触发的事件。
         * @event Director.EVENT_AFTER_UPDATE
         */
        /**
         * @en The event which will be triggered after engine and components update logic.
         * @zh 将在引擎和组件 “update” 逻辑之后所触发的事件。
         */
        static readonly EVENT_AFTER_UPDATE = "director_after_update";
        /**
         * @en The event which will be triggered before the rendering process.
         * @zh 渲染过程之前所触发的事件。
         * @event Director.EVENT_BEFORE_DRAW
         */
        /**
         * @en The event which will be triggered before the rendering process.
         * @zh 渲染过程之前所触发的事件。
         */
        static readonly EVENT_BEFORE_DRAW = "director_before_draw";
        /**
         * @en The event which will be triggered after the rendering process.
         * @zh 渲染过程之后所触发的事件。
         */
        /**
         * @en The event which will be triggered after the rendering process.
         * @zh 渲染过程之后所触发的事件。
         */
        static readonly EVENT_AFTER_DRAW = "director_after_draw";
        /**
         * The event which will be triggered before the physics process.<br/>
         * 物理过程之前所触发的事件。
         */
        static readonly EVENT_BEFORE_PHYSICS = "director_before_physics";
        /**
         * The event which will be triggered after the physics process.<br/>
         * 物理过程之后所触发的事件。
         */
        static readonly EVENT_AFTER_PHYSICS = "director_after_physics";
        static instance: Director;
        _compScheduler: ComponentScheduler;
        _nodeActivator: NodeActivator;
        private _invalid;
        private _paused;
        private _purgeDirectorInNextLoop;
        private _root;
        private _loadingScene;
        private _scene;
        private _totalFrames;
        private _lastUpdate;
        private _deltaTime;
        private _scheduler;
        private _systems;
        constructor();
        /**
         * calculates delta time since last time it was called
         */
        calculateDeltaTime(): void;
        /**
         * @en
         * Converts a view coordinate to an WebGL coordinate<br/>
         * Useful to convert (multi) touches coordinates to the current layout (portrait or landscape)<br/>
         * Implementation can be found in directorWebGL.
         * @zh 将触摸点的屏幕坐标转换为 WebGL View 下的坐标。
         * @deprecated since v2.0
         */
        convertToGL(uiPoint: Vec2): Vec2;
        /**
         * @en
         * Converts an OpenGL coordinate to a view coordinate<br/>
         * Useful to convert node points to window points for calls such as glScissor<br/>
         * Implementation can be found in directorWebGL.
         * @zh 将触摸点的 WebGL View 坐标转换为屏幕坐标。
         * @deprecated since v2.0
         */
        convertToUI(glPoint: Vec2): Vec2;
        /**
         * End the life of director in the next frame
         */
        end(): void;
        /**
         * @en
         * Returns the size of the WebGL view in points.<br/>
         * It takes into account any possible rotation (device orientation) of the window.
         * @zh 获取视图的大小，以点为单位。
         * @deprecated since v2.0
         */
        getWinSize(): import("cocos/core/math").Size;
        /**
         * @en
         * Returns the size of the OpenGL view in pixels.<br/>
         * It takes into account any possible rotation (device orientation) of the window.<br/>
         * On Mac winSize and winSizeInPixels return the same value.
         * (The pixel here refers to the resource resolution. If you want to get the physics resolution of device, you need to use `view.getFrameSize()`)
         * @zh
         * 获取视图大小，以像素为单位（这里的像素指的是资源分辨率。
         * 如果要获取屏幕物理分辨率，需要用 `view.getFrameSize()`）
         * @deprecated since v2.0
         */
        getWinSizeInPixels(): import("cocos/core/math").Size;
        /**
         * @en Pause the director's ticker, only involve the game logic execution.<br>
         * It won't pause the rendering process nor the event manager.<br>
         * If you want to pause the entire game including rendering, audio and event,<br>
         * please use `game.pause`.
         * @zh 暂停正在运行的场景，该暂停只会停止游戏逻辑执行，但是不会停止渲染和 UI 响应。<br>
         * 如果想要更彻底得暂停游戏，包含渲染，音频和事件，请使用 `game.pause` 。
         */
        pause(): void;
        /**
         * @en Removes cached all cocos2d cached data.
         * @zh 删除cocos2d所有的缓存数据
         * @deprecated since v2.0
         */
        purgeCachedData(): void;
        /**
         * @en Purge the `director` itself, including unschedule all schedule,<br>
         * remove all event listeners, clean up and exit the running scene, stops all animations, clear cached data.
         * @zh 清除 `director` 本身，包括停止所有的计时器，<br>
         * 移除所有的事件监听器，清理并退出当前运行的场景，停止所有动画，清理缓存数据。
         */
        purgeDirector(): void;
        /**
         * @en Reset the director, can be used to restart the director after purge
         * @zh 重置此 Director，可用于在清除后重启 Director。
         */
        reset(): void;
        /**
         * @en
         * Run a scene. Replaces the running scene with a new one or enter the first scene.<br>
         * The new scene will be launched immediately.
         * @zh 运行指定场景。将正在运行的场景替换为（或重入为）新场景。新场景将立即启动。
         * @param scene - The need run scene.
         * @param onBeforeLoadScene - The function invoked at the scene before loading.
         * @param onLaunched - The function invoked at the scene after launch.
         */
        runSceneImmediate(scene: Scene, onBeforeLoadScene?: Director.OnBeforeLoadScene, onLaunched?: Director.OnSceneLaunched): void;
        /**
         * @en
         * Run a scene. Replaces the running scene with a new one or enter the first scene.<br>
         * The new scene will be launched at the end of the current frame.<br>
         * @zh 运行指定场景。
         * @param scene - The need run scene.
         * @param onBeforeLoadScene - The function invoked at the scene before loading.
         * @param onLaunched - The function invoked at the scene after launch.
         * @private
         */
        runScene(scene: Scene, onBeforeLoadScene?: Director.OnBeforeLoadScene, onLaunched?: Director.OnSceneLaunched): void;
        _getSceneUuid(key: string | number): any;
        /**
         * @en Loads the scene by its name.
         * @zh 通过场景名称进行加载场景。
         *
         * @param sceneName - The name of the scene to load.
         * @param onLaunched - callback, will be called after scene launched.
         * @return if error, return false
         */
        loadScene(sceneName: string, onLaunched?: Director.OnSceneLaunched, onUnloaded?: Director.OnUnload): boolean;
        /**
         * @en
         * Pre-loads the scene to reduces loading time. You can call this method at any time you want.<br>
         * After calling this method, you still need to launch the scene by `director.loadScene`.<br>
         * It will be totally fine to call `director.loadScene` at any time even if the preloading is not<br>
         * yet finished, the scene will be launched after loaded automatically.
         * @zh 预加载场景，你可以在任何时候调用这个方法。
         * 调用完后，你仍然需要通过 `director.loadScene` 来启动场景，因为这个方法不会执行场景加载操作。<br>
         * 就算预加载还没完成，你也可以直接调用 `director.loadScene`，加载完成后场景就会启动。
         * @param sceneName 场景名称。
         * @param onLoaded 加载回调。
         */
        preloadScene(sceneName: string, onLoaded?: Director.OnSceneLoaded): void;
        /**
         * @en
         * Pre-loads the scene to reduces loading time. You can call this method at any time you want.<br>
         * After calling this method, you still need to launch the scene by `director.loadScene`.<br>
         * It will be totally fine to call `director.loadScene` at any time even if the preloading is not<br>
         * yet finished, the scene will be launched after loaded automatically.
         * @zh 预加载场景，你可以在任何时候调用这个方法。
         * 调用完后，你仍然需要通过 `director.loadScene` 来启动场景，因为这个方法不会执行场景加载操作。<br>
         * 就算预加载还没完成，你也可以直接调用 `director.loadScene`，加载完成后场景就会启动。
         * @param sceneName 场景名称。
         * @param onProgress 加载进度回调。
         * @param onLoaded 加载回调。
         */
        preloadScene(sceneName: string, onProgress: Director.OnLoadSceneProgress, onLoaded: Director.OnSceneLoaded): void;
        /**
         * @en Loads the scene by its uuid.
         * @zh 通过 uuid 加载场景。
         * @param uuid 场景资源的 uuid。
         * @param doNotRun 仅加载和初始化场景，但并不运行。此参数仅在编辑器环境中生效。
         */
        _loadSceneByUuid(uuid: string, doNotRun?: boolean): void;
        _loadSceneByUuid(uuid: string, onLaunched?: Director.OnSceneLaunched, doNotRun?: boolean): void;
        _loadSceneByUuid(uuid: string, onLaunched?: Director.OnSceneLaunched, onUnloaded?: Director.OnUnload, doNotRun?: boolean): void;
        /**
         * @en Resume game logic execution after pause, if the current scene is not paused, nothing will happen.
         * @zh 恢复暂停场景的游戏逻辑，如果当前场景没有暂停将没任何事情发生。
         */
        resume(): void;
        /**
         * @en
         * Enables or disables WebGL depth test.<br>
         * Implementation can be found in directorCanvas.js/directorWebGL.js
         * @zh 启用/禁用深度测试（在 Canvas 渲染模式下不会生效）。
         * @deprecated since v2.0
         */
        setDepthTest(value: boolean): void;
        /**
         * @en
         * Set color for clear screen.<br>
         * (Implementation can be found in directorCanvas.js/directorWebGL.js)
         * @zh
         * 设置场景的默认擦除颜色。<br>
         * 支持全透明，但不支持透明度为中间值。要支持全透明需手工开启 `macro.ENABLE_TRANSPARENT_CANVAS`。
         * @deprecated since v2.0
         */
        setClearColor(clearColor: Color): void;
        get root(): Root | null;
        /**
         * @en Returns current logic Scene.
         * @zh 获取当前逻辑场景。
         * @deprecated Since v2.0.
         */
        getRunningScene(): Scene | null;
        /**
         * @en Returns current logic Scene.
         * @zh 获取当前逻辑场景。
         * @example
         * ```
         * import { director } from 'cc';
         * // This will help you to get the Canvas node in scene
         * director.getScene().getChildByName('Canvas');
         * ```
         */
        getScene(): Scene | null;
        /**
         * @en Returns the FPS value. Please use [[Game.setFrameRate]] to control animation interval.
         * @zh 获取单位帧执行时间。请使用 [[Game.setFrameRate]] 来控制游戏帧率。
         * @deprecated since v2.0.
         */
        getAnimationInterval(): number;
        /**
         * @en Sets animation interval, this doesn't control the main loop.<br>
         * To control the game's frame rate overall, please use `game.setFrameRate`
         * @zh 设置动画间隔，这不控制主循环。<br>
         * 要控制游戏的帧速率，请使用 `game.setFrameRate`
         * @deprecated since v2.0
         * @param value - The animation interval desired.
         */
        setAnimationInterval(value: number): void;
        /**
         * @en Returns the delta time since last frame.
         * @zh 获取上一帧的增量时间。
         */
        getDeltaTime(): number;
        /**
         * @en Returns the current time.
         * @zh 获取当前帧的时间。
         */
        getCurrentTime(): number;
        /**
         * @en Returns how many frames were called since the director started.
         * @zh 获取 director 启动以来游戏运行的总帧数。
         */
        getTotalFrames(): number;
        /**
         * @en Returns whether or not the Director is paused.
         * @zh 是否处于暂停状态。
         */
        isPaused(): boolean;
        /**
         * @en Returns the scheduler associated with this director.
         * @zh 获取和 director 相关联的调度器。
         */
        getScheduler(): Scheduler;
        /**
         * @en Sets the scheduler associated with this director.
         * @zh 设置和 director 相关联的调度器。
         */
        setScheduler(scheduler: Scheduler): void;
        /**
         * @en Register a system.
         * @zh 注册一个系统。
         */
        registerSystem(name: string, sys: System, priority: number): void;
        unregisterSystem(sys: System): void;
        /**
         * @en get a system.
         * @zh 获取一个 system。
         */
        getSystem(name: string): System | undefined;
        /**
         * @en Returns the `AnimationManager` associated with this director. Please use getSystem(AnimationManager.ID)
         * @zh 获取和 director 相关联的 `AnimationManager`（动画管理器）。请使用 getSystem(AnimationManager.ID) 来替代
         * @deprecated
         */
        getAnimationManager(): any;
        /**
         * @en Starts Animation
         * @zh 开始动画
         */
        startAnimation(): void;
        /**
         * @en Stops animation
         * @zh 停止动画
         */
        stopAnimation(): void;
        /**
         * @en Run main loop of director
         * @zh 运行主循环
         */
        mainLoop(time: number): void;
        private _initOnRendererInitialized;
        private _init;
    }
    export namespace Director {
        type OnBeforeLoadScene = () => void;
        type OnUnload = () => void;
        type OnSceneLoaded = (error: null | Error, sceneAsset?: SceneAsset) => void;
        type OnSceneLaunched = (error: null | Error, scene?: Scene) => void;
        /**
         * @param completedCount - The number of the items that are already completed.
         * @param totalCount - The total number of the items.
         * @param item - The latest item which flow out the pipeline.
         */
        type OnLoadSceneProgress = (completedCount: number, totalCount: number, item: any) => void;
    }
    /**
     * 导演类。
     */
    export const director: Director;
}
declare module "cocos/core/components/ui-base/canvas" {
    import { RenderTexture } from "cocos/core/assets/render-texture";
    import { GFXClearFlag } from "cocos/core/gfx/define";
    import { Color } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    import { Component } from "cocos/core/components/component";
    /**
     * @en
     * The root node of UI.
     * Provide an aligned window for all child nodes, also provides ease of setting screen adaptation policy interfaces from the editor.
     * Line-of-sight range is -999 to 1000.
     *
     * @zh
     * 作为 UI 根节点，为所有子节点提供对齐视窗，另外提供屏幕适配策略接口，方便从编辑器设置。
     * 注：由于本节点的尺寸会跟随屏幕拉伸，所以 anchorPoint 只支持 (0.5, 0.5)，否则适配不同屏幕时坐标会有偏差。
     * UI 的视距范围是 -999 ～ 1000.
     */
    export class Canvas extends Component {
        /**
         * @en
         * The flags to clear the built in camera.
         *
         * @zh
         * 清理屏幕缓冲标记。
         */
        get clearFlag(): GFXClearFlag;
        set clearFlag(val: GFXClearFlag);
        /**
         * @en
         * The color clearing value of the builtin camera.
         *
         * @zh
         * 内置相机的颜色缓冲默认值。
         */
        get color(): Color;
        set color(val: Color);
        /**
         * @en
         * The render mode of Canvas.
         * When you choose the mode of INTERSPERSE, You can specify the rendering order of the Canvas with the camera in the scene.
         * When you choose the mode of OVERLAY, the builtin camera of Canvas will render after all scene cameras are rendered.
         * NOTE: The cameras in the scene (including the Canvas built-in camera) must have a ClearFlag selection of SOLID_COLOR,
         * otherwise a splash screen may appear on the mobile device.
         *
         * @zh
         * Canvas 渲染模式。
         * intersperse 下可以指定 Canvas 与场景中的相机的渲染顺序，overlay 下 Canvas 会在所有场景相机渲染完成后渲染。
         * 注意：场景里的相机（包括 Canvas 内置的相机）必须有一个的 ClearFlag 选择 SOLID_COLOR，否则在移动端可能会出现闪屏。
         */
        get renderMode(): number;
        set renderMode(val: number);
        /**
         * @en
         * Camera render priority.
         * When you choose the RenderModel of INTERSPERSE, specifies the render order with other cameras.
         * When you choose the RenderModel of OVERLAY, specifies sorting with the rest of the Canvas.
         *
         * @zh
         * 相机渲染优先级。当 RenderMode 为 intersperse 时，指定与其它相机的渲染顺序，当 RenderMode 为 overlay 时，指定跟其余 Canvas 做排序使用。需要对多 Canvas 设定 priority 以免出现不同平台下的闪屏问题。
         *
         * @param value - 渲染优先级。
         */
        get priority(): number;
        set priority(val: number);
        /**
         * @en
         * Set the target render texture.
         *
         * @zh
         * 设置目标渲染纹理。
         */
        get targetTexture(): RenderTexture | null;
        set targetTexture(value: RenderTexture | null);
        get visibility(): number;
        get camera(): scene.Camera | null;
        protected _priority: number;
        protected _targetTexture: RenderTexture | null;
        protected _clearFlag: GFXClearFlag;
        protected _color: Color;
        protected _renderMode: number;
        protected _thisOnResized: () => void;
        protected _camera: scene.Camera | null;
        private _pos;
        constructor();
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Screen alignment.
         *
         * @zh
         * 屏幕对齐。
         */
        alignWithScreen(): void;
        protected _checkTargetTextureEvent(old: RenderTexture | null): void;
        protected _updateTargetTexture(): void;
        private _getViewPriority;
    }
}
declare module "cocos/core/components/ui-base/ui-transform" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    import { SystemEventType } from "cocos/core/platform/event-manager/event-enum";
    import { EventListener } from "cocos/core/platform/event-manager/event-listener";
    import { Mat4, Rect, Size, Vec2, Vec3 } from "cocos/core/math/index";
    import { aabb } from "cocos/core/geometry/index";
    import { Canvas } from "cocos/core/components/ui-base/canvas";
    import { Node } from "cocos/core/scene-graph/index";
    /**
     * @en
     * The component of transform in UI.
     *
     * @zh
     * UI 变换组件。
     */
    export class UITransform extends Component {
        /**
         * @en
         * Size of the UI node.
         *
         * @zh
         * 内容尺寸。
         */
        get contentSize(): Readonly<Size>;
        set contentSize(value: Readonly<Size>);
        get width(): number;
        set width(value: number);
        get height(): number;
        set height(value: number);
        /**
         * @en
         * Anchor point of the UI node.
         *
         * @zh
         * 锚点位置。
         */
        get anchorPoint(): Readonly<Vec2>;
        set anchorPoint(value: Readonly<Vec2>);
        get anchorX(): number;
        set anchorX(value: number);
        get anchorY(): number;
        set anchorY(value: number);
        /**
         * @en
         * Render sequence.
         * Note: UI rendering is only about priority.
         *
         * @zh
         * 渲染先后顺序，按照广度渲染排列，按同级节点下进行一次排列。
         */
        get priority(): number;
        set priority(value: number);
        protected _priority: number;
        /**
         * @zh
         * 查找被渲染相机。
         */
        get visibility(): number;
        static EventType: typeof SystemEventType;
        _canvas: Canvas | null;
        protected _contentSize: Size;
        protected _anchorPoint: Vec2;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Sets the untransformed size of the node.<br/>
         * The contentSize remains the same no matter if the node is scaled or rotated.<br/>
         * All nodes have a size. Layer and Scene have the same size of the screen.
         *
         * @zh
         * 设置节点原始大小，不受该节点是否被缩放或者旋转的影响。
         *
         * @param size - 节点内容变换的尺寸或者宽度。
         * @param height - 节点内容未变换的高度。
         * @example
         * ```ts
         * import { Size } from 'cc';
         * node.setContentSize(new Size(100, 100));
         * node.setContentSize(100, 100);
         * ```
         */
        setContentSize(size: Size | number, height?: number): void;
        /**
         * @en
         * Sets the anchor point in percent. <br/>
         * anchor point is the point around which all transformations and positioning manipulations take place. <br/>
         * It's like a pin in the node where it is "attached" to its parent. <br/>
         * The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.<br/>
         * But you can use values higher than (1,1) and lower than (0,0) too.<br/>
         * The default anchor point is (0.5,0.5), so it starts at the center of the node.
         *
         * @zh
         * 设置锚点的百分比。<br>
         * 锚点应用于所有变换和坐标点的操作，它就像在节点上连接其父节点的大头针。<br>
         * 锚点是标准化的，就像百分比一样。(0，0) 表示左下角，(1，1) 表示右上角。<br>
         * 但是你可以使用比（1，1）更高的值或者比（0，0）更低的值。<br>
         * 默认的锚点是（0.5，0.5），因此它开始于节点的中心位置。<br>
         * 注意：Creator 中的锚点仅用于定位所在的节点，子节点的定位不受影响。
         *
         * @param point - 节点锚点或节点 x 轴锚。
         * @param y - 节点 y 轴锚。
         * @example
         * ```ts
         * import { Vec2 } from 'cc';
         * node.setAnchorPoint(new Vec2(1, 1));
         * node.setAnchorPoint(1, 1);
         * ```
         */
        setAnchorPoint(point: Vec2 | number, y?: number): void;
        /**
         * @zh
         * 当前节点的点击计算。
         *
         * @param point - 屏幕点。
         * @param listener - 事件监听器。
         */
        isHit(point: Vec2, listener?: EventListener): any;
        /**
         * @en
         * Converts a Point to node (local) space coordinates.
         *
         * @zh
         * 将一个 UI 节点世界坐标系下点转换到另一个 UI 节点 (局部) 空间坐标系，这个坐标系以锚点为原点。
         * 非 UI 节点转换到 UI 节点(局部) 空间坐标系，请走 Camera 的 `convertToUINode`。
         *
         * @param worldPoint - 世界坐标点。
         * @param out - 转换后坐标。
         * @returns - 返回与目标节点的相对位置。
         * @example
         * ```ts
         * const newVec3 = uiTransform.convertToNodeSpaceAR(cc.v3(100, 100, 0));
         * ```
         */
        convertToNodeSpaceAR(worldPoint: Vec3, out?: Vec3): Vec3;
        /**
         * @en
         * Converts a Point in node coordinates to world space coordinates.
         *
         * @zh
         * 将距当前节点坐标系下的一个点转换到世界坐标系。
         *
         * @param nodePoint - 节点坐标。
         * @param out - 转换后坐标。
         * @returns - 返回 UI 世界坐标系。
         * @example
         * ```ts
         * const newVec3 = uiTransform.convertToWorldSpaceAR(3(100, 100, 0));
         * ```
         */
        convertToWorldSpaceAR(nodePoint: Vec3, out?: Vec3): Vec3;
        /**
         * @en
         * Returns a "local" axis aligned bounding box of the node. <br/>
         * The returned box is relative only to its parent.
         *
         * @zh
         * 返回父节坐标系下的轴向对齐的包围盒。
         *
         * @return - 节点大小的包围盒
         * @example
         * ```ts
         * const boundingBox = uiTransform.getBoundingBox();
         * ```
         */
        getBoundingBox(): Rect;
        /**
         * @en
         * Returns a "world" axis aligned bounding box of the node.<br/>
         * The bounding box contains self and active children's world bounding box.
         *
         * @zh
         * 返回节点在世界坐标系下的对齐轴向的包围盒（AABB）。
         * 该边框包含自身和已激活的子节点的世界边框。
         *
         * @returns - 返回世界坐标系下包围盒。
         * @example
         * ```ts
         * const newRect = uiTransform.getBoundingBoxToWorld();
         * ```
         */
        getBoundingBoxToWorld(): Rect;
        /**
         * @en
         * Returns the minimum bounding box containing the current bounding box and its child nodes.
         *
         * @zh
         * 返回包含当前包围盒及其子节点包围盒的最小包围盒。
         *
         * @param parentMat - 父节点矩阵。
         * @returns
         */
        getBoundingBoxTo(parentMat: Mat4): Rect;
        /**
         * @en
         * Compute the corresponding aabb in world space for raycast.
         *
         * @zh
         * 计算出此 UI_2D 节点在世界空间下的 aabb 包围盒
         */
        getComputeAABB(out?: aabb): aabb | undefined;
        _updateVisibility(): void;
        protected _parentChanged(node: Node): void;
        protected _sortSiblings(): void;
    }
}
declare module "cocos/core/components/ui-base/ui-renderable" {
    import { Color } from "cocos/core/math/index";
    import { Material } from "cocos/core/assets/index";
    import { GFXBlendFactor } from "cocos/core/gfx/define";
    import { MaterialInstance } from "cocos/core/renderer/index";
    import { IAssembler, IAssemblerManager } from "cocos/core/renderer/ui/base";
    import { RenderData } from "cocos/core/renderer/ui/render-data";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { Node } from "cocos/core/scene-graph/index";
    import { TransformBit } from "cocos/core/scene-graph/node-enum";
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    /**
     * @en
     * The shader property type of the material after instantiation.
     *
     * @zh
     * 实例后的材质的着色器属性类型。
     */
    export enum InstanceMaterialType {
        /**
         * @en
         * The shader only has color properties.
         *
         * @zh
         * 着色器只带颜色属性。
         */
        ADD_COLOR = 0,
        /**
         * @en
         * The shader has color and texture properties.
         *
         * @zh
         * 着色器带颜色和贴图属性。
         */
        ADD_COLOR_AND_TEXTURE = 1,
        /**
         * @en
         * The shader has color and texture properties and uses grayscale mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用灰度模式。
         */
        GRAYSCALE = 2,
        /**
         * @en
         * The shader has color and texture properties and uses embedded alpha mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用透明通道分离贴图。
         */
        USE_ALPHA_SEPARATED = 3,
        /**
         * @en
         * The shader has color and texture properties and uses embedded alpha and grayscale mode.
         *
         * @zh
         * 着色器带颜色和贴图属性,并使用灰度模式。
         */
        USE_ALPHA_SEPARATED_AND_GRAY = 4
    }
    /**
     * @en
     * Base class for components which supports rendering features.
     *
     * @zh
     * 所有支持渲染的 UI 组件的基类。
     */
    export class UIRenderable extends RenderableComponent {
        /**
         * @en
         * Specifies the blend mode for the original image, it will clone a new material object.
         *
         * @zh
         * 指定原图的混合模式，这会克隆一个新的材质对象，注意这带来的。
         *
         * @param value 原图混合模式。
         * @example
         * ```ts
         * sprite.srcBlendFactor = GFXBlendFactor.ONE;
         * ```
         */
        get srcBlendFactor(): GFXBlendFactor;
        set srcBlendFactor(value: GFXBlendFactor);
        /**
         * @en
         * Specifies the blend mode for the target image.
         *
         * @zh
         * 指定目标的混合模式。
         *
         * @param value 目标混合模式。
         * @example
         * ```ts
         * sprite.dstBlendFactor = GFXBlendFactor.ONE;
         * ```
         */
        get dstBlendFactor(): GFXBlendFactor;
        set dstBlendFactor(value: GFXBlendFactor);
        /**
         * @en
         * Render color.
         *
         * @zh
         * 渲染颜色。
         *
         * @param value 渲染颜色。
         */
        get color(): Readonly<Color>;
        set color(value: Readonly<Color>);
        protected _uiMaterial: Material | null;
        protected _uiMaterialIns: MaterialInstance | null;
        protected getUIRenderMaterial(): MaterialInstance | Material | null;
        getUIMaterialInstance(): MaterialInstance;
        protected _uiMaterialDirty: boolean;
        protected _uiMatInsDirty: boolean;
        get uiMaterial(): Material | null;
        set uiMaterial(val: Material | null);
        get renderData(): RenderData | null;
        set delegateSrc(value: Node);
        static BlendState: typeof GFXBlendFactor;
        static Assembler: IAssemblerManager | null;
        static PostAssembler: IAssemblerManager | null;
        protected _srcBlendFactor: GFXBlendFactor;
        protected _dstBlendFactor: GFXBlendFactor;
        protected _color: Color;
        protected _assembler: IAssembler | null;
        protected _postAssembler: IAssembler | null;
        protected _renderData: RenderData | null;
        protected _renderDataFlag: boolean;
        protected _renderFlag: boolean;
        protected _delegateSrc: Node | null;
        protected _instanceMaterialType: InstanceMaterialType;
        protected _blendTemplate: {
            blendState: {
                targets: {
                    blendSrc: GFXBlendFactor;
                    blendDst: GFXBlendFactor;
                }[];
            };
        };
        protected _lastParent: Node | null;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Marks the render data of the current component as modified so that the render data is recalculated.
         *
         * @zh
         * 标记当前组件的渲染数据为已修改状态，这样渲染数据才会重新计算。
         *
         * @param enable 是否标记为已修改。
         */
        markForUpdateRenderData(enable?: boolean): void;
        /**
         * @en
         * Request a new render data.
         *
         * @zh
         * 请求渲染数据。
         *
         * @return 渲染数据 RenderData。
         */
        requestRenderData(): RenderData;
        /**
         * @en
         * Destroy render data.
         *
         * @zh
         * 渲染数据销毁。
         */
        destroyRenderData(): void;
        updateAssembler(render: UI): void;
        postUpdateAssembler(render: UI): void;
        protected _render(render: UI): void;
        protected _postRender(render: UI): void;
        protected _checkAndUpdateRenderData(): void;
        protected _canRender(): boolean;
        protected _postCanRender(): void;
        protected _updateColor(): void;
        _updateBlendFunc(): MaterialInstance | Material | null;
        protected _nodeStateChange(type: TransformBit): void;
        _updateBuiltinMaterial(): Material;
        protected _flushAssembler?(): void;
    }
}
declare module "cocos/core/components/component-event-handler" {
    import { Node } from "cocos/core/scene-graph/index";
    /**
     * @zh
     * “EventHandler” 类用来设置场景中的事件回调，该类允许用户设置回调目标节点，目标组件名，组件方法名，并可通过 emit 方法调用目标函数。
     *
     * @example
     * ```ts
     * import { Component } from 'cc';
     * const eventHandler = new Component.EventHandler();
     * eventHandler.target = newTarget;
     * eventHandler.component = "MainMenu";
     * eventHandler.handler = "OnClick";
     * eventHandler.customEventData = "my data";
     * ```
     */
    export class EventHandler {
        get _componentName(): any;
        set _componentName(value: any);
        /**
         * @zh
         * 组件事件派发。
         *
         * @param events - 需要派发的组件事件列表。
         * @param args - 派发参数数组。
         */
        static emitEvents(events: EventHandler[], ...args: any[]): void;
        /**
         * @zh
         * 目标节点。
         */
        target: Node | null;
        /**
         * @zh
         * 目标组件名。
         */
        component: string;
        _componentId: string;
        /**
         * @zh
         * 响应事件函数名。
         */
        handler: string;
        /**
         * @zh
         * 自定义事件数据。
         */
        customEventData: string;
        /**
         * @zh
         * 触发目标组件上的指定 handler 函数，该参数是回调函数的参数值（可不填）。
         *
         * @param params - 派发参数数组。
         * @example
         * ```ts
         * import { Component } from 'cc';
         * const eventHandler = new Component.EventHandler();
         * eventHandler.target = newTarget;
         * eventHandler.component = "MainMenu";
         * eventHandler.handler = "OnClick"
         * eventHandler.emit(["param1", "param2", ....]);
         * ```
         */
        emit(params: any[]): void;
        private _compName2Id;
        private _compId2Name;
        private _genCompIdIfNeeded;
    }
}
declare module "cocos/core/components/index" {
    /**
     * @hidden
     */
    export { default as System } from "cocos/core/components/system";
    export { default as MissingScript } from "cocos/core/components/missing-script";
    export { EventHandler } from "cocos/core/components/component-event-handler";
    export { Component } from "cocos/core/components/component";
}
declare module "cocos/core/platform/event-manager/system-event" {
    /**
     * @category event
     */
    import { EventTarget } from "cocos/core/event/event-target";
    import { EventAcceleration, EventKeyboard, EventMouse, EventTouch } from "cocos/core/platform/event-manager/events";
    import { SystemEventType } from "cocos/core/platform/event-manager/event-enum";
    import { Touch } from "cocos/core/platform/event-manager/touch";
    /**
    * @en
    * The System event, it currently supports keyboard events and accelerometer events.<br/>
    * You can get the `SystemEvent` instance with `systemEvent`.<br/>
    * @zh
    * 系统事件，它目前支持按键事件和重力感应事件。<br/>
    * 你可以通过 `systemEvent` 获取到 `SystemEvent` 的实例。<br/>
    * @example
    * ```
    * import { systemEvent, SystemEvent } from 'cc';
    * systemEvent.on(SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
    * systemEvent.off(SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this);
    * ```
    */
    export class SystemEvent extends EventTarget {
        static EventType: typeof SystemEventType;
        constructor();
        /**
         * @en
         * Sets whether to enable the accelerometer event listener or not.
         *
         * @zh
         * 是否启用加速度计事件。
         */
        setAccelerometerEnabled(isEnabled: boolean): void;
        /**
         * @en
         * Sets the accelerometer interval value.
         *
         * @zh
         * 设置加速度计间隔值。
         */
        setAccelerometerInterval(interval: number): void;
        on(type: SystemEventType.KEY_DOWN | SystemEventType.KEY_UP, callback: (event?: EventKeyboard) => void, target?: Object): any;
        on(type: SystemEventType.MOUSE_DOWN | SystemEventType.MOUSE_ENTER | SystemEventType.MOUSE_LEAVE | SystemEventType.MOUSE_MOVE | SystemEventType.MOUSE_UP | SystemEventType.MOUSE_WHEEL, callback: (event?: EventMouse) => void, target?: Object): any;
        on(type: SystemEventType.TOUCH_START | SystemEventType.TOUCH_MOVE | SystemEventType.TOUCH_END | SystemEventType.TOUCH_CANCEL, callback: (touch?: Touch, event?: EventTouch) => void, target?: Object): any;
        on(type: SystemEventType.DEVICEMOTION, callback: (event?: EventAcceleration) => void, target?: Object): any;
        /**
         * @en
         * Removes the listeners previously registered with the same type, callback, target and or useCapture,
         * if only type is passed as parameter, all listeners registered with that type will be removed.
         * @zh
         * 删除之前用同类型，回调，目标或 useCapture 注册的事件监听器，如果只传递 type，将会删除 type 类型的所有事件监听器。
         *
         * @param type - A string representing the event type being removed.
         * @param callback - The callback to remove.
         * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
         */
        off(type: string, callback?: Function, target?: Object): void;
    }
    /**
     * @module cc
     */
    /**
     * @en The singleton of the SystemEvent, there should only be one instance to be used globally
     * @zh 系统事件单例，方便全局使用。
     */
    export const systemEvent: SystemEvent;
}
declare module "cocos/core/platform/event-manager/deprecated" { }
declare module "cocos/core/platform/event-manager/index" {
    /**
     * @category event
     */
    export * from "cocos/core/platform/event-manager/event-manager";
    export * from "cocos/core/platform/event-manager/input-manager";
    export * from "cocos/core/platform/event-manager/system-event";
    export * from "cocos/core/platform/event-manager/events";
    export * from "cocos/core/platform/event-manager/touch";
    export * from "cocos/core/platform/event-manager/event-enum";
    import "cocos/core/platform/event-manager/deprecated";
}
declare module "cocos/core/platform/screen" {
    /**
     * @en The screen API provides an easy way for web content to be presented using the user's entire screen.
     * It's designed for web platforms and some mobile browsers don't provide such behavior, e.g. Safari
     * @zh screen 单例对象提供简单的方法来尝试让 Web 内容进入全屏模式。这是 Web 平台特有的行为，在部分浏览器上并不支持这样的功能。
     */
    const screen: {
        _supportsFullScreen: boolean;
        _preOnFullScreenChange: any;
        _touchEvent: string;
        _fn: any;
        _fnMap: string[][];
        /**
         * @en Initialization
         * @zh 初始化函数
         */
        init(): void;
        /**
         * @en Return true if it's in full screen state now.
         * @zh 当前是否处在全屏状态下
         * @returns {Boolean}
         */
        fullScreen(): boolean;
        /**
         * @en Request to enter full screen mode with the given element.
         * Many browser forbid to enter full screen mode without an user intended interaction.
         * For simplify the process, you can try to use {{autoFullScreen}} which will try to enter full screen mode during the next user touch event.
         * @zh 尝试使当前节点进入全屏模式，很多浏览器不允许程序触发这样的行为，必须在一个用户交互回调中才会生效。
         * 如果希望更简单一些，可以尝试用 {{autoFullScreen}} 来自动监听用户触摸事件并在下一次触摸事件中尝试进入全屏模式。
         * @param element The element to request full screen state
         * @param onFullScreenChange callback function when full screen state changed
         */
        requestFullScreen(element: HTMLElement, onFullScreenChange: (this: Document, ev: any) => any): any;
        /**
         * @en Exit the full mode.
         * @zh 退出全屏模式
         * @return Success or not
         */
        exitFullScreen(): boolean;
        /**
         * @en Automatically request full screen during the next touch/click event
         * @zh 自动监听触摸、鼠标事件并在下一次事件触发时尝试进入全屏模式
         * @param element The element to request full screen state
         * @param onFullScreenChange callback function when full screen state changed
         */
        autoFullScreen(element: HTMLElement, onFullScreenChange: (this: Document, ev: any) => any): void;
    };
    export { screen };
}
declare module "cocos/ui/components/sprite" {
    /**
     * @category ui
     */
    import { SpriteAtlas, SpriteFrame } from "cocos/core/assets/index";
    import { Vec2 } from "cocos/core/math/index";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    /**
     * @en
     * Enum for sprite type.
     *
     * @zh
     * Sprite 类型。
     */
    enum SpriteType {
        /**
         * @en
         * The simple type.
         *
         * @zh
         * 普通类型。
         */
        SIMPLE = 0,
        /**
         * @en
         * The sliced type.
         *
         * @zh
         * 切片（九宫格）类型。
         */
        SLICED = 1,
        /**
         * @en
         * The tiled type.
         *
         * @zh  平铺类型
         */
        TILED = 2,
        /**
         * @en
         * The filled type.
         *
         * @zh
         * 填充类型。
         */
        FILLED = 3
    }
    /**
     * @en
     * Enum for fill type.
     *
     * @zh
     * 填充类型。
     */
    enum FillType {
        /**
         * @en
         * The horizontal fill.
         *
         * @zh
         * 水平方向填充。
         */
        HORIZONTAL = 0,
        /**
         * @en
         * The vertical fill.
         *
         * @zh
         * 垂直方向填充。
         */
        VERTICAL = 1,
        /**
         * @en
         * The radial fill.
         *
         * @zh  径向填充
         */
        RADIAL = 2
    }
    /**
     * @en
     * Sprite Size can track trimmed size, raw size or none.
     *
     * @zh
     * 精灵尺寸调整模式。
     */
    enum SizeMode {
        /**
         * @en
         * Use the customized node size.
         *
         * @zh
         * 使用节点预设的尺寸。
         */
        CUSTOM = 0,
        /**
         * @en
         * Match the trimmed size of the sprite frame automatically.
         *
         * @zh
         * 自动适配为精灵裁剪后的尺寸。
         */
        TRIMMED = 1,
        /**
         * @en
         * Match the raw size of the sprite frame automatically.
         *
         * @zh
         * 自动适配为精灵原图尺寸。
         */
        RAW = 2
    }
    enum EventType {
        SPRITE_FRAME_CHANGED = "spriteframe-changed"
    }
    /**
     * @en
     * Renders a sprite in the scene.
     *
     * @zh
     * 渲染精灵组件。
     */
    export class Sprite extends UIRenderable {
        /**
         * @en
         * The sprite atlas where the sprite is.
         *
         * @zh
         * 精灵的图集。
         */
        get spriteAtlas(): SpriteAtlas | null;
        set spriteAtlas(value: SpriteAtlas | null);
        /**
         * @en
         * The sprite frame of the sprite.
         *
         * @zh
         * 精灵的精灵帧。
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en
         * The sprite render type.
         *
         * @zh
         * 精灵渲染类型。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.type = Sprite.Type.SIMPLE;
         * ```
         */
        get type(): SpriteType;
        set type(value: SpriteType);
        /**
         * @en
         * The fill type, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 精灵填充类型，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.fillType = Sprite.FillType.HORIZONTAL;
         * ```
         */
        get fillType(): FillType;
        set fillType(value: FillType);
        /**
         * @en
         * The fill Center, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充中心点，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * import { Vec2 } from 'cc';
         * sprite.fillCenter = new Vec2(0, 0);
         * ```
         */
        get fillCenter(): Vec2;
        set fillCenter(value: Vec2);
        /**
         * @en
         * The fill Start, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充起始点，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * // -1 To 1 between the numbers
         * sprite.fillStart = 0.5;
         * ```
         */
        get fillStart(): number;
        set fillStart(value: number);
        /**
         * @en
         * The fill Range, This will only have any effect if the "type" is set to “Sprite.Type.FILLED”.
         *
         * @zh
         * 填充范围，仅渲染类型设置为 Sprite.Type.FILLED 时有效。
         *
         * @example
         * ```ts
         * // -1 To 1 between the numbers
         * sprite.fillRange = 1;
         * ```
         */
        get fillRange(): number;
        set fillRange(value: number);
        /**
         * @en
         * specify the frame is trimmed or not.
         *
         * @zh
         * 是否使用裁剪模式。
         *
         * @example
         * ```ts
         * sprite.trim = true;
         * ```
         */
        get trim(): boolean;
        set trim(value: boolean);
        get grayscale(): boolean;
        set grayscale(value: boolean);
        /**
         * @en
         * Specify the size tracing mode.
         *
         * @zh
         * 精灵尺寸调整模式。
         *
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * sprite.sizeMode = Sprite.SizeMode.CUSTOM;
         * ```
         */
        get sizeMode(): SizeMode;
        set sizeMode(value: SizeMode);
        static FillType: typeof FillType;
        static Type: typeof SpriteType;
        static SizeMode: typeof SizeMode;
        static EventType: typeof EventType;
        protected _spriteFrame: SpriteFrame | null;
        protected _type: SpriteType;
        protected _fillType: FillType;
        protected _sizeMode: SizeMode;
        protected _fillCenter: Vec2;
        protected _fillStart: number;
        protected _fillRange: number;
        protected _isTrimmedMode: boolean;
        protected _useGrayscale: boolean;
        protected _atlas: SpriteAtlas | null;
        __preload(): void;
        onEnable(): void;
        onDestroy(): void;
        /**
         * @en
         * Quickly switch to other sprite frame in the sprite atlas.
         * If there is no atlas, the switch fails.
         *
         * @zh
         * 精灵图集内的精灵替换
         *
         * @returns
         */
        changeSpriteFrameFromAtlas(name: string): void;
        changeMaterialForDefine(): void;
        protected _render(render: UI): void;
        protected _canRender(): boolean;
        protected _flushAssembler(): void;
        private _applySpriteSize;
        private _resized;
        private _activateMaterial;
        private _onTextureLoaded;
        private _applySpriteFrame;
        /**
         * 强制刷新 uv。
         */
        private _markForUpdateUvDirty;
    }
}
declare module "cocos/core/platform/SubContextView" {
    /**
     * @category component
     */
    import { Component } from "cocos/core/components/component";
    /**
     * @en SubContextView is a view component which controls open data context viewport in WeChat game platform.<br/>
     * The component's node size decide the viewport of the sub context content in main context,
     * the entire sub context texture will be scaled to the node's bounding box area.<br/>
     * This component provides multiple important features:<br/>
     * 1. Sub context could use its own resolution size and policy.<br/>
     * 2. Sub context could be minized to smallest size it needed.<br/>
     * 3. Resolution of sub context content could be increased.<br/>
     * 4. User touch input is transformed to the correct viewport.<br/>
     * 5. Texture update is handled by this component. User don't need to worry.<br/>
     * One important thing to be noted, whenever the node's bounding box change,
     * you need to manually reset the viewport of sub context using updateSubContextViewport.
     * @zh SubContextView 可以用来控制微信小游戏平台开放数据域在主域中的视窗的位置。<br/>
     * 这个组件的节点尺寸决定了开放数据域内容在主域中的尺寸，整个开放数据域会被缩放到节点的包围盒范围内。<br/>
     * 在这个组件的控制下，用户可以更自由得控制开放数据域：<br/>
     * 1. 子域中可以使用独立的设计分辨率和适配模式<br/>
     * 2. 子域区域尺寸可以缩小到只容纳内容即可<br/>
     * 3. 子域的分辨率也可以被放大，以便获得更清晰的显示效果<br/>
     * 4. 用户输入坐标会被自动转换到正确的子域视窗中<br/>
     * 5. 子域内容贴图的更新由组件负责，用户不需要处理<br/>
     * 唯一需要注意的是，当子域节点的包围盒发生改变时，开发者需要使用 `updateSubContextViewport` 来手动更新子域视窗。
     */
    export class SubContextView extends Component {
        get fps(): number;
        set fps(value: number);
        private _fps;
        private _sprite;
        private _imageAsset;
        private _context;
        private _updatedTime;
        private _updateInterval;
        private _firstlyEnabled;
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        update(dt: number): void;
        /**
         * @en Reset open data context size and viewport
         * @zh 重置开放数据域的尺寸和视窗
         */
        reset(): void;
        /**
         * @en Update the sub context viewport manually, it should be called whenever the node's bounding box changes.
         * @zh 更新开放数据域相对于主域的 viewport，这个函数应该在节点包围盒改变时手动调用。
         */
        updateSubContextViewport(): void;
        private _updateSubContextTexture;
        private _registerNodeEvent;
        private _unregisterNodeEvent;
        private _runSubContextMainLoop;
        private _stopSubContextMainLoop;
        private _updateSubContextFrameRate;
    }
}
declare module "cocos/core/platform/index" {
    /**
     * @hidden
     */
    export * from "cocos/core/platform/sys";
    export * from "cocos/core/platform/macro";
    export * from "cocos/core/platform/visible-rect";
    export * from "cocos/core/platform/view";
    export * from "cocos/core/platform/event-manager/index";
    export { log, error, warn, assert, logID, errorID, warnID, assertID, isDisplayStats, setDisplayStats, } from "cocos/core/platform/debug";
    export { screen } from "cocos/core/platform/screen";
    export { SubContextView } from "cocos/core/platform/SubContextView";
}
declare module "cocos/ui/components/button" {
    /**
     * 用户界面组件
     * @category ui
     */
    import { SpriteFrame } from "cocos/core/assets/index";
    import { Component, EventHandler as ComponentEventHandler } from "cocos/core/components/index";
    import { EventMouse, EventTouch } from "cocos/core/platform/index";
    import { Color } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/node";
    import { Sprite } from "cocos/ui/components/sprite";
    /**
     * @en Enum for transition type.
     *
     * @zh 过渡类型。
     */
    enum Transition {
        /**
         * @en The none type.
         *
         * @zh 不做任何过渡。
         */
        NONE = 0,
        /**
         * @en The color type.
         *
         * @zh 颜色过渡。
         */
        COLOR = 1,
        /**
         * @en The sprite type.
         *
         * @zh 精灵过渡。
         */
        SPRITE = 2,
        /**
         * @en The scale type.
         *
         * @zh 缩放过渡。
         */
        SCALE = 3
    }
    export enum EventType {
        CLICK = "click"
    }
    /**
     * @en
     * Button has 4 Transition types<br/>
     * When Button state changed:<br/>
     *  If Transition type is Button.Transition.NONE, Button will do nothing<br/>
     *  If Transition type is Button.Transition.COLOR, Button will change target's color<br/>
     *  If Transition type is Button.Transition.SPRITE, Button will change target Sprite's sprite<br/>
     *  If Transition type is Button.Transition.SCALE, Button will change target node's scale<br/>
     *
     * Button will trigger 5 events:<br/>
     *  Button.EVENT_TOUCH_DOWN<br/>
     *  Button.EVENT_TOUCH_UP<br/>
     *  Button.EVENT_HOVER_IN<br/>
     *  Button.EVENT_HOVER_MOVE<br/>
     *  Button.EVENT_HOVER_OUT<br/>
     *  User can get the current clicked node with 'event.target' from event object which is passed as parameter in the callback function of click event.
     *
     * @zh
     * 按钮组件。可以被按下,或者点击。<br/>
     *
     * 按钮可以通过修改 Transition 来设置按钮状态过渡的方式：<br/>
     *   - `Button.Transition.NONE`   // 不做任何过渡<br/>
     *   - `Button.Transition.COLOR`  // 进行颜色之间过渡<br/>
     *   - `Button.Transition.SPRITE` // 进行精灵之间过渡<br/>
     *   - `Button.Transition.SCALE` // 进行缩放过渡<br/>
     *
     * 按钮可以绑定事件（但是必须要在按钮的 Node 上才能绑定事件）：<br/>
     *   // 以下事件可以在全平台上都触发<br/>
     *   - `Node.EventType.TOUCH_START`  // 按下时事件<br/>
     *   - `Node.EventType.TOUCH_Move`   // 按住移动后事件<br/>
     *   - `Node.EventType.TOUCH_END`    // 按下后松开后事件<br/>
     *   - `Node.EventType.TOUCH_CANCEL` // 按下取消事件<br/>
     *   // 以下事件只在 PC 平台上触发<br/>
     *   - `Node.EventType.MOUSE_DOWN`  // 鼠标按下时事件<br/>
     *   - `Node.EventType.MOUSE_MOVE`  // 鼠标按住移动后事件<br/>
     *   - `Node.EventType.MOUSE_ENTER` // 鼠标进入目标事件<br/>
     *   - `Node.EventType.MOUSE_LEAVE` // 鼠标离开目标事件<br/>
     *   - `Node.EventType.MOUSE_UP`    // 鼠标松开事件<br/>
     *   - `Node.EventType.MOUSE_WHEEL` // 鼠标滚轮事件<br/>
     *
     * @example
     * ```ts
     * import { log, Node } from 'cc';
     * // Add an event to the button.
     * button.node.on(Node.EventType.TOUCH_START, (event) => {
     *     log("This is a callback after the trigger event");
     * });
     * // You could also add a click event
     * //Note: In this way, you can't get the touch event info, so use it wisely.
     * button.node.on('click', (button) => {
     *    //The event is a custom event, you could get the Button component via first argument
     * })
     * ```
     */
    export class Button extends Component {
        /**
         * @en
         * Transition target.
         * When Button state changed:
         * - If Transition type is Button.Transition.NONE, Button will do nothing.
         * - If Transition type is Button.Transition.COLOR, Button will change target's color.
         * - If Transition type is Button.Transition.SPRITE, Button will change target Sprite's sprite.
         *
         * @zh
         * 需要过渡的目标。<br/>
         * 当前按钮状态改变规则：<br/>
         * - 如果 Transition type 选择 Button.Transition.NONE，按钮不做任何过渡。
         * - 如果 Transition type 选择 Button.Transition.COLOR，按钮会对目标颜色进行颜色之间的过渡。
         * - 如果 Transition type 选择 Button.Transition.Sprite，按钮会对目标 Sprite 进行 Sprite 之间的过渡。
         */
        get target(): Node | null;
        set target(value: Node | null);
        /**
         * @en
         * Whether the Button is disabled.
         * If true, the Button will trigger event and do transition.
         *
         * @zh
         * 按钮事件是否被响应，如果为 false，则按钮将被禁用。
         */
        get interactable(): boolean;
        set interactable(value: boolean);
        set _resizeToTarget(value: boolean);
        /**
         * @en
         * Transition type.
         *
         * @zh
         * 按钮状态改变时过渡方式。
         */
        get transition(): Transition;
        set transition(value: Transition);
        /**
         * @en
         * Normal state color.
         *
         * @zh
         * 普通状态下按钮所显示的颜色。
         */
        get normalColor(): Readonly<Color>;
        set normalColor(value: Readonly<Color>);
        /**
         * @en
         * Pressed state color.
         *
         * @zh
         * 按下状态时按钮所显示的颜色。
         */
        get pressedColor(): Readonly<Color>;
        set pressedColor(value: Readonly<Color>);
        /**
         * @en
         * Hover state color.
         *
         * @zh
         * 悬停状态下按钮所显示的颜色。
         */
        get hoverColor(): Readonly<Color>;
        set hoverColor(value: Readonly<Color>);
        /**
         * @en
         * Disabled state color.
         *
         * @zh
         * 禁用状态下按钮所显示的颜色。
         */
        get disabledColor(): Readonly<Color>;
        set disabledColor(value: Readonly<Color>);
        /**
         * @en
         * Color and Scale transition duration.
         *
         * @zh
         * 颜色过渡和缩放过渡时所需时间。
         */
        get duration(): number;
        set duration(value: number);
        /**
         * @en
         * When user press the button, the button will zoom to a scale.
         * The final scale of the button equals (button original scale * zoomScale)
         *
         * @zh
         * 当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale。
         */
        get zoomScale(): number;
        set zoomScale(value: number);
        /**
         * @en
         * Normal state sprite.
         *
         * @zh
         * 普通状态下按钮所显示的 Sprite。
         */
        get normalSprite(): SpriteFrame | null;
        set normalSprite(value: SpriteFrame | null);
        /**
         * @en
         * Pressed state sprite.
         *
         * @zh
         * 按下状态时按钮所显示的 Sprite。
         */
        get pressedSprite(): SpriteFrame | null;
        set pressedSprite(value: SpriteFrame | null);
        /**
         * @en
         * Hover state sprite.
         *
         * @zh
         * 悬停状态下按钮所显示的 Sprite。
         */
        get hoverSprite(): SpriteFrame | null;
        set hoverSprite(value: SpriteFrame | null);
        /**
         * @en
         * Disabled state sprite.
         *
         * @zh
         * 禁用状态下按钮所显示的 Sprite。
         */
        get disabledSprite(): SpriteFrame | null;
        set disabledSprite(value: SpriteFrame | null);
        static Transition: typeof Transition;
        static EventType: typeof EventType;
        /**
         * @en
         * If Button is clicked, it will trigger event's handler.
         *
         * @zh
         * 按钮的点击事件列表。
         */
        clickEvents: ComponentEventHandler[];
        protected _interactable: boolean;
        protected _transition: Transition;
        protected _normalColor: Color;
        protected _hoverColor: Color;
        protected _pressColor: Color;
        protected _disabledColor: Color;
        protected _normalSprite: SpriteFrame | null;
        protected _hoverSprite: SpriteFrame | null;
        protected _pressedSprite: SpriteFrame | null;
        protected _disabledSprite: SpriteFrame | null;
        protected _duration: number;
        protected _zoomScale: number;
        protected _target: Node | null;
        private _pressed;
        private _hovered;
        private _fromColor;
        private _toColor;
        private _time;
        private _transitionFinished;
        private _fromScale;
        private _toScale;
        private _originalScale;
        private _sprite;
        private _targetScale;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        update(dt: number): void;
        protected _resizeNodeToTargetNode(): void;
        protected _resetState(): void;
        protected _registerEvent(): void;
        protected _getTargetSprite(target: Node | null): Sprite | null;
        protected _applyTarget(): void;
        protected _onTouchBegan(event?: EventTouch): void;
        protected _onTouchMove(event?: EventTouch): false | undefined;
        protected _onTouchEnded(event?: EventTouch): void;
        protected _onTouchCancel(event?: EventTouch): void;
        protected _onMouseMoveIn(event?: EventMouse): void;
        protected _onMouseMoveOut(event?: EventMouse): void;
        protected _updateState(): void;
        protected _getButtonState(): string;
        protected _updateColorTransition(state: string): void;
        protected _updateSpriteTransition(state: string): void;
        protected _updateScaleTransition(state: string): void;
        protected _zoomUp(): void;
        protected _zoomBack(): void;
        protected _applyTransition(state: string): void;
    }
}
declare module "cocos/core/assets/font" {
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @en
     * Class for Font handling.
     *
     * @zh
     * 字体资源类。
     */
    export class Font extends Asset {
    }
}
declare module "cocos/core/assets/bitmap-font" {
    import { Font } from "cocos/core/assets/font";
    import { SpriteFrame } from "cocos/core/assets/sprite-frame";
    export interface IConfig {
        [key: string]: any;
    }
    /**
     * @en
     * Class for BitmapFont handling.
     *
     * @zh
     * 位图字体资源类。
     */
    export class BitmapFont extends Font {
        fntDataStr: string;
        /**
         * @zh
         * bitmap font 依赖精灵。
         */
        spriteFrame: SpriteFrame | null;
        /**
         * @zh
         * 文字尺寸。
         */
        fontSize: number;
        /**
         * @zh
         * 文字配置。
         */
        fntConfig: IConfig | null;
    }
}
declare module "cocos/ui/assembler/label/bmfontUtils" {
    import { Vec2 } from "cocos/core/math/index";
    import { Label } from "cocos/ui/components/label";
    class FontLetterDefinition {
        u: number;
        v: number;
        width: number;
        height: number;
        offsetX: number;
        offsetY: number;
        textureID: number;
        validDefinition: boolean;
        xAdvance: number;
    }
    interface ILetterDefinition {
        [key: string]: FontLetterDefinition;
    }
    export class FontAtlas {
        get letterDefinitions(): ILetterDefinition;
        private _letterDefinitions;
        addLetterDefinitions(letter: string, letterDefinition: FontLetterDefinition): void;
        cloneLetterDefinition(): ILetterDefinition;
        assignLetterDefinitions(letterDefinition: ILetterDefinition): void;
        scaleFontLetterDefinition(scaleFactor: number): void;
        getLetterDefinitionForChar(char: string): FontLetterDefinition;
    }
    export const bmfontUtils: {
        updateRenderData(comp: Label): void;
        _updateFontScale(): void;
        _updateProperties(): void;
        _resetProperties(): void;
        _updateContent(): void;
        _computeHorizontalKerningForText(): void;
        _multilineTextWrap(nextTokenFunc: Function): boolean;
        _getFirstCharLen(): number;
        _getFirstWordLen(text: string, startIndex: number, textLen: number): number;
        _multilineTextWrapByWord(): boolean;
        _multilineTextWrapByChar(): boolean;
        _recordPlaceholderInfo(letterIndex: number, char: string): void;
        _recordLetterInfo(letterDefinitions: ILetterDefinition, letterPosition: Vec2, character: string, letterIndex: number, lineIndex: number): void;
        _alignText(): void;
        _scaleFontSizeDown(fontSize: number): void;
        _shrinkLabelToContentSize(lambda: Function): void;
        _isVerticalClamp(): boolean;
        _isHorizontalClamp(): boolean | undefined;
        _isHorizontalClamped(px: number, lineIndex: number): boolean;
        _updateQuads(): boolean;
        appendQuad(comp: any, texture: any, rect: any, rotated: any, x: any, y: any, scale: any): void;
        _computeAlignmentOffset(): void;
        _setupBMFontOverflowMetrics(): void;
    };
    export default bmfontUtils;
}
declare module "cocos/ui/assembler/label/font-utils" {
    /**
     * @hidden
     */
    export interface ISharedLabelData {
        canvas: HTMLCanvasElement;
        context: CanvasRenderingContext2D | null;
    }
    export class CanvasPool {
        pool: ISharedLabelData[];
        get(): ISharedLabelData;
        put(canvas: ISharedLabelData): void;
    }
}
declare module "cocos/core/load-pipeline/binary-downloader" {
    export default function downloadBinary(item: any, callback: any): void;
}
declare module "cocos/core/load-pipeline/text-downloader" {
    export default function (item: any, callback: any): void;
}
declare module "cocos/audio/audio-downloader" {
    export function downloadAudio(item: any, callback: any): Error | undefined;
}
declare module "cocos/core/load-pipeline/downloader" {
    import { Pipeline, IPipe } from "cocos/core/load-pipeline/pipeline";
    import * as PackDownloader from "cocos/core/load-pipeline/pack-downloader";
    /**
     * @en The downloader pipe in {{loader}}, it can download several types of files:
     * 1. Text
     * 2. Image
     * 3. Script
     * 4. Audio
     * 5. Binary
     * All unknown type will be downloaded as plain text.
     * You can pass custom supported types in the {{loader.addDownloadHandlers}}.
     * @zh {{loader}} 中的下载管线，可以下载下列类型的文件：
     * 1. Text
     * 2. Image
     * 3. Script
     * 4. Audio
     * 5. Binary
     * 所有未知类型会被当做文本来下载，也可以通过 {{loader.addDownloadHandlers}} 来定制下载行为
     */
    export default class Downloader implements IPipe {
        static ID: string;
        static PackDownloader: typeof PackDownloader;
        id: string;
        async: boolean;
        pipeline: Pipeline | null;
        private extMap;
        private _curConcurrent;
        private _loadQueue;
        private _subPackages;
        constructor(extMap?: any);
        /**
         * @en Set sub package configurations, only available in certain platforms
         * @zh 设置子包配置，只在部分平台支持
         * @param subPackages
         */
        setSubPackages(subPackages: any): void;
        /**
         * @en Add custom supported types handler or modify existing type handler.
         * @zh 添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @param extMap Custom supported types with corresponded handler
         */
        addHandlers(extMap: Map<string, Function>): void;
        _handleLoadQueue(): void;
        handle(item: any, callback: any): undefined;
        /**
         * @en Load sub package with name.
         * @zh 通过子包名加载子包代码。
         * @param name - Sub package name
         * @param completeCallback -  Callback invoked when sub package loaded
         * @param {Error} completeCallback.error - error information
         */
        loadSubpackage(name: string, completeCallback?: Function): void;
    }
}
declare module "cocos/core/load-pipeline/plist-parser" {
    /**
     * A SAX Parser
     * @class saxParser
     */
    class SAXParser {
        private _isSupportDOMParser;
        private _parser;
        constructor();
        /**
         * @method parse
         * @param {String} xmlTxt
         * @return {Document}
         */
        parse(xmlTxt: any): any;
        _parseXML(textxml: any): any;
    }
    /**
     *
     * plistParser is a singleton object for parsing plist files
     * @class plistParser
     * @extends SAXParser
     */
    class PlistParser extends SAXParser {
        /**
         * @en parse a xml string as plist object.
         * @zh 将xml字符串解析为plist对象。
         * @param {String} xmlTxt - plist xml contents
         * @return {*} plist object
         */
        parse(xmlTxt: any): any;
        _parseNode(node: any): any;
        _parseArray(node: any): any[];
        _parseDict(node: any): {};
    }
    /**
     * @name plistParser
     * A Plist Parser
     */
    let plistParser: PlistParser;
    export default plistParser;
}
declare module "cocos/core/load-pipeline/uuid-loader" {
    export function isSceneObj(json: any): boolean;
    export function loadUuid(item: any, callback: any): void | Error;
    export namespace loadUuid {
        var isSceneObj: typeof import("cocos/core/load-pipeline/uuid-loader").isSceneObj;
    }
}
declare module "cocos/core/load-pipeline/font-loader" {
    export function loadFont(item: any, callback: any): any;
    export function _getFontFamily(fontHandle: any): any;
}
declare module "cocos/core/load-pipeline/loader" {
    import { Pipeline, IPipe } from "cocos/core/load-pipeline/pipeline";
    /**
     * @en The loader pipe in {{loader}}, it can load several types of files:
     * 1. Images
     * 2. JSON
     * 3. Plist
     * 4. Audio
     * 5. Font
     * 6. Binary
     * 7. Cocos Assets
     * It will not interfere with items of unknown type.
     * You can pass custom supported types in the {{loader.addLoadHandlers}}.
     * @zh {{loader}} 中的解析加载管线，可以解析加载下列类型的资源：
     * 1. Images
     * 2. JSON
     * 3. Plist
     * 4. Audio
     * 5. Font
     * 6. Binary
     * 7. Cocos Assets
     * 所有未知类型不会被处理，也可以通过 {{loader.addLoadHandlers}} 来定制加载行为
     */
    export default class Loader implements IPipe {
        static ID: string;
        id: string;
        async: boolean;
        pipeline: Pipeline | null;
        private extMap;
        constructor(extMap?: any);
        /**
         * @en Add custom supported types handler or modify existing type handler.
         * @zh 添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @param extMap Custom supported types with corresponded handler
         * @param extMap Custom supported types with corresponded handler
         */
        addHandlers(extMap: Map<string, Function>): void;
        handle(item: any, callback: any): any;
    }
}
declare module "cocos/core/load-pipeline/asset-loader" {
    import { Pipeline, IPipe } from "cocos/core/load-pipeline/pipeline";
    /**
     * @en The load pipe in {{loader}} to load an asset with its uuid, it will recursively load its dependencies.
     * @zh {{loader}} 加载管线中的资源加载管道，用来通过 uuid 加载 asset 资源及其依赖
     */
    export default class AssetLoader implements IPipe {
        static ID: string;
        id: string;
        async: boolean;
        pipeline: Pipeline | null;
        handle(item: any, callback: any): any;
    }
}
declare module "cocos/core/load-pipeline/callback-params" {
    /**
     * @hidden
     */
    export type LoadCompleteCallback<T> = (error: Error | null | undefined, asset?: T) => void;
    export type LoadProgressCallback = (completedCount: number, totalCount: number, item: any) => void;
}
declare module "cocos/core/load-pipeline/released-asset-checker" {
    export default class ReleasedAssetChecker {
        private _releasedKeys;
        private _dirty;
        constructor();
        setReleased(item: any, releasedKey: any): void;
        checkCouldRelease(caches: any): void;
    }
}
declare module "cocos/core/load-pipeline/CCLoader" {
    import { Asset } from "cocos/core/assets/asset";
    import { RawAsset } from "cocos/core/assets/raw-asset";
    import AssetLoader from "cocos/core/load-pipeline/asset-loader";
    import { LoadCompleteCallback, LoadProgressCallback } from "cocos/core/load-pipeline/callback-params";
    import Downloader from "cocos/core/load-pipeline/downloader";
    import Loader from "cocos/core/load-pipeline/loader";
    import { Pipeline } from "cocos/core/load-pipeline/pipeline";
    /**
     * @en Loader for resource loading process. The engine automatically initialize its singleton object {{loader}}.
     * @zh 资源加载管理器，引擎会自动创建一个单例对象 {{loader}}。
     */
    export class CCLoader extends Pipeline {
        /**
         * @en Gets a new XMLHttpRequest instance.
         * @zh 获取一个新的 XMLHttpRequest 的实例。
         */
        getXMLHttpRequest: Function;
        /**
         * @en The asset loader in loader's pipeline, it's by default the first pipe.<br>
         * It's used to identify an asset's type, and determine how to download it.
         * @zh loader 中的资源加载器，默认情况下是最先加载的。<br>
         * 用于标识资源的类型，并确定如何加载此资源。
         */
        assetLoader: AssetLoader;
        /**
         * @en The md5 pipe in loader's pipeline, it could be absent if the project isn't build with md5 option.<br>
         * It's used to modify the url to the real downloadable url with md5 suffix.
         * @zh loader 中的 md5 加载管道，如果项目没有使用 md5 构建，则此项可能不存在。<br>
         * 用于修改带有 md5 后缀的真实可下载的 URL 。
         */
        md5Pipe: null;
        /**
         * @en
         * The downloader in loader's pipeline, it's by default the second pipe.<br>
         * It's used to download files with several handlers: pure text, image, script, audio, font, uuid.<br>
         * You can add your own download function with addDownloadHandlers
         * @zh
         * loader 中的资源下载程序，默认情况下是第二个加载的。<br>
         * 它用于下载带有多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
         * 您可以使用 addDownloadHandlers 来添加自己的下载函数
         */
        downloader: Downloader;
        /**
         * @en
         * The loader in loader's pipeline, it's by default the third pipe.<br>
         * It's used to parse downloaded content with several handlers: JSON, image, plist, fnt, uuid.<br>
         * You can add your own download function with addLoadHandlers
         * @zh
         * loader 中的资源下载程序，默认情况下是第三个加载的。<br>
         * 它用于解析下载的内容及多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
         * 您可以使用 addLoadHandlers 来添加自己的下载函数
         */
        loader: Loader;
        /**
         * @en The default progression callback during the loading process,
         * if no progression callback is passed to {{load}} function, then this default callback will be used.
         * @zh Loader 默认的进度回调函数，如果在调用 {{load}} 函数时没有指定进度回调函数的话，会调用默认进度回调函数。
         */
        onProgress: Function | null;
        _assetTables: any;
        private _autoReleaseSetting;
        private _releasedAssetChecker_DEBUG;
        constructor();
        /**
         * @en Initialize with director
         * @zh 使用 {{director}} 初始化
         * @param director The director instance of engine
         */
        init(director: any): void;
        /**
         * @en Add custom supported types handler or modify existing type handler for download process.
         * @zh 为下载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @example
         * ```ts
         *  loader.addDownloadHandlers({
         *      // This will match all url with `.scene` extension or all url with `scene` type
         *      'scene' : function (url, callback) {}
         *  });
         * ```
         * @param extMap Handlers for corresponding type in a map
         */
        addDownloadHandlers(extMap: Map<string, Function>): void;
        /**
         * @en Add custom supported types handler or modify existing type handler for load process.
         * @zh 为加载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
         * @example
         * ```ts
         *  loader.addLoadHandlers({
         *      // This will match all url with `.scene` extension or all url with `scene` type
         *      'scene' : function (url, callback) {}
         *  });
         * ```
         * @param extMap Handlers for corresponding type in a map
         */
        addLoadHandlers(extMap: Map<string, Function>): void;
        /**
         * @en
         * Load resources with a progression callback and a complete callback.<br>
         * The progression callback is the same as Pipeline's [[LoadingItems.onProgress]] <br>
         * The complete callback is almost the same as Pipeline's [[LoadingItems.onComplete]] <br>
         * The only difference is when user pass a single url as resources, the complete callback will set its result directly as the second parameter.
         * @zh
         * 使用进度回调和完整回调加载资源。<br>
         * 进度回调与 Pipeline 的 [[LoadingItems.onProgress]] 相同<br>
         * 完整的回调与 Pipeline 的 [[LoadingItems.onComplete]] 几乎相同<br>
         * 唯一的区别是当用户将单个 URL 作为资源传递时，完整的回调将其结果直接设置为第二个参数。
         * @example
         * ```TypeScript
         * import { loader, log, Texture2D } from 'cc';
         * loader.load('a.png', function (err, tex) {
         *     log('Result should be a texture: ' + (tex instanceof Texture2D));
         * });
         *
         * loader.load('http://example.com/a.png', function (err, tex) {
         *     log('Should load a texture from external url: ' + (tex instanceof Texture2D));
         * });
         *
         * loader.load({url: 'http://example.com/getImageREST?file=a.png', type: 'png'}, function (err, tex) {
         *     log('Should load a texture from RESTful API by specify the type: ' + (tex instanceof Texture2D));
         * });
         *
         * loader.load(['a.png', 'b.json'], function (errors, results) {
         *     if (errors) {
         *         for (let i = 0; i < errors.length; i++) {
         *             log('Error url [' + errors[i] + ']: ' + results.getError(errors[i]));
         *         }
         *     }
         *     let aTex = results.getContent('a.png');
         *     let bJsonObj = results.getContent('b.json');
         * });
         * ```
         * @param resources - Url list or load request list
         * @param progressCallback - Progression callback
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed
         * @param {Number} progressCallback.totalCount - The total number of the items
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline
         * @param completeCallback - Completion callback
         */
        load(resources: string | string[] | Object, progressCallback?: Function | null, completeCallback?: Function | null): void;
        /**
         * @en See: {{Pipeline.flowInDeps}}
         * @zh 参考：{{Pipeline.flowInDeps}}
         */
        flowInDeps(owner: any, urlList: any, callback: any): import("cocos/core/load-pipeline/loading-items").IItem[];
        loadRes<T>(url: string, type: Constructor<T>, mount: string, progressCallback: LoadProgressCallback, completeCallback: LoadCompleteCallback<T>): any;
        loadRes<T>(url: string, type: Constructor<T>, progressCallback: LoadProgressCallback, completeCallback: LoadCompleteCallback<T>): any;
        loadRes<T>(url: string, type: Constructor<T>, completeCallback: LoadCompleteCallback<T>): any;
        /**
         * @en
         * Load all assets in a folder inside the "assets/resources" folder of your project.<br>
         * <br>
         * Note: All asset URLs in Creator use forward slashes, URLs using backslashes will not work.
         * @zh
         * 将所有资产加载到项目 “assets / resources” 文件夹中
         * <br>
         * 注意：Creator 中的所有资源 URL 都使用正斜杠，使用反斜杠的 URL 将不起作用。
         * @param url The url of the directory to be loaded, this url should be related path to the `resources` folder.
         * @param type - If type is provided, only assets for correspond type will be loaded
         * @param progressCallback - Progression callback
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
         * @param {Number} progressCallback.totalCount - The total number of the items.
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
         * @param completeCallback - Completion callback
         * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
         *                                         with the error. If all assets are loaded successfully, error will be null.
         * @param {Asset[]|Array} completeCallback.assets - An array of all loaded assets.
         *                                             If nothing to load, assets will be an empty array.
         * @param {string[]} completeCallback.urls - An array that lists all the URLs of loaded assets.
         *
         * @example
         * ```ts
         * import { loader, error, Texture2D } from 'cc';
         * // load the texture (resources/imgs/cocos.png) and the corresponding sprite frame
         * loader.loadResDir('imgs/cocos', function (err, assets) {
         *     if (err) {
         *         error(err);
         *         return;
         *     }
         *     let texture = assets[0];
         *     let spriteFrame = assets[1];
         * });
         *
         * // load all textures in "resources/imgs/"
         * loader.loadResDir('imgs', Texture2D, function (err, textures) {
         *     let texture1 = textures[0];
         *     let texture2 = textures[1];
         * });
         *
         * // load all JSONs in "resources/data/"
         * loader.loadResDir('data', function (err, objects, urls) {
         *     let data = objects[0];
         *     let url = urls[0];
         * });
         * ```
         */
        loadResDir(url: string, type?: Function, mount?: any, progressCallback?: Function, completeCallback?: Function): void;
        /**
         * @en This method is like [[loadRes]] except that it accepts array of url.
         * @zh 此方法除了接受 URL 数组参数外，与 [[loadRes]] 方法相同。
         *
         * @param url The url array of assets to be loaded, this url should be related path without extension to the `resources` folder.
         * @param type - If type is provided, only assets for correspond type will be loaded
         * @param progressCallback - Progression callback
         * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
         * @param {Number} progressCallback.totalCount - The total number of the items.
         * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
         * @param completeCallback - Completion callback
         * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
         *                                         with the error. If all assets are loaded successfully, error will be null.
         * @param {Asset[]|Array} completeCallback.assets - An array of all loaded assets.
         *                                                     If nothing to load, assets will be an empty array.
         * @example
         * ```ts
         * import { loader, error, SpriteFrame } from 'cc';
         * // load the SpriteFrames from resources folder
         * let spriteFrames;
         * let urls = ['misc/characters/character_01', 'misc/weapons/weapons_01'];
         * loader.loadResArray(urls, SpriteFrame, function (err, assets) {
         *     if (err) {
         *         error(err);
         *         return;
         *     }
         *     spriteFrames = assets;
         *     // ...
         * });
         * ```
         */
        loadResArray(urls: string[], type?: Function, mount?: any, progressCallback?: Function, completeCallback?: Function): void;
        /**
         * @en
         * Get resource data by id. <br>
         * When you load resources with [[load]] or [[loadRes]],
         * the url will be the unique identity of the resource.
         * After loaded, you can acquire them by passing the url to this API.
         * @zh
         * 根据 ID 获取资源数据。<br>
         * 当使用 [[load]] 或 [[loadRes]] 来加载资源时，<br>
         * URL 将是资源的唯一标识。<br>
         * 在完成加载之后，你可以通过将 URL 传递给此 API 来获取它们。
         * @param url The asset url, it should be related path without extension to the `resources` folder.
         * @param type If type is provided, the asset for correspond type will be returned
         */
        getRes<T = any>(url: string, type?: Function): T | null;
        /**
         * @en Get total resources count in loader.
         * @zh 获取加载的总资源数量
         */
        getResCount(): Number;
        /**
         * @en
         * Get all resource dependencies of the requested asset in an array, including itself.<br>
         * The owner parameter accept the following types: 1. The asset itself; 2. The resource url; 3. The asset's uuid.<br>
         * The returned array stores the dependencies with their uuids, after retrieve dependencies,<br>
         * you can release them, access dependent assets by passing the uuid to [[getRes]], or other stuffs you want.<br>
         * For release all dependencies of an asset, please refer to [[release]]
         * Here is some examples:
         * @zh
         * 获取一个指定资源的所有依赖资源，包含它自身，并保存在数组中返回。<br>
         * owner 参数接收以下几种类型：1. 资源 asset 对象；2. 资源目录下的 url；3. 资源的 uuid。<br>
         * 返回的数组将仅保存依赖资源的 uuid，获取这些 uuid 后，你可以从 loader 释放这些资源；通过 [[getRes]] 获取某个资源或者进行其他你需要的操作。<br>
         * 想要释放一个资源及其依赖资源，可以参考 [[release]]。<br>
         * 下面是一些示例代码：
         * @example
         * ```ts
         * import { loader, Texture2D } from 'cc';
         * // Release all dependencies of a loaded prefab
         * let deps = loader.getDependsRecursively(prefab);
         * loader.release(deps);
         * // Retrieve all dependent textures
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * let textures = [];
         * for (let i = 0; i < deps.length; ++i) {
         *     let item = loader.getRes(deps[i]);
         *     if (item instanceof Texture2D) {
         *         textures.push(item);
         *     }
         * }
         * ```
         * @param owner - The asset itself or the asset url or the asset uuid
         */
        getDependsRecursively(owner: Asset | RawAsset | string): Array<string>;
        /**
         * @en
         * Release the content of an asset or an array of assets by uuid.<br>
         * This method will not only remove the cache of the asset in loader, but also clean up its content.<br>
         * For example, if you release a texture, the texture asset and its gl texture data will be freed up.<br>
         * In complexe project, you can use this function with [[getDependsRecursively]] to free up memory in critical circumstances.<br>
         * Notice, this method may cause the texture to be unusable, if there are still other nodes use the same texture, they may turn to black and report gl errors.<br>
         * If you only want to remove the cache of an asset, please use [[Pipeline.removeItem]]
         * @zh
         * 通过 id（通常是资源 url）来释放一个资源或者一个资源数组。<br>
         * 这个方法不仅会从 loader 中删除资源的缓存引用，还会清理它的资源内容。<br>
         * 比如说，当你释放一个 texture 资源，这个 texture 和它的 gl 贴图数据都会被释放。<br>
         * 在复杂项目中，我们建议你结合 [[getDependsRecursively]] 来使用，便于在设备内存告急的情况下更快地释放不再需要的资源的内存。<br>
         * 注意，这个函数可能会导致资源贴图或资源所依赖的贴图不可用，如果场景中存在节点仍然依赖同样的贴图，它们可能会变黑并报 GL 错误。<br>
         * 如果你只想删除一个资源的缓存引用，请使用 [[Pipeline.removeItem]]
         *
         * @example
         * ```ts
         * // Release a texture which is no longer need
         * loader.release(texture);
         * // Release all dependencies of a loaded prefab
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * loader.release(deps);
         * // If there is no instance of this prefab in the scene, the prefab and its dependencies like textures, sprite frames, etc, will be freed up.
         * // If you have some other nodes share a texture in this prefab, you can skip it in two ways:
         * // 1. Forbid auto release a texture before release
         * loader.setAutoRelease(texture2d, false);
         * // 2. Remove it from the dependencies array
         * let deps = loader.getDependsRecursively('prefabs/sample');
         * let index = deps.indexOf(texture2d._uuid);
         * if (index !== -1)
         *     deps.splice(index, 1);
         * loader.release(deps);
         * ```
         * @param asset Asset or assets to be released
         */
        release(asset: Asset | RawAsset | string | Array<Asset | RawAsset | string>): void;
        /**
         * @en Release the asset by its object. Refer to {{release}} for detailed informations.
         * @zh 通过资源对象自身来释放资源。详细信息请参考 {{release}}
         * @param asset The asset to be released
         */
        releaseAsset(asset: Asset): void;
        /**
         * @en Release the asset loaded by {{loadRes}}. Refer to {{release}} for detailed informations.
         * @zh 释放通过 {{loadRes}} 加载的资源。详细信息请参考 {{release}}
         * @param url The asset url, it should be related path without extension to the `resources` folder.
         * @param type If type is provided, the asset for correspond type will be returned
         */
        releaseRes(url: string, type?: Function, mount?: any): void;
        /**
         * @en Release the all assets loaded by {{loadResDir}}. Refer to {{release}} for detailed informations.
         * @zh 释放通过 {{loadResDir}} 加载的资源。详细信息请参考 {{release}}
         * @param url The url of the directory to release, it should be related path to the `resources` folder.
         * @param type If type is provided, the asset for correspond type will be returned
         */
        releaseResDir(url: string, type?: Function, mount?: any): void;
        /**
         * @en Resource all assets. Refer to {{release}} for detailed informations.
         * @zh 释放所有资源。详细信息请参考 {{release}}
         */
        releaseAll(): void;
        removeItem(key: any): boolean;
        /**
         * @en
         * Indicates whether to release the asset when loading a new scene.<br>
         * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
         * according to whether the previous scene checked the "Auto Release Assets" option.<br>
         * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
         * will not be affected by that option, remain not released by default.<br>
         * Use this API to change the default behavior on a single asset, to force preserve or release specified asset when scene switching.<br>
         * <br>
         * See: {{setAutoReleaseRecursively}}, {{isAutoRelease}}
         * @zh
         * 设置当场景切换时是否自动释放资源。<br>
         * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
         * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
         * 使用这个 API 可以在单个资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
         * <br>
         * 参考：{{setAutoReleaseRecursively}}，{{isAutoRelease}}
         *
         * @example
         * ```ts
         * // auto release the texture event if "Auto Release Assets" disabled in current scene
         * loader.setAutoRelease(texture2d, true);
         * // don't release the texture even if "Auto Release Assets" enabled in current scene
         * loader.setAutoRelease(texture2d, false);
         * // first parameter can be url
         * loader.setAutoRelease(audioUrl, false);
         * ```
         * @param assetOrUrlOrUuid - The asset or its url or its uuid
         * @param autoRelease - Whether to release automatically during scene switch
         */
        setAutoRelease(assetOrUrlOrUuid: Asset | string, autoRelease: Boolean): void;
        /**
         * @en
         * Indicates whether to release the asset and its referenced other assets when loading a new scene.<br>
         * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
         * according to whether the previous scene checked the "Auto Release Assets" option.<br>
         * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
         * will not be affected by that option, remain not released by default.<br>
         * Use this API to change the default behavior on the specified asset and its recursively referenced assets, to force preserve or release specified asset when scene switching.<br>
         * <br>
         * See: {{setAutoRelease}}, {{isAutoRelease}}
         * @zh
         * 设置当场景切换时是否自动释放资源及资源引用的其它资源。<br>
         * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
         * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
         * 使用这个 API 可以在指定资源及资源递归引用到的所有资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
         * <br>
         * 参考：{{setAutoRelease}}，{{isAutoRelease}}
         *
         * @example
         * ```ts
         * // auto release the SpriteFrame and its Texture event if "Auto Release Assets" disabled in current scene
         * loader.setAutoReleaseRecursively(spriteFrame, true);
         * // don't release the SpriteFrame and its Texture even if "Auto Release Assets" enabled in current scene
         * loader.setAutoReleaseRecursively(spriteFrame, false);
         * // don't release the Prefab and all the referenced assets
         * loader.setAutoReleaseRecursively(prefab, false);
         * ```
         * @param assetOrUrlOrUuid - The asset or its url or its uuid
         * @param autoRelease - Whether to release automatically during scene switch
         */
        setAutoReleaseRecursively(assetOrUrlOrUuid: Asset | string, autoRelease: Boolean): void;
        /**
         * @en Returns whether the asset is configured as auto released, despite how "Auto Release Assets" property is set on scene asset.<br>
         * <br>
         * See: {{setAutoRelease}}, {{setAutoReleaseRecursively}}
         * @zh 返回指定的资源是否有被设置为自动释放，不论场景的“Auto Release Assets”如何设置。<br>
         * <br>
         * 参考：{{setAutoRelease}}，{{setAutoReleaseRecursively}}
         * @param {Asset|string} assetOrUrl - asset object or the raw asset's url
         * @returns {Boolean}
         */
        isAutoRelease(assetOrUrl: Asset | string): Boolean;
        /**
         * @en Retrieve asset's uuid
         * @zh 获取资源的 uuid
         */
        _getResUuid(url: string, type?: Function, mount?: any, quiet?: any): string;
        /**
         * @en Find the asset's reference id in loader, asset could be asset object, asset uuid or asset url
         * @zh 在 laoder 中找到资源的引用 id ，参数可以是资源对象、资源的 uuid 或者是资源的 url
         */
        _getReferenceKey(assetOrUrlOrUuid: any): any;
        private _urlNotFound;
        private _parseLoadResArgs;
        private _loadResUuids;
    }
    /**
     * Singleton object of CCLoader
     */
    export const loader: CCLoader;
}
declare module "cocos/core/load-pipeline/index" {
    /**
     * @hidden
     */
    export { default as url } from "cocos/core/load-pipeline/url";
    export { default as Downloader } from "cocos/core/load-pipeline/downloader";
    export { default as Loader } from "cocos/core/load-pipeline/loader";
    export * from "cocos/core/load-pipeline/loading-items";
    export { Pipeline } from "cocos/core/load-pipeline/pipeline";
    export { loader } from "cocos/core/load-pipeline/CCLoader";
    export * from "cocos/core/load-pipeline/callback-params";
}
declare module "cocos/ui/assembler/label/letter-font" {
    /**
     * @hidden
     */
    import { ImageAsset, Texture2D } from "cocos/core/assets/index";
    import { Color, Vec2 } from "cocos/core/math/index";
    import { Label } from "cocos/ui/components/index";
    import { ISharedLabelData } from "cocos/ui/assembler/label/font-utils";
    interface ILabelInfo {
        fontSize: number;
        lineHeight: number;
        hash: string;
        fontFamily: string;
        fontDesc: string;
        hAlign: number;
        vAlign: number;
        color: Color;
        isOutlined: boolean;
        out: Color;
        margin: number;
    }
    class FontLetterDefinition {
        u: number;
        v: number;
        w: number;
        h: number;
        texture: LetterRenderTexture | null;
        offsetX: number;
        offsetY: number;
        valid: boolean;
        xAdvance: number;
    }
    class LetterTexture {
        image: ImageAsset | null;
        labelInfo: ILabelInfo;
        char: string;
        data: ISharedLabelData | null;
        canvas: HTMLCanvasElement | null;
        context: CanvasRenderingContext2D | null;
        width: number;
        height: number;
        hash: string;
        constructor(char: string, labelInfo: ILabelInfo);
        updateRenderData(): void;
        destroy(): void;
        private _updateProperties;
        private _updateTexture;
    }
    export class LetterRenderTexture extends Texture2D {
        /**
         * @en
         * Init the render texture with size.
         * @zh
         * 初始化 render texture。
         * @param [width]
         * @param [height]
         * @param [string]
         */
        initWithSize(width: number, height: number, format?: number): void;
        /**
         * @en Draw a texture to the specified position
         * @zh 将指定的图片渲染到指定的位置上。
         * @param {Texture2D} image
         * @param {Number} x
         * @param {Number} y
         */
        drawTextureAt(image: ImageAsset, x: number, y: number): void;
    }
    export class LetterAtlas {
        get width(): number;
        get height(): number;
        texture: LetterRenderTexture;
        private _x;
        private _y;
        private _nextY;
        private _width;
        private _height;
        private _letterDefinitions;
        private _dirty;
        constructor(width: number, height: number);
        insertLetterTexture(letterTexture: LetterTexture): FontLetterDefinition | null;
        update(): void;
        reset(): void;
        destroy(): void;
        beforeSceneLoad(): void;
        getLetter(key: string): FontLetterDefinition | undefined;
        addLetterDefinitions(key: string, letterDefinition: FontLetterDefinition): void;
        cloneLetterDefinition(): {};
        assignLetterDefinitions(letterDefinitions: Map<string, FontLetterDefinition>): void;
        scaleFontLetterDefinition(scaleFactor: number): void;
        getLetterDefinitionForChar(char: string, labelInfo: ILabelInfo): FontLetterDefinition | null;
    }
    export const letterFont: {
        getAssemblerData(): LetterRenderTexture;
        updateRenderData(comp: Label): void;
        _updateFontScale(): void;
        _updateProperties(): void;
        _updateFontFamily(comp: Label): void;
        _computeHash(labelInfo: ILabelInfo): string;
        _getFontDesc(): string;
        _resetProperties(): void;
        _updateContent(): void;
        _computeHorizontalKerningForText(): void;
        _multilineTextWrap(nextTokenFunc: Function): boolean;
        _getFirstCharLen(): number;
        _getFirstWordLen(text: string, startIndex: number, textLen: number): number | undefined;
        _multilineTextWrapByWord(): boolean;
        _multilineTextWrapByChar(): boolean;
        _recordPlaceholderInfo(letterIndex: number, char: string): void;
        _recordLetterInfo(letterPosition: Vec2, character: string, letterIndex: number, lineIndex: number): void;
        _alignText(): void;
        _scaleFontSizeDown(fontSize: number): void;
        _isVerticalClamp(): boolean;
        _isHorizontalClamp(): boolean;
        _isHorizontalClamped(px: number, lineIndex: number): boolean;
        _updateQuads(): boolean | undefined;
        appendQuad(renderData: any, texture: any, rect: any, rotated: any, x: any, y: any, scale: any): void;
        _computeAlignmentOffset(): void;
        _setupBMFontOverflowMetrics(): void;
    };
}
declare module "cocos/ui/components/label" {
    /**
     * @category ui
     */
    import { Font, SpriteFrame, Material } from "cocos/core/assets/index";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { FontAtlas } from "cocos/ui/assembler/label/bmfontUtils";
    import { CanvasPool, ISharedLabelData } from "cocos/ui/assembler/label/font-utils";
    import { LetterRenderTexture } from "cocos/ui/assembler/label/letter-font";
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    /**
     * @en Enum for horizontal text alignment.
     *
     * @zh 文本横向对齐类型。
     */
    export enum HorizontalTextAlignment {
        /**
         * @en Alignment left for text.
         *
         * @zh 左对齐。
         */
        LEFT = 0,
        /**
         * @en Alignment center for text.
         *
         * @zh 中心对齐。
         */
        CENTER = 1,
        /**
         * @en Alignment right for text.
         *
         * @zh 右对齐。
         */
        RIGHT = 2
    }
    /**
     * @en Enum for vertical text alignment.
     *
     * @zh 文本垂直对齐类型。
     */
    export enum VerticalTextAlignment {
        /**
         * @en Alignment top for text.
         *
         * @zh 上对齐。
         */
        TOP = 0,
        /**
         * @en Alignment center for text.
         *
         * @zh 中心对齐。
         */
        CENTER = 1,
        /**
         * @en Alignment bottom for text.
         *
         * @zh 下对齐。
         */
        BOTTOM = 2
    }
    /**
     * @en Enum for Overflow.
     *
     * @zh 文本超载类型。
     */
    export enum Overflow {
        /**
         * @en None.
         *
         * @zh 不做任何限制。
         */
        NONE = 0,
        /**
         * @en In CLAMP mode, when label content goes out of the bounding box, it will be clipped.
         *
         * @zh CLAMP 模式中，当文本内容超出边界框时，多余的会被截断。
         */
        CLAMP = 1,
        /**
         * @en In SHRINK mode, the font size will change dynamically to adapt the content size.
         * This mode may takes up more CPU resources when the label is refreshed.
         *
         * @zh SHRINK 模式，字体大小会动态变化，以适应内容大小。
         */
        SHRINK = 2,
        /**
         * @en In RESIZE_HEIGHT mode, you can only change the width of label and the height is changed automatically.
         *
         * @zh 在 RESIZE_HEIGHT 模式下，只能更改文本的宽度，高度是自动改变的。
         */
        RESIZE_HEIGHT = 3
    }
    /**
     * @en Enum for cache mode.
     *
     * @zh 文本图集缓存类型。
     */
    export enum CacheMode {
        /**
         * @en Do not do any caching.
         *
         * @zh 不做任何缓存。
         */
        NONE = 0,
        /**
         * @en In BITMAP mode, cache the label as a static image and add it to the dynamic atlas for batch rendering,
         * and can batching with Sprites using broken images.
         *
         * @zh BITMAP 模式，将 label 缓存成静态图像并加入到动态图集，以便进行批次合并，可与使用碎图的 Sprite 进行合批。
         * （注：动态图集在 Chrome 以及微信小游戏暂时关闭，该功能无效）。
         */
        BITMAP = 1,
        /**
         * @en In CHAR mode, split text into characters and cache characters into a dynamic atlas which the size of 1024 * 1024.
         *
         * @zh CHAR 模式，将文本拆分为字符，并将字符缓存到一张单独的大小为 1024 * 1024 的图集中进行重复使用，不再使用动态图集。
         * （注：当图集满时将不再进行缓存，暂时不支持 SHRINK 自适应文本尺寸（后续完善））。
         */
        CHAR = 2
    }
    /**
     * @zh
     * Type 类型。
     */
    /**
     * @zh
     * TTF字体。
     */
    /**
     * @zh
     * 位图字体。
     */
    /**
     * @zh
     * 系统字体。
     */
    /**
     * @en
     * The Label Component.
     *
     * @zh
     * 文字标签组件。
     */
    export class Label extends UIRenderable {
        /**
         * @en
         * Content string of label.
         *
         * @zh
         * 标签显示的文本内容。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * Horizontal Alignment of label.
         *
         * @zh
         * 文本内容的水平对齐方式。
         */
        get horizontalAlign(): HorizontalTextAlignment;
        set horizontalAlign(value: HorizontalTextAlignment);
        /**
         * @en
         * Vertical Alignment of label.
         *
         * @zh
         * 文本内容的垂直对齐方式。
         */
        get verticalAlign(): VerticalTextAlignment;
        set verticalAlign(value: VerticalTextAlignment);
        /**
         * @en
         * The actual rendering font size in shrink mode.
         *
         * @zh
         * SHRINK 模式下面文本实际渲染的字体大小。
         */
        get actualFontSize(): number;
        set actualFontSize(value: number);
        /**
         * @en
         * Font size of label.
         *
         * @zh
         * 文本字体大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en
         * Font family of label, only take effect when useSystemFont property is true.
         *
         * @zh
         * 文本字体名称, 只在 useSystemFont 属性为 true 的时候生效。
         */
        get fontFamily(): string;
        set fontFamily(value: string);
        /**
         * @en
         * Line Height of label.
         *
         * @zh
         * 文本行高。
         */
        get lineHeight(): number;
        set lineHeight(value: number);
        /**
         * @en
         * Overflow of label.
         *
         * @zh
         * 文字显示超出范围时的处理方式。
         */
        get overflow(): Overflow;
        set overflow(value: Overflow);
        /**
         * @en
         * Whether auto wrap label when string width is large than label width.
         *
         * @zh
         * 是否自动换行。
         */
        get enableWrapText(): boolean;
        set enableWrapText(value: boolean);
        /**
         * @en
         * The font of label.
         *
         * @zh
         * 文本字体。
         */
        get font(): Font | null;
        set font(value: Font | null);
        /**
         * @en
         * Whether use system font name or not.
         *
         * @zh
         * 是否使用系统字体。
         */
        get useSystemFont(): boolean;
        set useSystemFont(value: boolean);
        /**
         * @en
         * The cache mode of label. This mode only supports system fonts.
         *
         * @zh
         * 文本缓存模式, 该模式只支持系统字体。
         */
        get cacheMode(): CacheMode;
        set cacheMode(value: CacheMode);
        get spriteFrame(): SpriteFrame | LetterRenderTexture | null;
        /**
         * @en
         * Whether the font is bold.
         *
         * @zh
         * 字体是否加粗。
         */
        get isBold(): boolean;
        set isBold(value: boolean);
        /**
         * @en
         * Whether the font is italic.
         *
         * @zh
         * 字体是否倾斜。
         */
        get isItalic(): boolean;
        set isItalic(value: boolean);
        /**
         * @en
         * Whether the font is underline.
         *
         * @zh
         * 字体是否加下划线。
         */
        get isUnderline(): boolean;
        set isUnderline(value: boolean);
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        get assemblerData(): ISharedLabelData | null;
        get fontAtlas(): FontAtlas | null;
        set fontAtlas(value: FontAtlas | null);
        get spacingX(): number;
        set spacingX(value: number);
        get _bmFontOriginalSize(): number;
        static HorizontalAlign: typeof HorizontalTextAlignment;
        static VerticalAlign: typeof VerticalTextAlignment;
        static Overflow: typeof Overflow;
        static CacheMode: typeof CacheMode;
        static _canvasPool: CanvasPool;
        protected _useOriginalSize: boolean;
        protected _string: string;
        protected _horizontalAlign: HorizontalTextAlignment;
        protected _verticalAlign: VerticalTextAlignment;
        protected _actualFontSize: number;
        protected _fontSize: number;
        protected _fontFamily: string;
        protected _lineHeight: number;
        protected _overflow: Overflow;
        protected _enableWrapText: boolean;
        protected _font: Font | null;
        protected _isSystemFontUsed: boolean;
        protected _spacingX: number;
        protected _isItalic: boolean;
        protected _isBold: boolean;
        protected _isUnderline: boolean;
        protected _cacheMode: CacheMode;
        protected _N$file: Font | null;
        protected _texture: SpriteFrame | LetterRenderTexture | null;
        protected _ttfSpriteFrame: SpriteFrame | null;
        protected _userDefinedFont: Font | null;
        protected _assemblerData: ISharedLabelData | null;
        protected _fontAtlas: FontAtlas | null;
        protected _letterTexture: LetterRenderTexture | null;
        constructor();
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        updateRenderData(force?: boolean): void;
        protected _render(render: UI): void;
        protected _updateColor(): void;
        protected _canRender(): boolean;
        protected _flushAssembler(): void;
        protected _applyFontTexture(): void;
    }
}
declare module "cocos/ui/components/editbox/tabIndexUtil" {
    /**
     * @hidden
     */
    import { EditBoxImpl } from "cocos/ui/components/editbox/edit-box-impl";
    export class tabIndexUtil {
        static _tabIndexList: EditBoxImpl[];
        static add(editBoxImpl: EditBoxImpl): void;
        static remove(editBoxImpl: EditBoxImpl): void;
        static resort(): void;
        static next(editBoxImpl: EditBoxImpl): void;
    }
}
declare module "cocos/ui/components/editbox/types" {
    /**
     * 键盘的返回键类型。
     * @readonly
     * @enum EditBox.KeyboardReturnType
     */
    export enum KeyboardReturnType {
        /**
         * 默认。
         */
        DEFAULT = 0,
        /**
         * 完成类型。
         */
        DONE = 1,
        /**
         * 发送类型。
         */
        SEND = 2,
        /**
         * 搜索类型。
         */
        SEARCH = 3,
        /**
         * 跳转类型。
         */
        GO = 4,
        /**
         * 下一个类型。
         */
        NEXT = 5
    }
    /**
     * 输入模式。
     * @readonly
     * @enum EditBox.InputMode
     */
    export enum InputMode {
        /**
         * 用户可以输入任何文本，包括换行符。
         */
        ANY = 0,
        /**
         * 允许用户输入一个电子邮件地址。
         */
        EMAIL_ADDR = 1,
        /**
         * 允许用户输入一个整数值。
         */
        NUMERIC = 2,
        /**
         * 允许用户输入一个电话号码。
         */
        PHONE_NUMBER = 3,
        /**
         * 允许用户输入一个 URL。
         */
        URL = 4,
        /**
         * 允许用户输入一个实数。
         */
        DECIMAL = 5,
        /**
         * 除了换行符以外，用户可以输入任何文本。
         */
        SINGLE_LINE = 6
    }
    /**
     * 定义了一些用于设置文本显示和文本格式化的标志位。
     * @readonly
     * @enum EditBox.InputFlag
     */
    export enum InputFlag {
        /**
         * 表明输入的文本是保密的数据，任何时候都应该隐藏起来，它隐含了 EDIT_BOX_INPUT_FLAG_SENSITIVE。
         */
        PASSWORD = 0,
        /**
         * 表明输入的文本是敏感数据，它禁止存储到字典或表里面，也不能用来自动补全和提示用户输入。
         * 一个信用卡号码就是一个敏感数据的例子。
         */
        SENSITIVE = 1,
        /**
         * 这个标志用来指定在文本编辑的时候，是否把每一个单词的首字母大写。
         */
        INITIAL_CAPS_WORD = 2,
        /**
         * 这个标志用来指定在文本编辑是否每个句子的首字母大写。
         */
        INITIAL_CAPS_SENTENCE = 3,
        /**
         * 自动把输入的所有字符大写。
         */
        INITIAL_CAPS_ALL_CHARACTERS = 4,
        /**
         * Don't do anything with the input text.
         */
        DEFAULT = 5
    }
}
declare module "cocos/ui/components/editbox/edit-box-impl-base" {
    /**
     * @hidden
     */
    import { EditBox } from "cocos/ui/components/editbox/edit-box";
    export class EditBoxImplBase {
        _editing: boolean;
        _delegate: EditBox | null;
        init(delegate: EditBox): void;
        onEnable(): void;
        update(): void;
        onDisable(): void;
        clear(): void;
        setTabIndex(index: number): void;
        setSize(width: number, height: number): void;
        setFocus(value: any): void;
        isFocused(): boolean;
        beginEditing(): void;
        endEditing(): void;
    }
}
declare module "cocos/ui/components/editbox/edit-box-impl" {
    import { EditBox } from "cocos/ui/components/editbox/edit-box";
    import { InputFlag, InputMode, KeyboardReturnType } from "cocos/ui/components/editbox/types";
    import { EditBoxImplBase } from "cocos/ui/components/editbox/edit-box-impl-base";
    export class EditBoxImpl extends EditBoxImplBase {
        _delegate: EditBox | null;
        _inputMode: InputMode;
        _inputFlag: InputFlag;
        _returnType: KeyboardReturnType;
        __eventListeners: any;
        __fullscreen: boolean;
        __autoResize: boolean;
        __orientationChanged: any;
        _edTxt: HTMLInputElement | HTMLTextAreaElement | null;
        private _isTextArea;
        private _textLabelFont;
        private _textLabelFontSize;
        private _textLabelFontColor;
        private _textLabelAlign;
        private _placeholderLabelFont;
        private _placeholderLabelFontSize;
        private _placeholderLabelFontColor;
        private _placeholderLabelAlign;
        private _placeholderLineHeight;
        private _placeholderStyleSheet;
        private _domId;
        init(delegate: EditBox): void;
        clear(): void;
        update(): void;
        setTabIndex(index: number): void;
        setSize(width: number, height: number): void;
        beginEditing(): void;
        endEditing(): void;
        private _createInput;
        private _createTextArea;
        private _addDomToGameContainer;
        private _removeDomFromGameContainer;
        private _showDom;
        private _hideDom;
        private _showDomOnMobile;
        private _hideDomOnMobile;
        private _adjustWindowScroll;
        private _scrollBackWindow;
        private _updateMatrix;
        private _updateInputType;
        private _updateMaxLength;
        private _initStyleSheet;
        private _updateStyleSheet;
        private _updateTextLabel;
        private _updatePlaceholderLabel;
        private _registerEventListeners;
        private _removeEventListeners;
    }
}
declare module "cocos/ui/components/editbox/edit-box" {
    import { SpriteFrame } from "cocos/core/assets/sprite-frame";
    import { Component } from "cocos/core/components/component";
    import { EventHandler as ComponentEventHandler } from "cocos/core/components/component-event-handler";
    import { Size } from "cocos/core/math/index";
    import { EventTouch } from "cocos/core/platform/index";
    import { Label } from "cocos/ui/components/label";
    import { Sprite } from "cocos/ui/components/sprite";
    import { EditBoxImplBase } from "cocos/ui/components/editbox/edit-box-impl-base";
    import { InputFlag, InputMode, KeyboardReturnType } from "cocos/ui/components/editbox/types";
    enum EventType {
        EDITING_DID_BEGAN = "editing-did-began",
        EDITING_DID_ENDED = "editing-did-ended",
        TEXT_CHANGED = "text-changed",
        EDITING_RETURN = "editing-return"
    }
    /**
     * @en
     * `EditBox` is a component for inputing text, you can use it to gather small amounts of text from users.
     *
     * @zh
     * `EditBox` 组件，用于获取用户的输入文本。
     */
    export class EditBox extends Component {
        /**
         * @en
         * Input string of EditBox.
         *
         * @zh
         * 输入框的初始输入内容，如果为空则会显示占位符的文本。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * The display text of placeholder.
         *
         * @zh
         * 输入框占位符的文本内容。
         */
        get placeholder(): string;
        set placeholder(value: string);
        /**
         * @en
         * The Label component attached to the node for EditBox's input text label
         *
         * @zh
         * 输入框输入文本节点上挂载的 Label 组件对象
         */
        get textLabel(): Label | null;
        set textLabel(oldValue: Label | null);
        /**
         * @en
         * The Label component attached to the node for EditBox's placeholder text label.
         *
         * @zh
         * 输入框占位符节点上挂载的 Label 组件对象。
         */
        get placeholderLabel(): Label | null;
        set placeholderLabel(oldValue: Label | null);
        /**
         * @en
         * The background image of EditBox.
         *
         * @zh
         * 输入框的背景图片。
         */
        get backgroundImage(): SpriteFrame | null;
        set backgroundImage(value: SpriteFrame | null);
        /**
         * @en
         * Set the input flags that are to be applied to the EditBox.
         *
         * @zh
         * 指定输入标志位，可以指定输入方式为密码或者单词首字母大写。
         */
        get inputFlag(): InputFlag;
        set inputFlag(value: InputFlag);
        /**
         * @en
         * Set the input mode of the edit box.
         * If you pass ANY, it will create a multiline EditBox.
         *
         * @zh
         * 指定输入模式: ANY表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。
         */
        get inputMode(): InputMode;
        set inputMode(oldValue: InputMode);
        /**
         * @en
         * The return key type of EditBox.
         * Note: it is meaningless for web platforms and desktop platforms.
         *
         * @zh
         * 指定移动设备上面回车按钮的样式。
         * 注意：这个选项对 web 平台与 desktop 平台无效。
         */
        get returnType(): KeyboardReturnType;
        set returnType(value: KeyboardReturnType);
        /**
         * @en
         * The maximize input length of EditBox.
         * - If pass a value less than 0, it won't limit the input number of characters.
         * - If pass 0, it doesn't allow input any characters.
         *
         * @zh
         * 输入框最大允许输入的字符个数。
         * - 如果值为小于 0 的值，则不会限制输入字符个数。
         * - 如果值为 0，则不允许用户进行任何输入。
         */
        get maxLength(): number;
        set maxLength(value: number);
        /**
         * @en
         * Set the tabIndex of the DOM input element (only useful on Web).
         *
         * @zh
         * 修改 DOM 输入元素的 tabIndex（这个属性只有在 Web 上面修改有意义）。
         */
        get tabIndex(): number;
        set tabIndex(value: number);
        static _EditBoxImpl: typeof EditBoxImplBase;
        static KeyboardReturnType: typeof KeyboardReturnType;
        static InputFlag: typeof InputFlag;
        static InputMode: typeof InputMode;
        static EventType: typeof EventType;
        /**
         * @en
         * The event handler to be called when EditBox began to edit text.
         *
         * @zh
         * 开始编辑文本输入框触发的事件回调。
         */
        editingDidBegan: ComponentEventHandler[];
        /**
         * @en
         * The event handler to be called when EditBox text changes.
         *
         * @zh
         * 编辑文本输入框时触发的事件回调。
         */
        textChanged: ComponentEventHandler[];
        /**
         * @en
         * The event handler to be called when EditBox edit ends.
         *
         * @zh
         * 结束编辑文本输入框时触发的事件回调。
         */
        editingDidEnded: ComponentEventHandler[];
        /**
         * @en
         * The event handler to be called when return key is pressed. Windows is not supported.
         *
         * @zh
         * 当用户按下回车按键时的事件回调，目前不支持 windows 平台
         */
        editingReturn: ComponentEventHandler[];
        _impl: EditBoxImplBase | null;
        _background: Sprite | null;
        protected _textLabel: Label | null;
        protected _placeholderLabel: Label | null;
        protected _returnType: KeyboardReturnType;
        protected _useOriginalSize: boolean;
        protected _string: string;
        protected _tabIndex: number;
        protected _backgroundImage: SpriteFrame | null;
        protected _inputFlag: InputFlag;
        protected _inputMode: InputMode;
        protected _maxLength: number;
        private _isLabelVisible;
        __preload(): void;
        onEnable(): void;
        update(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en Let the EditBox get focus
         * @zh 让当前 EditBox 获得焦点。
         */
        setFocus(): void;
        /**
         * @en Let the EditBox get focus
         * @zh 让当前 EditBox 获得焦点
         */
        focus(): void;
        /**
         * @en Let the EditBox lose focus
         * @zh 让当前 EditBox 失去焦点
         */
        blur(): void;
        /**
         * @en Determine whether EditBox is getting focus or not.
         * @zh 判断 EditBox 是否获得了焦点。
         * Note: only available on Web at the moment.
         */
        isFocused(): boolean;
        _editBoxEditingDidBegan(): void;
        _editBoxEditingDidEnded(): void;
        _editBoxTextChanged(text: string): void;
        _editBoxEditingReturn(): void;
        _showLabels(): void;
        _hideLabels(): void;
        protected _onTouchBegan(event: EventTouch): void;
        protected _onTouchCancel(event: EventTouch): void;
        protected _onTouchEnded(event: EventTouch): void;
        protected _init(): void;
        protected _createBackgroundSprite(): void;
        protected _updateTextLabel(): void;
        protected _updatePlaceholderLabel(): void;
        protected _syncSize(): void;
        protected _updateLabels(): void;
        protected _updateString(text: string): void;
        protected _updateLabelStringStyle(text: string, ignorePassword?: boolean): string;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _updateLabelPosition(size: Size): void;
        protected _resizeChildNodes(): void;
    }
}
declare module "cocos/ui/components/layout" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    import { Size, Vec2 } from "cocos/core/math/index";
    import { TransformBit } from "cocos/core/scene-graph/node-enum";
    import { Node } from "cocos/core/index";
    /**
     * @en Enum for layout.
     *
     * @zh 布局类型。
     */
    enum Type {
        /**
         * @en None Layout.
         *
         * @zh 取消布局。
         */
        NONE = 0,
        /**
         * @en Horizontal Layout.
         *
         * @zh 水平布局。
         */
        HORIZONTAL = 1,
        /**
         * @en Vertical Layout.
         *
         * @zh 垂直布局。
         */
        VERTICAL = 2,
        /**
         * @en Grid Layout.
         *
         * @zh 网格布局。
         */
        GRID = 3
    }
    /**
     * @en Enum for Layout Resize Mode.
     *
     * @zh 缩放模式。
     */
    enum ResizeMode {
        /**
         * @en Don't scale.
         *
         * @zh 不做任何缩放。
         */
        NONE = 0,
        /**
         * @en The container size will be expanded with its children's size.
         *
         * @zh 容器的大小会根据子节点的大小自动缩放。
         */
        CONTAINER = 1,
        /**
         * @en Child item size will be adjusted with the container's size.
         *
         * @zh 子节点的大小会随着容器的大小自动缩放。
         */
        CHILDREN = 2
    }
    /**
     * @en Enum for Grid Layout start axis direction.
     *
     * @zh 布局轴向，只用于 GRID 布局。
     */
    enum AxisDirection {
        /**
         * @en The horizontal axis.
         *
         * @zh 进行水平方向布局。
         */
        HORIZONTAL = 0,
        /**
         * @en The vertical axis.
         *
         * @zh 进行垂直方向布局。
         */
        VERTICAL = 1
    }
    /**
     * @en Enum for vertical layout direction.
     *
     * @zh 垂直方向布局方式。
     */
    enum VerticalDirection {
        /**
         * @en Items arranged from bottom to top.
         *
         * @zh 从下到上排列。
         */
        BOTTOM_TO_TOP = 0,
        /**
         * @en Items arranged from top to bottom.
         * @zh 从上到下排列。
         */
        TOP_TO_BOTTOM = 1
    }
    /**
     * @en Enum for horizontal layout direction.
     *
     * @zh 水平方向布局方式。
     */
    enum HorizontalDirection {
        /**
         * @en Items arranged from left to right.
         *
         * @zh 从左往右排列。
         */
        LEFT_TO_RIGHT = 0,
        /**
         * @en Items arranged from right to left.
         * @zh 从右往左排列。
         */
        RIGHT_TO_LEFT = 1
    }
    /**
     * @en
     * The Layout is a container component, use it to arrange child elements easily.<br>
     * Note：<br>
     * 1.Scaling and rotation of child nodes are not considered.<br>
     * 2.After setting the Layout, the results need to be updated until the next frame,unless you manually call.[[updateLayout]]
     *
     * @zh
     * Layout 组件相当于一个容器，能自动对它的所有子节点进行统一排版。<br>
     * 注意：<br>
     * 1.不会考虑子节点的缩放和旋转。<br>
     * 2.对 Layout 设置后结果需要到下一帧才会更新，除非你设置完以后手动调用。[[updateLayout]]
     */
    export class Layout extends Component {
        /**
         * @en
         * The layout type.
         *
         * @zh
         * 布局类型。
         */
        get type(): Type;
        set type(value: Type);
        /**
         * @en
         * The are three resize modes for Layout. None, resize Container and resize children.
         *
         * @zh
         * 缩放模式。
         */
        get resizeMode(): ResizeMode;
        set resizeMode(value: ResizeMode);
        /**
         * @en
         * The cell size for grid layout.
         *
         * @zh
         * 每个格子的大小，只有布局类型为 GRID 的时候才有效。
         */
        get cellSize(): Readonly<Size>;
        set cellSize(value: Readonly<Size>);
        /**
         * @en
         * The start axis for grid layout. If you choose horizontal, then children will layout horizontally at first,
         * and then break line on demand. Choose vertical if you want to layout vertically at first .
         *
         * @zh
         * 起始轴方向类型，可进行水平和垂直布局排列，只有布局类型为 GRID 的时候才有效。
         */
        get startAxis(): AxisDirection;
        set startAxis(value: AxisDirection);
        /**
         * @en
         * The left padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内左边距，只会在一个布局方向上生效。
         */
        get paddingLeft(): number;
        set paddingLeft(value: number);
        /**
         * @en
         * The right padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内右边距，只会在一个布局方向上生效。
         */
        get paddingRight(): number;
        set paddingRight(value: number);
        /**
         * @en
         * The top padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内上边距，只会在一个布局方向上生效。
         */
        get paddingTop(): number;
        set paddingTop(value: number);
        /**
         * @en
         * The bottom padding of layout, it only effect the layout in one direction.
         *
         * @zh
         * 容器内下边距，只会在一个布局方向上生效。
         */
        get paddingBottom(): number;
        set paddingBottom(value: number);
        /**
         * @en
         * The distance in x-axis between each element in layout.
         *
         * @zh
         * 子节点之间的水平间距。
         */
        get spacingX(): number;
        set spacingX(value: number);
        /**
         * @en
         * The distance in y-axis between each element in layout.
         *
         * @zh
         * 子节点之间的垂直间距。
         */
        get spacingY(): number;
        set spacingY(value: number);
        /**
         * @en
         * Only take effect in Vertical layout mode.
         * This option changes the start element's positioning.
         *
         * @zh
         * 垂直排列子节点的方向。
         */
        get verticalDirection(): VerticalDirection;
        set verticalDirection(value: VerticalDirection);
        /**
         * @en
         * Only take effect in horizontal layout mode.
         * This option changes the start element's positioning.
         *
         * @zh
         * 水平排列子节点的方向。
         */
        get horizontalDirection(): HorizontalDirection;
        set horizontalDirection(value: HorizontalDirection);
        /**
         * @en
         * The padding of layout, it will effect the layout in horizontal and vertical direction.
         *
         * @zh
         * 容器内边距，该属性会在四个布局方向上生效。
         */
        get padding(): number;
        set padding(value: number);
        /**
         * @en
         * Adjust the layout if the children scaled.
         *
         * @zh
         * 子节点缩放比例是否影响布局。
         */
        get affectedByScale(): boolean;
        set affectedByScale(value: boolean);
        static Type: typeof Type;
        static VerticalDirection: typeof VerticalDirection;
        static HorizontalDirection: typeof HorizontalDirection;
        static ResizeMode: typeof ResizeMode;
        static AxisDirection: typeof AxisDirection;
        protected _resizeMode: ResizeMode;
        protected _N$layoutType: Type;
        protected _N$padding: number;
        protected _cellSize: Size;
        protected _startAxis: AxisDirection;
        protected _paddingLeft: number;
        protected _paddingRight: number;
        protected _paddingTop: number;
        protected _paddingBottom: number;
        protected _spacingX: number;
        protected _spacingY: number;
        protected _verticalDirection: VerticalDirection;
        protected _horizontalDirection: HorizontalDirection;
        protected _affectedByScale: boolean;
        protected _layoutSize: Size;
        protected _layoutDirty: boolean;
        protected _isAlign: boolean;
        /**
         * @en
         * Perform the layout update.
         *
         * @zh
         * 立即执行更新布局。
         *
         * @example
         * ```ts
         * import { Layout, log } from 'cc';
         * layout.type = Layout.HORIZONTAL;
         * layout.node.addChild(childNode);
         * log(childNode.x); // not yet changed
         * layout.updateLayout();
         * log(childNode.x); // changed
         * ```
         */
        updateLayout(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected _migratePaddingData(): void;
        protected _addEventListeners(): void;
        protected _removeEventListeners(): void;
        protected _addChildrenEventListeners(): void;
        protected _removeChildrenEventListeners(): void;
        protected _childAdded(child: Node): void;
        protected _childRemoved(child: Node): void;
        protected _resized(): void;
        protected _doLayoutHorizontally(baseWidth: number, rowBreak: boolean, fnPositionY: Function, applyChildren: boolean): number;
        protected _doLayoutVertically(baseHeight: number, columnBreak: boolean, fnPositionX: Function, applyChildren: boolean): number;
        protected _doLayoutBasic(): void;
        protected _doLayoutGridAxisHorizontal(layoutAnchor: any, layoutSize: any): void;
        protected _doLayoutGridAxisVertical(layoutAnchor: Vec2, layoutSize: Size): void;
        protected _doLayoutGrid(): void;
        protected _getHorizontalBaseWidth(children: Readonly<Node[]>): number;
        protected _getVerticalBaseHeight(children: Readonly<Node[]>): number;
        protected _doLayout(): void;
        protected _getUsedScaleValue(value: any): number;
        protected _transformDirty(type: TransformBit): void;
        protected _doLayoutDirty(): void;
        protected _doScaleDirty(type: TransformBit): void;
    }
}
declare module "cocos/ui/assembler/graphics/types" {
    /**
     * @en Enum for LineCap.
     * @zh 线段末端属性
     * @enum Graphics.LineCap
     */
    export enum LineCap {
        /**
         * @en The ends of lines are squared off at the endpoints.
         * @zh 线段末端以方形结束。
         */
        BUTT = 0,
        /**
         * @en The ends of lines are rounded.
         * @zh 线段末端以圆形结束。
         */
        ROUND = 1,
        /**
         * @en The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.
         * @zh 线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。
         */
        SQUARE = 2
    }
    /**
     * @en Enum for LineJoin.
     * @zh 线段拐角属性
     * @enum Graphics.LineJoin
     */
    export enum LineJoin {
        /**
         * @en Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.
         * @zh 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。
         */
        BEVEL = 0,
        /**
         * @en Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments.
         * The radius for these rounded corners is equal to the line width.
         * @zh 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。
         */
        ROUND = 1,
        /**
         * @en Connected segments are joined by extending their outside edges to connect at a single point,
         * with the effect of filling an additional lozenge-shaped area.
         * @zh 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。
         */
        MITER = 2
    }
    export enum PointFlags {
        PT_CORNER = 1,
        PT_LEFT = 2,
        PT_BEVEL = 4,
        PT_INNERBEVEL = 8
    }
}
declare module "cocos/ui/assembler/graphics/helper" {
    import { Impl } from "cocos/ui/assembler/graphics/webgl/impl";
    export function arc(ctx: Impl, cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise: boolean): void;
    export function ellipse(ctx: Impl, cx: number, cy: number, rx: number, ry: number): void;
    export function roundRect(ctx: Impl, x: number, y: number, w: number, h: number, r: number): void;
    export function tesselateBezier(ctx: Impl, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, level: number, type: number): void;
}
declare module "cocos/ui/assembler/graphics/webgl/impl" {
    import { Color, Vec2 } from "cocos/core/math/index";
    import { MeshRenderData } from "cocos/core/renderer/ui/render-data";
    import { LineCap, LineJoin, PointFlags } from "cocos/ui/assembler/graphics/types";
    export class Point extends Vec2 {
        dx: number;
        dy: number;
        dmx: number;
        dmy: number;
        flags: number;
        len: number;
        constructor(x: number, y: number);
        reset(): void;
    }
    export class Path {
        closed: boolean;
        bevel: number;
        complex: boolean;
        points: Point[];
        constructor();
        reset(): void;
    }
    export class Impl {
        dataOffset: number;
        updatePathOffset: boolean;
        pathLength: number;
        pathOffset: number;
        paths: Path[];
        tessTol: number;
        distTol: number;
        fillColor: Color;
        lineCap: LineCap;
        strokeColor: Color;
        lineJoin: LineJoin;
        lineWidth: number;
        pointsOffset: number;
        private _commandX;
        private _commandY;
        private _points;
        private _renderDataPool;
        private _renderDataList;
        private _curPath;
        moveTo(x: number, y: number): void;
        lineTo(x: number, y: number): void;
        bezierCurveTo(c1x: number, c1y: number, c2x: number, c2y: number, x: number, y: number): void;
        quadraticCurveTo(cx: number, cy: number, x: number, y: number): void;
        arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise: boolean): void;
        ellipse(cx: number, cy: number, rx: number, ry: number): void;
        circle(cx: number, cy: number, r: number): void;
        rect(x: number, y: number, w: number, h: number): void;
        roundRect(x: number, y: number, w: number, h: number, r: number): void;
        clear(clean?: boolean): void;
        close(): void;
        requestRenderData(): MeshRenderData;
        getRenderData(): MeshRenderData[];
        addPoint(x: number, y: number, flags: PointFlags): void;
        private _addPath;
    }
}
declare module "cocos/ui/components/graphics" {
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    import { Color } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { LineCap, LineJoin } from "cocos/ui/assembler/graphics/types";
    import { Impl } from "cocos/ui/assembler/graphics/webgl/impl";
    /**
     * @en
     * Graphics component.
     *
     * @zh
     * 自定义图形类
     */
    export class Graphics extends UIRenderable {
        /**
         * @en
         * Current line width.
         *
         * @zh
         * 当前线条宽度。
         */
        get lineWidth(): number;
        set lineWidth(value: number);
        /**
         * @en
         * Determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together.
         *
         * @zh
         * 用来设置2个长度不为0的相连部分（线段，圆弧，曲线）如何连接在一起的属性。
         */
        get lineJoin(): LineJoin;
        set lineJoin(value: LineJoin);
        /**
         * @en
         * Determines how the end points of every line are drawn.
         *
         * @zh
         * 指定如何绘制每一条线段末端。
         */
        get lineCap(): LineCap;
        set lineCap(value: LineCap);
        /**
         * @en
         * Stroke color.
         *
         * @zh
         * 线段颜色。
         */
        get strokeColor(): Readonly<Color>;
        set strokeColor(value: Readonly<Color>);
        /**
         * @en
         * Fill color.
         *
         * @zh
         * 填充颜色。
         */
        get fillColor(): Readonly<Color>;
        set fillColor(value: Readonly<Color>);
        /**
         * @en
         * Sets the miter limit ratio.
         *
         * @zh
         * 设置斜接面限制比例。
         */
        get miterLimit(): number;
        set miterLimit(value: number);
        get color(): Color;
        set color(value: Color);
        static LineJoin: typeof LineJoin;
        static LineCap: typeof LineCap;
        impl: Impl | null;
        model: scene.Model | null;
        protected _lineWidth: number;
        protected _strokeColor: Color;
        protected _lineJoin: LineJoin;
        protected _lineCap: LineCap;
        protected _fillColor: Color;
        protected _miterLimit: number;
        constructor();
        onRestore(): void;
        __preload(): void;
        onLoad(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Move path start point to (x,y).
         *
         * @zh
         * 移动路径起点到坐标(x, y)。
         *
         * @param x - 移动坐标 x 轴。
         * @param y - 移动坐标 y 轴。
         */
        moveTo(x: number, y: number): void;
        /**
         * @en
         * Adds a straight line to the path.
         *
         * @zh
         * 绘制直线路径。
         *
         * @param x - 绘制路径坐标 x 轴。
         * @param y - 绘制路径坐标 y 轴。
         */
        lineTo(x: number, y: number): void;
        /**
         * @en
         * Adds a cubic Bézier curve to the path.
         *
         * @zh
         * 绘制三次贝赛尔曲线路径。
         *
         * @param c1x - 第一个控制点的坐标 x 轴。
         * @param c1y - 第一个控制点的坐标 y 轴。
         * @param c2x - 第二个控制点的坐标 x 轴。
         * @param c2y - 第二个控制点的坐标 y 轴。
         * @param x - 最后一个控制点的坐标 x 轴。
         * @param y - 最后一个控制点的坐标 y 轴。
         */
        bezierCurveTo(c1x: number, c1y: number, c2x: number, c2y: number, x: number, y: number): void;
        /**
         * @en
         * Adds a quadratic Bézier curve to the path.
         *
         * @zh
         * 绘制二次贝赛尔曲线路径。
         *
         * @param cx - 起始控制点的坐标 x 轴。
         * @param cy - 起始控制点的坐标 y 轴。
         * @param x - 终点控制点的坐标 x 轴。
         * @param y - 终点控制点的坐标 x 轴。
         */
        quadraticCurveTo(cx: number, cy: number, x: number, y: number): void;
        /**
         * @en
         * Adds an arc to the path which is centered at (cx, cy) position with radius r starting at startAngle
         * and ending at endAngle going in the given direction by counterclockwise (defaulting to false).
         *
         * @zh
         * 绘制圆弧路径。圆弧路径的圆心在 (cx, cy) 位置，半径为 r ，根据 counterclockwise （默认为false）指定的方向从 startAngle 开始绘制，到 endAngle 结束。
         *
         * @param cx - 中心控制点的坐标 x 轴。
         * @param cy - 中心控制点的坐标 y 轴。
         * @param r - 圆弧弧度。
         * @param startAngle - 开始弧度，从正 x 轴顺时针方向测量。
         * @param endAngle - 结束弧度，从正 x 轴顺时针方向测量。
         * @param counterclockwise 如果为真，在两个角度之间逆时针绘制。默认顺时针。
         */
        arc(cx: number, cy: number, r: number, startAngle: number, endAngle: number, counterclockwise: boolean): void;
        /**
         * @en
         * Adds an ellipse to the path.
         *
         * @zh
         * 绘制椭圆路径。
         *
         * @param cx - 中心点的坐标 x 轴。
         * @param cy - 中心点的坐标 y 轴。
         * @param rx - 椭圆 x 轴半径。
         * @param ry - 椭圆 y 轴半径。
         */
        ellipse(cx: number, cy: number, rx: number, ry: number): void;
        /**
         * @en
         * Adds a circle to the path.
         *
         * @zh
         * 绘制圆形路径。
         *
         * @param cx - 中心点的坐标 x 轴。
         * @param cy - 中心点的坐标 y 轴。
         * @param r - 圆半径。
         */
        circle(cx: number, cy: number, r: number): void;
        /**
         * @en
         * Adds a rectangle to the path.
         *
         * @zh
         * 绘制矩形路径。
         *
         * @param x - 矩形起始坐标 x 轴。
         * @param y - 矩形起始坐标 y 轴。
         * @param w - 矩形宽度。
         * @param h - 矩形高度。
         */
        rect(x: number, y: number, w: number, h: number): void;
        /**
         * @en
         * Adds a round corner rectangle to the path.
         *
         * @zh
         * 绘制圆角矩形路径。
         *
         * @param x - 矩形起始坐标 x 轴。
         * @param y - 矩形起始坐标 y 轴。
         * @param w - 矩形宽度。
         * @param h - 矩形高度。
         * @param r - 矩形圆角半径。
         */
        roundRect(x: number, y: number, w: number, h: number, r: number): void;
        /**
         * @en
         * Draws a filled rectangle.
         *
         * @zh
         * 绘制填充矩形。
         *
         * @param x - 矩形起始坐标 x 轴。
         * @param y - 矩形起始坐标 y 轴。
         * @param w - 矩形宽度。
         * @param h - 矩形高度。
         */
        fillRect(x: any, y: any, w: any, h: any): void;
        /**
         * @en
         * Erasing any previously drawn content.
         *
         * @zh
         * 擦除之前绘制的所有内容的方法。
         */
        clear(clean?: boolean): void;
        /**
         * @en
         * Causes the point of the pen to move back to the start of the current path.
         * It tries to add a straight line from the current point to the start.
         *
         * @zh
         * 将笔点返回到当前路径起始点的。它尝试从当前点到起始点绘制一条直线。
         */
        close(): void;
        /**
         * @en
         * Strokes the current or given path with the current stroke style.
         *
         * @zh
         * 根据当前的画线样式，绘制当前或已经存在的路径。
         */
        stroke(): void;
        /**
         * @en
         * Fills the current or given path with the current fill style.
         *
         * @zh
         * 根据当前的画线样式，填充当前或已经存在的路径。
         */
        fill(): void;
        /**
         * @en
         * Manual instance material.
         *
         * @zh
         * 辅助材质实例化。可用于只取数据而无实体情况下渲染使用。特殊情况可参考：[[instanceMaterial]]
         */
        helpInstanceMaterial(): void;
        protected _render(render: UI): void;
        protected _flushAssembler(): void;
        protected _canRender(): boolean;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
    }
}
declare module "cocos/ui/components/mask" {
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    import { Color, Vec2 } from "cocos/core/math/index";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { Graphics } from "cocos/ui/components/graphics";
    import { TransformBit } from "cocos/core/scene-graph/node-enum";
    /**
     * @en The type for mask.
     *
     * @zh 遮罩组件类型。
     */
    export enum MaskType {
        /**
         * @en Rect mask.
         *
         * @zh
         * 使用矩形作为遮罩。
         */
        RECT = 0,
        /**
         * @en Ellipse Mask.
         *
         * @zh
         * 使用椭圆作为遮罩。
         */
        ELLIPSE = 1,
        /**
         * @en Ellipse Mask.
         *
         * @zh
         * 使用图像模版作为遮罩。
         */
        GRAPHICS_STENCIL = 2
    }
    /**
     * @en
     * The Mask Component.
     *
     * @zh
     * 遮罩组件。
     */
    export class Mask extends UIRenderable {
        /**
         * @en
         * The mask type.
         *
         * @zh
         * 遮罩类型。
         */
        get type(): MaskType;
        set type(value: MaskType);
        /**
         * @en
         * Reverse mask (Not supported Canvas Mode)
         * .
         * @zh
         * 反向遮罩（不支持 Canvas 模式）。
         */
        get inverted(): boolean;
        set inverted(value: boolean);
        /**
         * @en
         * The segments for ellipse mask.
         *
         * TODO: remove segments, not supported by graphics
         * @zh
         * 椭圆遮罩的曲线细分数。
         */
        get segments(): number;
        set segments(value: number);
        get graphics(): Graphics | null;
        get clearGraphics(): Graphics | null;
        get dstBlendFactor(): import("cocos/core").GFXBlendFactor;
        set dstBlendFactor(value: import("cocos/core").GFXBlendFactor);
        get srcBlendFactor(): import("cocos/core").GFXBlendFactor;
        set srcBlendFactor(value: import("cocos/core").GFXBlendFactor);
        get color(): Readonly<Color>;
        set color(value: Readonly<Color>);
        static Type: typeof MaskType;
        protected _type: MaskType;
        protected _inverted: boolean;
        protected _segments: number;
        protected _graphics: Graphics | null;
        protected _clearGraphics: Graphics | null;
        constructor();
        onLoad(): void;
        /**
         * @zh
         * 图形内容重塑。
         */
        onRestore(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @zh
         * 根据屏幕坐标计算点击事件。
         *
         * @param cameraPt  屏幕点转换到相机坐标系下的点。
         */
        isHit(cameraPt: Vec2): boolean;
        protected _render(render: UI): void;
        protected _postRender(render: UI): void;
        protected _nodeStateChange(type: TransformBit): void;
        protected _resolutionChanged(): void;
        protected _canRender(): boolean;
        protected _flushAssembler(): void;
        protected _createGraphics(): void;
        protected _updateClearGraphics(): void;
        protected _updateGraphics(): void;
        protected _enableGraphics(): void;
        protected _disableGraphics(): void;
        protected _removeGraphics(): void;
    }
}
declare module "cocos/ui/components/progress-bar" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    import { Sprite } from "cocos/ui/components/sprite";
    /**
     * @en
     * Enum for ProgressBar mode.
     *
     * @zh
     * 进度条模式。
     */
    enum Mode {
        /**
         * @en
         * The mode of horizontal.
         *
         * @zh
         * 水平方向模式。
         */
        HORIZONTAL = 0,
        /**
         * @en
         * The mode of vertical.
         *
         * @zh
         *  垂直方向模式。
         */
        VERTICAL = 1,
        /**
         * @en
         * The mode of fill.
         *
         * @zh
         * 填充模式。
         */
        FILLED = 2
    }
    /**
     * @en
     * Visual indicator of progress in some operation.
     * Displays a bar to the user representing how far the operation has progressed.
     *
     * @zh
     * 进度条组件，可用于显示加载资源时的进度。
     *
     * @example
     * ```ts
     * // update progressBar
     * update(dt) {
     *     var progress = progressBar.progress;
     *     if (progress > 0) {
     *         progress += dt;
     *     }
     *     else {
     *         progress = 1;
     *     }
     *     progressBar.progress = progress;
     * }
     * ```
     */
    export class ProgressBar extends Component {
        /**
         * @en
         * The targeted Sprite which will be changed progressively.
         *
         * @zh
         * 用来显示进度条比例的 Sprite 对象。
         */
        get barSprite(): Sprite | null;
        set barSprite(value: Sprite | null);
        /**
         * @en
         * The progress mode, there are two modes supported now: horizontal and vertical.
         *
         * @zh
         * 进度条的模式。
         */
        get mode(): Mode;
        set mode(value: Mode);
        /**
         * @en
         * The total width or height of the bar sprite.
         *
         * @zh
         * 进度条实际的总长度。
         */
        get totalLength(): number;
        set totalLength(value: number);
        /**
         * @en
         * The current progress of the bar sprite. The valid value is between 0-1.
         *
         * @zh
         * 当前进度值，该数值的区间是 0-1 之间。
         */
        get progress(): number;
        set progress(value: number);
        /**
         * @en
         * Whether reverse the progress direction of the bar sprite.
         *
         * @zh
         * 进度条是否进行反方向变化。
         */
        get reverse(): boolean;
        set reverse(value: boolean);
        static Mode: typeof Mode;
        protected _barSprite: Sprite | null;
        protected _mode: Mode;
        protected _totalLength: number;
        protected _progress: number;
        protected _reverse: boolean;
        protected _initBarSprite(): void;
        protected _updateBarStatus(): void;
    }
}
declare module "cocos/ui/components/label-outline" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    import { Color } from "cocos/core/math/index";
    /**
     * @en
     * Outline effect used to change the display, only for system fonts or TTF fonts.
     *
     * @zh
     * 描边效果组件,用于字体描边,只能用于系统字体。
     *
     * @example
     * ```ts
     * import { Node, Label, LabelOutline } from 'cc';
     * // Create a new node and add label components.
     * const node = new Node("New Label");
     * const label = node.addComponent(Label);
     * const outline = node.addComponent(LabelOutline);
     * node.parent = this.node;
     * ```
     */
    export class LabelOutline extends Component {
        protected _color: Color;
        protected _width: number;
        /**
         * @en
         * Outline color.
         *
         * @zh
         * 改变描边的颜色。
         *
         * @example
         * ```ts
         * import { Color } from 'cc';
         * outline.color = new Color(0.5, 0.3, 0.7, 1.0);
         * ```
         */
        get color(): Readonly<Color>;
        set color(value: Readonly<Color>);
        /**
         * @en
         * Change the outline width.
         *
         * @zh
         * 改变描边的宽度。
         *
         * @example
         * ```ts
         * outline.width = 3;
         * ```
         */
        get width(): number;
        set width(value: number);
        onEnable(): void;
        onDisable(): void;
        protected _updateRenderData(): void;
    }
}
declare module "cocos/ui/components/rich-text" {
    /**
     * @category ui
     */
    import { SpriteAtlas, TTFFont } from "cocos/core/assets/index";
    import { EventTouch } from "cocos/core/platform/index";
    import { IHtmlTextParserResultObj } from "cocos/core/utils/index";
    import { Vec2 } from "cocos/core/math/index";
    import { PrivateNode } from "cocos/core/scene-graph/index";
    import { CacheMode, HorizontalTextAlignment, VerticalTextAlignment } from "cocos/ui/components/label";
    import { UIComponent, UIRenderable } from "cocos/core/components/ui-base/index";
    interface ILabelSegment {
        node: PrivateNode;
        comp: UIRenderable | null;
        lineCount: number;
        styleIndex: number;
        imageOffset: string;
        clickParam: string;
        clickHandler: string;
    }
    /**
     * @en
     * The RichText Component.
     *
     * @zh
     * 富文本组件。
     */
    export class RichText extends UIComponent {
        /**
         * @en
         * Content string of RichText.
         *
         * @zh
         * 富文本显示的文本内容。
         */
        get string(): string;
        set string(value: string);
        /**
         * @en
         * Horizontal Alignment of each line in RichText.
         *
         * @zh
         * 文本内容的水平对齐方式。
         */
        get horizontalAlign(): HorizontalTextAlignment;
        set horizontalAlign(value: HorizontalTextAlignment);
        /**
         * @en
         * Font size of RichText.
         *
         * @zh
         * 富文本字体大小。
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * @en
         * Custom System font of RichText
         *
         * @zh
         * 富文本定制系统字体
         */
        get fontFamily(): string;
        set fontFamily(value: string);
        /**
         * @en
         * Custom System font of RichText.
         *
         * @zh
         * 富文本定制字体。
         */
        get font(): TTFFont | null;
        set font(value: TTFFont | null);
        /**
         * @en
         * Whether use system font name or not.
         *
         * @zh
         * 是否使用系统字体。
         */
        get useSystemFont(): boolean;
        set useSystemFont(value: boolean);
        /**
         * @en
         * The cache mode of label. This mode only supports system fonts.
         *
         * @zh
         * 文本缓存模式, 该模式只支持系统字体。
         */
        get cacheMode(): CacheMode;
        set cacheMode(value: CacheMode);
        /**
         * @en
         * The maximize width of the RichText.
         *
         * @zh
         * 富文本的最大宽度。
         */
        get maxWidth(): number;
        set maxWidth(value: number);
        /**
         * @en
         * Line Height of RichText.
         *
         * @zh
         * 富文本行高。
         */
        get lineHeight(): number;
        set lineHeight(value: number);
        /**
         * @en
         * The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the image atlas.
         *
         * @zh
         * 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。
         */
        get imageAtlas(): SpriteAtlas | null;
        set imageAtlas(value: SpriteAtlas | null);
        /**
         * @en
         * Once checked, the RichText will block all input events (mouse and touch) within
         * the bounding box of the node, preventing the input from penetrating into the underlying node.
         *
         * @zh
         * 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。
         */
        get handleTouchEvent(): boolean;
        set handleTouchEvent(value: boolean);
        static HorizontalAlign: typeof HorizontalTextAlignment;
        static VerticalAlign: typeof VerticalTextAlignment;
        protected _lineHeight: number;
        protected _string: string;
        protected _horizontalAlign: HorizontalTextAlignment;
        protected _fontSize: number;
        protected _maxWidth: number;
        protected _fontFamily: string;
        protected _font: TTFFont | null;
        protected _isSystemFontUsed: boolean;
        protected _userDefinedFont: TTFFont | null;
        protected _cacheMode: CacheMode;
        protected _imageAtlas: SpriteAtlas | null;
        protected _handleTouchEvent: boolean;
        protected _textArray: IHtmlTextParserResultObj[];
        protected _labelSegments: ILabelSegment[];
        protected _labelSegmentsCache: ILabelSegment[];
        protected _linesWidth: number[];
        protected _lineCount: number;
        protected _labelWidth: number;
        protected _labelHeight: number;
        protected _layoutDirty: boolean;
        protected _lineOffsetX: number;
        protected _updateRichTextStatus: () => void;
        constructor();
        onEnable(): void;
        onDisable(): void;
        start(): void;
        onRestore(): void;
        onDestroy(): void;
        protected _addEventListeners(): void;
        protected _removeEventListeners(): void;
        protected _updateLabelSegmentTextAttributes(): void;
        protected _createFontLabel(str: string): ILabelSegment;
        protected _onTTFLoaded(): void;
        protected _measureText(styleIndex: number, string?: string): number | ((s: string) => number);
        protected _onTouchEnded(event: EventTouch): void;
        protected _containsTouchLocation(label: ILabelSegment, point: Vec2): boolean;
        protected _resetState(): void;
        protected _activateChildren(active: any): void;
        protected _addLabelSegment(stringToken: string, styleIndex: number): ILabelSegment;
        protected _updateRichTextWithMaxWidth(labelString: string, labelWidth: number, styleIndex: number): void;
        protected _isLastComponentCR(stringToken: any): boolean;
        protected _updateLineInfo(): void;
        protected _needsUpdateTextLayout(newTextArray: IHtmlTextParserResultObj[]): boolean;
        protected _addRichTextImageElement(richTextElement: IHtmlTextParserResultObj): void;
        protected _updateRichText(): void;
        protected _getFirstWordLen(text: string, startIndex: number, textLen: number): number;
        protected _updateRichTextPosition(): void;
        protected _convertLiteralColorValue(color: string): any;
        protected _applyTextAttribute(labelSeg: ILabelSegment): void;
    }
}
declare module "cocos/ui/components/view-group" {
    /**
     * @category ui
     */
    /**
     * @en
     * Handling touch events in a ViewGroup takes special care,
     * because it's common for a ViewGroup to have children that are targets for different touch events than the ViewGroup itself.
     * To make sure that each view correctly receives the touch events intended for it,
     * ViewGroup should register capture phase event and handle the event propagation properly.
     * Please refer to ScrollView for more information.
     *
     * @zh
     * ViewGroup 的事件处理比较特殊，因为 ViewGroup 里面的子节点关心的事件跟 ViewGroup 本身可能不一样。
     * 为了让子节点能够正确地处理事件，ViewGroup 需要注册 capture 阶段的事件，并且合理地处理 ViewGroup 之间的事件传递。
     * 请参考 ScrollView 的实现来获取更多信息。
     */
    import { Component } from "cocos/core/components/index";
    export class ViewGroup extends Component {
    }
}
declare module "cocos/ui/components/scroll-view" {
    /**
     * @category ui
     */
    import { EventHandler as ComponentEventHandler } from "cocos/core/components/component-event-handler";
    import { UITransform } from "cocos/core/components/ui-base/index";
    import { Event } from "cocos/core/event/index";
    import { EventMouse, EventTouch, Touch } from "cocos/core/platform/index";
    import { Size, Vec2, Vec3 } from "cocos/core/math/index";
    import { ScrollBar } from "cocos/ui/components/scroll-bar";
    import { ViewGroup } from "cocos/ui/components/view-group";
    import { Node } from "cocos/core/scene-graph/node";
    import { TransformBit } from "cocos/core/scene-graph/node-enum";
    /**
     * @en
     * Enum for ScrollView event type.
     *
     * @zh
     * 滚动视图事件类型
     */
    export enum EventType {
        /**
         * @en
         * The event emitted when ScrollView scroll to the top boundary of inner container.
         *
         * @zh
         * 滚动视图滚动到顶部边界事件。
         */
        SCROLL_TO_TOP = "scroll-to-top",
        /**
         * @en
         * The event emitted when ScrollView scroll to the bottom boundary of inner container.
         *
         * @zh
         * 滚动视图滚动到底部边界事件。
         */
        SCROLL_TO_BOTTOM = "scroll-to-bottom",
        /**
         * @en
         * The event emitted when ScrollView scroll to the left boundary of inner container.
         *
         * @zh
         * 滚动视图滚动到左边界事件。
         */
        SCROLL_TO_LEFT = "scroll-to-left",
        /**
         * @en
         * The event emitted when ScrollView scroll to the right boundary of inner container.
         *
         * @zh
         * 滚动视图滚动到右边界事件。
         */
        SCROLL_TO_RIGHT = "scroll-to-right",
        /**
         * @en
         * The event emitted when ScrollView scroll began.
         *
         * @zh
         * 滚动视图滚动开始时发出的事件。
         */
        SCROLL_BEGAN = "scroll-began",
        /**
         * @en
         * The event emitted when ScrollView auto scroll ended.
         *
         * @zh
         * 滚动视图滚动结束的时候发出的事件。
         */
        SCROLL_ENDED = "scroll-ended",
        /**
         * @en
         * The event emitted when ScrollView scroll to the top boundary of inner container and start bounce.
         *
         * @zh
         * 滚动视图滚动到顶部边界并且开始回弹时发出的事件。
         */
        BOUNCE_TOP = "bounce-top",
        /**
         * @en
         * The event emitted when ScrollView scroll to the bottom boundary of inner container and start bounce.
         *
         * @zh
         * 滚动视图滚动到底部边界并且开始回弹时发出的事件。
         */
        BOUNCE_BOTTOM = "bounce-bottom",
        /**
         * @en
         * The event emitted when ScrollView scroll to the left boundary of inner container and start bounce.
         *
         * @zh
         * 滚动视图滚动到左边界并且开始回弹时发出的事件。
         */
        BOUNCE_LEFT = "bounce-left",
        /**
         * @en
         * The event emitted when ScrollView scroll to the right boundary of inner container and start bounce.
         *
         * @zh
         * 滚动视图滚动到右边界并且开始回弹时发出的事件。
         */
        BOUNCE_RIGHT = "bounce-right",
        /**
         * @en
         * The event emitted when ScrollView is scrolling.
         *
         * @zh
         * 滚动视图正在滚动时发出的事件。
         */
        SCROLLING = "scrolling",
        /**
         * @en
         * The event emitted when ScrollView auto scroll ended with a threshold.
         *
         * @zh
         * 滚动视图自动滚动快要结束的时候发出的事件。
         */
        SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold",
        /**
         * @en
         * The event emitted when user release the touch.
         *
         * @zh
         * 当用户松手的时候会发出一个事件。
         */
        TOUCH_UP = "touch-up"
    }
    /**
     * @en
     * Layout container for a view hierarchy that can be scrolled by the user,
     * allowing it to be larger than the physical display.
     *
     * @zh
     * 滚动视图组件。
     */
    export class ScrollView extends ViewGroup {
        static EventType: typeof EventType;
        /**
         * @en
         * The elapse time of bouncing back. A value of 0 will bounce back immediately.
         *
         * @zh
         * 回弹持续的时间，0 表示将立即反弹。
         */
        bounceDuration: number;
        /**
         * @en
         * It determines how quickly the content stop moving. A value of 1 will stop the movement immediately.
         * A value of 0 will never stop the movement until it reaches to the boundary of scrollview.
         *
         * @zh
         * 开启惯性后，在用户停止触摸后滚动多快停止，0表示永不停止，1表示立刻停止。
         */
        brake: number;
        /**
         * @en
         * When elastic is set, the content will be bounce back when move out of boundary.
         *
         * @zh
         * 是否允许滚动内容超过边界，并在停止触摸后回弹。
         */
        elastic: boolean;
        /**
         * @en
         * When inertia is set, the content will continue to move when touch ended.
         *
         * @zh
         * 是否开启滚动惯性。
         */
        inertia: boolean;
        /**
         * @en
         * This is a reference to the UI element to be scrolled.
         *
         * @zh
         * 可滚动展示内容的节点。
         */
        get content(): Node | null;
        set content(value: Node | null);
        /**
         * @en
         * Enable horizontal scroll.
         *
         * @zh
         * 是否开启水平滚动。
         */
        horizontal: boolean;
        /**
         * @en
         * The horizontal scrollbar reference.
         * @zh
         * 水平滚动的 ScrollBar。
         */
        get horizontalScrollBar(): ScrollBar | null;
        set horizontalScrollBar(value: ScrollBar | null);
        /**
         * @en
         * Enable vertical scroll.
         *
         * @zh
         * 是否开启垂直滚动。
         */
        vertical: boolean;
        /**
         * @en
         * The vertical scrollbar reference.
         *
         * @zh
         * 垂直滚动的 ScrollBar。
         */
        get verticalScrollBar(): ScrollBar | null;
        set verticalScrollBar(value: ScrollBar | null);
        /**
         * @en
         * If cancelInnerEvents is set to true, the scroll behavior will cancel touch events on inner content nodes
         * It's set to true by default.
         *
         * @zh
         * 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。<br/>
         * 注意，子节点上的 touchstart 事件仍然会触发，触点移动距离非常短的情况下 touchmove 和 touchend 也不会受影响。
         */
        cancelInnerEvents: boolean;
        /**
         * @en
         * ScrollView events callback.
         *
         * @zh
         * 滚动视图的事件回调函数。
         */
        scrollEvents: ComponentEventHandler[];
        get view(): UITransform | null;
        protected _autoScrolling: boolean;
        protected _scrolling: boolean;
        protected _content: Node | null;
        protected _horizontalScrollBar: ScrollBar | null;
        protected _verticalScrollBar: ScrollBar | null;
        protected _topBoundary: number;
        protected _bottomBoundary: number;
        protected _leftBoundary: number;
        protected _rightBoundary: number;
        protected _touchMoveDisplacements: Vec3[];
        protected _touchMoveTimeDeltas: number[];
        protected _touchMovePreviousTimestamp: number;
        protected _touchMoved: boolean;
        protected _autoScrollAttenuate: boolean;
        protected _autoScrollStartPosition: Vec3;
        protected _autoScrollTargetDelta: Vec3;
        protected _autoScrollTotalTime: number;
        protected _autoScrollAccumulatedTime: number;
        protected _autoScrollCurrentlyOutOfBoundary: boolean;
        protected _autoScrollBraking: boolean;
        protected _autoScrollBrakingStartPosition: Vec3;
        protected _outOfBoundaryAmount: Vec3;
        protected _outOfBoundaryAmountDirty: boolean;
        protected _stopMouseWheel: boolean;
        protected _mouseWheelEventElapsedTime: number;
        protected _isScrollEndedWithThresholdEventFired: boolean;
        protected _scrollEventEmitMask: number;
        protected _isBouncing: boolean;
        protected _contentPos: Vec3;
        protected _deltaPos: Vec3;
        /**
         * @en
         * Scroll the content to the bottom boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图底部。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到底部边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the bottom of the view.
         * scrollView.scrollToBottom(0.1);
         * ```
         */
        scrollToBottom(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图顶部。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到顶部边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the top of the view.
         * scrollView.scrollToTop(0.1);
         * ```
         */
        scrollToTop(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左边。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到左边边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the left of the view.
         * scrollView.scrollToLeft(0.1);
         * ```
         */
        scrollToLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右边。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到右边边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the right of the view.
         * scrollView.scrollToRight(0.1);
         * ```
         */
        scrollToRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左上角。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到左上边边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the upper left corner of the view.
         * scrollView.scrollToTopLeft(0.1);
         * ```
         */
        scrollToTopLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the top right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右上角。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到右上边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the top right corner of the view.
         * scrollView.scrollToTopRight(0.1);
         * ```
         */
        scrollToTopRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the bottom left boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图左下角。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到左下边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the lower left corner of the view.
         * scrollView.scrollToBottomLeft(0.1);
         * ```
         */
        scrollToBottomLeft(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the bottom right boundary of ScrollView.
         *
         * @zh
         * 视图内容将在规定时间内滚动到视图右下角。
         *
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到右边下边界。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to the lower right corner of the view.
         * scrollView.scrollToBottomRight(0.1);
         * ```
         */
        scrollToBottomRight(timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll with an offset related to the ScrollView's top left origin, if timeInSecond is omitted, then it will jump to the specific offset immediately.
         *
         * @zh
         * 视图内容在规定时间内将滚动到 ScrollView 相对左上角原点的偏移位置, 如果 timeInSecond 参数不传，则立即滚动到指定偏移位置。
         *
         * @param offset - 指定移动偏移量。
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到指定偏移量处。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to middle position in 0.1 second in x-axis
         * let maxScrollOffset = this.getMaxScrollOffset();
         * scrollView.scrollToOffset(new Vec3(maxScrollOffset.x / 2, 0, 0), 0.1);
         * ```
         */
        scrollToOffset(offset: Vec3, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Get the positive offset value corresponds to the content's top left boundary.
         *
         * @zh
         * 获取滚动视图相对于左上角原点的当前滚动偏移。
         *
         * @return - 当前滚动偏移量。
         */
        getScrollOffset(): Vec3;
        /**
         * @en
         * Get the maximize available  scroll offset.
         *
         * @zh
         * 获取滚动视图最大可以滚动的偏移量。
         *
         * @return - 最大可滚动偏移量。
         */
        getMaxScrollOffset(): Vec3;
        /**
         * @en
         * Scroll the content to the horizontal percent position of ScrollView.
         *
         * @zh
         * 视图内容在规定时间内将滚动到 ScrollView 水平方向的百分比位置上。
         *
         * @param percent - 0 - 之间的百分比。
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到指定水平百分比位置。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Scroll to middle position.
         * scrollView.scrollToBottomRight(0.5, 0.1);
         * ```
         */
        scrollToPercentHorizontal(percent: number, timeInSecond: number, attenuated: boolean): void;
        /**
         * @en
         * Scroll the content to the percent position of ScrollView in any direction.
         *
         * @zh
         * 视图内容在规定时间内进行垂直方向和水平方向的滚动，并且滚动到指定百分比位置上。
         *
         * @param anchor - 在 new Vec2(0,0) and new Vec2(1,1) 上取差值的一个点。
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到指定水平或垂直百分比位置。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * // Vertical scroll to the bottom of the view.
         * scrollView.scrollTo(new Vec2(0, 1), 0.1);
         *
         * // Horizontal scroll to view right.
         * scrollView.scrollTo(new Vec2(1, 0), 0.1);
         * ```
         */
        scrollTo(anchor: Vec2, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Scroll the content to the vertical percent position of ScrollView.
         *
         * @zh
         * 视图内容在规定时间内滚动到 ScrollView 垂直方向的百分比位置上。
         *
         * @param percent - 0 - 1 之间的百分比。
         * @param timeInSecond - 滚动时间（s）。 如果超时，内容将立即跳到指定垂直百分比位置。
         * @param attenuated - 滚动加速是否衰减，默认为 true。
         * @example
         * ```ts
         * scrollView.scrollToPercentVertical(0.5, 0.1);
         * ```
         */
        scrollToPercentVertical(percent: number, timeInSecond?: number, attenuated?: boolean): void;
        /**
         * @en
         * Stop auto scroll immediately.
         *
         * @zh
         * 停止自动滚动, 调用此 API 可以让 ScrollView 立即停止滚动。
         */
        stopAutoScroll(): void;
        /**
         * @en
         * Modify the content position.
         *
         * @zh
         * 设置当前视图内容的坐标点。
         *
         * @param position - 当前视图坐标点.
         */
        setContentPosition(position: Vec3): void;
        /**
         * @en
         * Query the content's position in its parent space.
         *
         * @zh
         * 获取当前视图内容的坐标点。
         *
         * @returns - 当前视图内容的坐标点.
         */
        getContentPosition(): Vec3;
        /**
         * @en
         * Query whether the user is currently dragging the ScrollView to scroll it.
         *
         * @zh
         * 用户是否在拖拽当前滚动视图。
         *
         * @returns - 是否在拖拽当前滚动视图。
         */
        isScrolling(): boolean;
        /**
         * @en
         * Query whether the ScrollView is currently scrolling because of a bounceback or inertia slowdown.
         *
         * @zh
         * 当前滚动视图是否在惯性滚动。
         *
         * @returns - 滚动视图是否在惯性滚动。
         */
        isAutoScrolling(): boolean;
        getScrollEndedEventTiming(): number;
        start(): void;
        onEnable(): void;
        update(dt: number): void;
        onDisable(): void;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _onMouseWheel(event: EventMouse, captureListeners?: Node[]): void;
        protected _onTouchBegan(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchMoved(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchEnded(event: EventTouch, captureListeners?: Node[]): void;
        protected _onTouchCancelled(event: EventTouch, captureListeners?: Node[]): void;
        protected _calculateBoundary(): void;
        protected _hasNestedViewGroup(event: Event, captureListeners?: Node[]): boolean | undefined;
        protected _startInertiaScroll(touchMoveVelocity: Vec3): void;
        protected _calculateAttenuatedFactor(distance: number): number;
        protected _startAttenuatingAutoScroll(deltaMove: Vec3, initialVelocity: Vec3): void;
        protected _calculateAutoScrollTimeByInitialSpeed(initialSpeed: number): number;
        protected _startAutoScroll(deltaMove: Vec3, timeInSecond: number, attenuated?: boolean): void;
        protected _calculateTouchMoveVelocity(): Vec3;
        protected _flattenVectorByDirection(vector: Vec3): Vec3;
        protected _moveContent(deltaMove: Vec3, canStartBounceBack?: boolean): void;
        protected _getContentLeftBoundary(): number;
        protected _getContentRightBoundary(): number;
        protected _getContentTopBoundary(): number;
        protected _getContentBottomBoundary(): number;
        protected _getHowMuchOutOfBoundary(addition?: Vec3): Vec3;
        protected _updateScrollBar(outOfBoundary: Vec3): void;
        protected _onScrollBarTouchBegan(): void;
        protected _onScrollBarTouchEnded(): void;
        protected _dispatchEvent(event: string): void;
        protected _adjustContentOutOfBoundary(): void;
        protected _hideScrollBar(): void;
        protected _updateScrollBarState(): void;
        protected _stopPropagationIfTargetIsMe(event: Event): void;
        protected _processDeltaMove(deltaMove: Vec3): void;
        protected _handleMoveLogic(touch: Touch): void;
        protected _handleReleaseLogic(touch: Touch): void;
        protected _getLocalAxisAlignDelta(touch: Touch): Vec3;
        protected _scrollChildren(deltaMove: Vec3): void;
        protected _handlePressLogic(): void;
        protected _clampDelta(delta: Vec3): Vec3;
        protected _gatherTouchMove(delta: Vec3): void;
        protected _startBounceBackIfNeeded(): boolean;
        protected _processInertiaScroll(): void;
        protected _isOutOfBoundary(): boolean;
        protected _isNecessaryAutoScrollBrake(): boolean;
        protected _processAutoScrolling(dt: any): void;
        protected _checkMouseWheel(dt: number): void;
        protected _calculateMovePercentDelta(options: any): Vec3;
        protected _moveContentToTopLeft(scrollViewSize: Size): void;
        protected _scaleChanged(value: TransformBit): void;
    }
}
declare module "cocos/ui/components/scroll-bar" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    import { Size, Vec3 } from "cocos/core/math/index";
    import { ScrollView } from "cocos/ui/components/scroll-view";
    import { Sprite } from "cocos/ui/components/sprite";
    import { Node } from "cocos/core/index";
    /**
     * @en
     * Enum for ScrollBar direction.
     *
     * @zh
     * 滚动条方向。
     */
    enum Direction {
        /**
         * @en
         * Horizontal scroll.
         *
         * @zh
         * 横向滚动。
         */
        HORIZONTAL = 0,
        /**
         * @en
         * Vertical scroll.
         *
         * @zh
         * 纵向滚动。
         */
        VERTICAL = 1
    }
    /**
     * @en
     * The ScrollBar control allows the user to scroll an image or other view that is too large to see completely.
     *
     * @zh
     * 滚动条组件。
     */
    export class ScrollBar extends Component {
        /**
         * @en
         * The "handle" part of the ScrollBar.
         *
         * @zh
         * 作为当前滚动区域位置显示的滑块 Sprite。
         */
        get handle(): Sprite | null;
        set handle(value: Sprite | null);
        /**
         * @en
         * The direction of scrolling.
         *
         * @zh
         * ScrollBar 的滚动方向。
         */
        get direction(): Direction;
        set direction(value: Direction);
        /**
         * @en
         * Whether enable auto hide or not.
         *
         * @zh
         * 是否在没有滚动动作时自动隐藏 ScrollBar。
         */
        get enableAutoHide(): boolean;
        set enableAutoHide(value: boolean);
        /**
         * @en
         * The time to hide ScrollBar when scroll finished.
         * Note: This value is only useful when enableAutoHide is true.
         *
         * @zh
         * 没有滚动动作后经过多久会自动隐藏。<br/>
         * 注意：只要当 “enableAutoHide” 为 true 时，才有效。
         */
        get autoHideTime(): number;
        set autoHideTime(value: number);
        static Direction: typeof Direction;
        protected _scrollView: ScrollView | null;
        protected _handle: Sprite | null;
        protected _direction: Direction;
        protected _enableAutoHide: boolean;
        protected _autoHideTime: number;
        protected _touching: boolean;
        protected _opacity: number;
        protected _autoHideRemainingTime: number;
        /**
         * @en
         * Hide ScrollBar.
         *
         * @zh
         * 滚动条隐藏。
         */
        hide(): void;
        /**
         * @en
         * Show ScrollBar.
         *
         * @zh
         * 滚动条显示。
         */
        show(): void;
        /**
         * @en
         * Reset the position of ScrollBar.
         *
         * @zh
         * 重置滚动条位置。
         *
         * @param outOfBoundary - 滚动位移。
         */
        onScroll(outOfBoundary: Vec3): void;
        /**
         * @zh
         * 滚动视窗设置。
         *
         * @param scrollView - 滚动视窗。
         */
        setScrollView(scrollView: ScrollView): void;
        onTouchBegan(): void;
        onTouchEnded(): void;
        protected onEnable(): void;
        protected start(): void;
        protected update(dt: any): void;
        protected _convertToScrollViewSpace(content: Node): Vec3;
        protected _setOpacity(opacity: number): void;
        protected _updateHandlerPosition(position: Vec3): void;
        protected _fixupHandlerPosition(): Vec3;
        protected _conditionalDisableScrollBar(contentSize: Size, scrollViewSize: Size): boolean;
        protected _calculateLength(contentMeasure: number, scrollViewMeasure: number, handleNodeMeasure: number, outOfBoundary: number): number;
        protected _calculatePosition(contentMeasure: number, scrollViewMeasure: number, handleNodeMeasure: number, contentPosition: number, outOfBoundary: number, actualLenth: number): Vec3;
        protected _updateLength(length: number): void;
        protected _processAutoHide(deltaTime: number): void;
    }
}
declare module "cocos/ui/components/slider" {
    /**
     * @category ui
     */
    import { Component, EventHandler } from "cocos/core/components/index";
    import { EventTouch, Touch } from "cocos/core/platform/index";
    import { Sprite } from "cocos/ui/components/sprite";
    /**
     * @en
     * The Slider Direction.
     *
     * @zh
     * 滑动器方向。
     */
    enum Direction {
        /**
         * @en
         * The horizontal direction.
         *
         * @zh
         * 水平方向。
         */
        Horizontal = 0,
        /**
         * @en
         * The vertical direction.
         *
         * @zh
         * 垂直方向。
         */
        Vertical = 1
    }
    /**
     * @en
     * The Slider Control.
     *
     * @zh
     * 滑动器组件。
     */
    export class Slider extends Component {
        /**
         * @en
         * The "handle" part of the slider.
         *
         * @zh
         * 滑动器滑块按钮部件。
         */
        get handle(): Sprite | null;
        set handle(value: Sprite | null);
        /**
         * @en
         * The slider direction.
         *
         * @zh
         * 滑动器方向。
         */
        get direction(): number;
        set direction(value: number);
        /**
         * @en
         * The current progress of the slider. The valid value is between 0-1.
         *
         * @zh
         * 当前进度值，该数值的区间是 0-1 之间。
         */
        get progress(): number;
        set progress(value: number);
        static Direction: typeof Direction;
        /**
         * @en
         * The slider slide events' callback array.
         *
         * @zh
         * 滑动器组件事件回调函数。
         */
        slideEvents: EventHandler[];
        private _handle;
        private _direction;
        private _progress;
        private _offset;
        private _dragging;
        private _touchHandle;
        private _handleLocalPos;
        private _touchPos;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        protected _onHandleDragStart(event?: EventTouch): void;
        protected _onTouchBegan(event?: EventTouch): void;
        protected _onTouchMoved(event?: EventTouch): void;
        protected _onTouchEnded(event?: EventTouch): void;
        protected _onTouchCancelled(event?: EventTouch): void;
        protected _handleSliderLogic(touch: Touch | null): void;
        protected _emitSlideEvent(): void;
        protected _updateProgress(touch: Touch | null): void;
        protected _updateHandlePosition(): void;
        private _changeLayout;
    }
}
declare module "cocos/ui/components/toggle-container" {
    /**
     * @category ui
     */
    import { Component, EventHandler as ComponentEventHandler } from "cocos/core/components/index";
    import { Toggle } from "cocos/ui/components/toggle";
    /**
     * @en
     * ToggleContainer is not a visible UI component but a way to modify the behavior of a set of Toggles. <br/>
     * Toggles that belong to the same group could only have one of them to be switched on at a time.<br/>
     * Note: All the first layer child node containing the toggle component will auto be added to the container.
     *
     * @zh
     * ToggleGroup 不是一个可见的 UI 组件，它可以用来修改一组 Toggle  组件的行为。当一组 Toggle 属于同一个 ToggleGroup 的时候，<br/>
     * 任何时候只能有一个 Toggle 处于选中状态。
     */
    export class ToggleContainer extends Component {
        protected _allowSwitchOff: boolean;
        /**
         * @en
         * If this setting is true, a toggle could be switched off and on when pressed.
         * If it is false, it will make sure there is always only one toggle could be switched on
         * and the already switched on toggle can't be switched off.
         *
         * @zh
         * 如果这个设置为 true，那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。
         */
        get allowSwitchOff(): boolean;
        set allowSwitchOff(value: boolean);
        /**
         * @en
         * If Toggle is clicked, it will trigger event's handler.
         *
         * @zh
         * Toggle 按钮的点击事件列表。
         */
        checkEvents: ComponentEventHandler[];
        /**
         * @en
         * Read only property, return the toggle items array reference managed by ToggleContainer.
         *
         * @zh
         * 只读属性，返回 toggleContainer 管理的 toggle 数组引用。
         */
        get toggleItems(): (Toggle | undefined)[];
        start(): void;
        activeToggles(): (Toggle | undefined)[];
        anyTogglesChecked(): boolean;
        /**
         * @en
         * Refresh the state of the managed toggles.
         *
         * @zh
         * 刷新管理的 toggle 状态。
         *
         * @param toggle - 需要被更新的 toggle。
         * @param emitEvent - 是否需要触发事件
         */
        notifyToggleCheck(toggle: Toggle, emitEvent?: boolean): void;
        ensureValidState(): void;
    }
}
declare module "cocos/core/data/utils/extends-enum" {
    /**
     * @zh
     * 组合任意多个枚举。
     * 此函数的行为等价于返回了一个新的枚举，其成员囊括了所有源枚举的成员。
     * 这些枚举的成员必须各不相同（包括成员名和值），否则行为是未定义的。
     * @en
     * Combine arbitray number of enumerations.
     * It behaves like an enumeration having members that is a combination of members of the source enumerations
     * is returned.
     * These enumerations shall have non-overlaped member names or member values.
     * If not, the behavior is undefined.
     * @example
     * ```ts
     * enum Apple { apple = 'apple', }
     * enum Pen { pen = 'pen' }
     * // As if `enum ApplePen { apple = 'apple'; pen = 'pen'; }`
     * const ApplePen = extendsEnum(Apple, Pen);
     * ```
     */
    export function extendsEnum(): {};
    export function extendsEnum<E0>(e0: E0): E0;
    export function extendsEnum<E0, E1>(e0: E0, e1: E1): E0 & E1;
    export function extendsEnum<E0, E1, E2>(e0: E0, e1: E1, e2: E2): E0 & E1 & E2;
    export function extendsEnum<E0, E1, E2, E3>(e0: E0, e1: E1, e2: E2, e3: E3): E0 & E1 & E2 & E3;
}
declare module "cocos/ui/components/toggle" {
    /**
     * @category ui
     */
    import { EventHandler as ComponentEventHandler } from "cocos/core/components/component-event-handler";
    import { Button } from "cocos/ui/components/button";
    import { Sprite } from "cocos/ui/components/sprite";
    import { ToggleContainer } from "cocos/ui/components/toggle-container";
    import { EventType as ButtonEventType } from "cocos/ui/components/button";
    enum EventType {
        TOGGLE = "toggle"
    }
    /**
     * @en
     * The toggle component is a CheckBox, when it used together with a ToggleGroup,
     * it could be treated as a RadioButton.
     *
     * @zh
     * Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton。
     */
    export class Toggle extends Button {
        /**
         * @en
         * When this value is true, the check mark component will be enabled,
         * otherwise the check mark component will be disabled.
         *
         * @zh
         * 如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。
         */
        get isChecked(): boolean;
        set isChecked(value: boolean);
        /**
         * @en
         * The image used for the checkmark.
         *
         * @zh
         * Toggle 处于选中状态时显示的图片。
         */
        get checkMark(): Sprite | null;
        set checkMark(value: Sprite | null);
        set _resizeToTarget(value: boolean);
        get _toggleContainer(): ToggleContainer | null;
        static EventType: typeof EventType & typeof ButtonEventType;
        /**
         * @en
         * If Toggle is clicked, it will trigger event's handler.
         *
         * @zh
         * Toggle 按钮的点击事件列表。
         */
        checkEvents: ComponentEventHandler[];
        protected _isChecked: boolean;
        protected _checkMark: Sprite | null;
        protected _internalToggle(): void;
        protected _set(value: boolean, emitEvent?: boolean): void;
        playEffect(): void;
        /**
         * @en
         * Set isChecked without invoking checkEvents.
         *
         * @zh
         * 设置 isChecked 而不调用 checkEvents 回调。
         *
         * @param value - 是否被按下
         */
        setIsCheckedWithoutNotify(value: boolean): void;
        onEnable(): void;
        onDisable(): void;
        OnDestroy(): void;
        protected _emitToggleEvents(): void;
    }
}
declare module "cocos/ui/components/ui-mesh-renderer" {
    /**
     * @category ui
     */
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    import { UIComponent } from "cocos/core/components/ui-base/ui-component";
    import { UI } from "cocos/core/renderer/ui/ui";
    /**
     * @en
     * The component of model.
     * When you place particles or models in the UI, you must add this component to render.
     * The component must be placed on a node with the [[MeshRenderer]] or the [[Particle]].
     *
     * @zh
     * UI 模型基础组件。
     * 当你在 UI 中放置模型或者粒子的时候，必须添加该组件才能渲染。该组件必须放置在带有 [[MeshRenderer]] 或者 [[Particle]] 组件的节点上。
     */
    export class UIMeshRenderer extends UIComponent {
        private _models;
        get modelComponent(): RenderableComponent | null;
        private _modelComponent;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        updateAssembler(render: UI): boolean;
        update(): void;
        private _fitUIRenderQueue;
    }
}
declare module "cocos/ui/components/widget" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/index";
    import { Size, Vec3 } from "cocos/core/math/index";
    import { Scene } from "cocos/core/scene-graph/index";
    import { Node } from "cocos/core/scene-graph/node";
    import { TransformBit } from "cocos/core/scene-graph/node-enum";
    export function getReadonlyNodeSize(parent: Node | Scene): Size | {
        topLeft: any;
        topRight: any;
        top: any;
        bottomLeft: any;
        bottomRight: any;
        bottom: any;
        center: any;
        left: any;
        right: any;
        width: number;
        height: number;
        init(visibleRect_: import("cocos/core/math").Rect): void;
    };
    export function computeInverseTransForTarget(widgetNode: Node, target: Node, out_inverseTranslate: Vec3, out_inverseScale: Vec3): void;
    /**
     * @en Enum for Widget's alignment mode, indicating when the widget should refresh.
     *
     * @zh Widget 的对齐模式，表示 Widget 应该何时刷新。
     */
    export enum AlignMode {
        /**
         * @en Only align once when the Widget is enabled for the first time.
         * This will allow the script or animation to continue controlling the current node.
         * It will only be aligned once before the end of frame when onEnable is called,then immediately disables the Widget.
         *
         * @zh 仅在 Widget 第一次激活时对齐一次，便于脚本或动画继续控制当前节点。<br/>
         * 开启后会在 onEnable 时所在的那一帧结束前对齐一次，然后立刻禁用该 Widget。
         */
        ONCE = 0,
        /**
         * @en Keep aligning all the way.
         *
         * @zh  始终保持对齐。
         */
        ALWAYS = 1,
        /**
         * @zh
         * 一开始会像 ONCE 一样对齐一次，之后每当窗口大小改变时还会重新对齐。
         */
        ON_WINDOW_RESIZE = 2
    }
    /**
     * @en Enum for Widget's alignment flag, indicating when the widget select alignment.
     *
     * @zh Widget 的对齐标志，表示 Widget 选择对齐状态。
     */
    export enum AlignFlags {
        /**
         * @en Align top.
         *
         * @zh 上边对齐。
         */
        TOP = 1,
        /**
         * @en Align middle.
         *
         * @zh 垂直中心对齐。
         */
        MID = 2,
        /**
         * @en Align bottom.
         *
         * @zh 下边对齐。
         */
        BOT = 4,
        /**
         * @en Align left.
         *
         * @zh 左边对齐。
         */
        LEFT = 8,
        /**
         * @en Align center.
         *
         * @zh 横向中心对齐。
         */
        CENTER = 16,
        /**
         * @en Align right.
         *
         * @zh 右边对齐。
         */
        RIGHT = 32,
        /**
         * @en Align horizontal.
         *
         * @zh 横向对齐。
         */
        HORIZONTAL = 56,
        /**
         * @en Align vertical.
         *
         * @zh 纵向对齐。
         */
        VERTICAL = 7
    }
    /**
     * @en
     * Stores and manipulate the anchoring based on its parent.
     * Widget are used for GUI but can also be used for other things.
     * Widget will adjust current node's position and size automatically,
     * but the results after adjustment can not be obtained until the next frame unless you call [[updateAlignment]] manually.
     *
     * @zh Widget 组件，用于设置和适配其相对于父节点的边距，Widget 通常被用于 UI 界面，也可以用于其他地方。<br/>
     * Widget 会自动调整当前节点的坐标和宽高，不过目前调整后的结果要到下一帧才能在脚本里获取到，除非你先手动调用 [[updateAlignment]]。
     */
    export class Widget extends Component {
        /**
         * @en
         * Specifies an alignment target that can only be one of the parent nodes of the current node.
         * The default value is null, and when null, indicates the current parent.
         *
         * @zh
         * 指定一个对齐目标，只能是当前节点的其中一个父节点，默认为空，为空时表示当前父节点。
         */
        get target(): Node | null;
        set target(value: Node | null);
        /**
         * @en
         * Whether to align to the top.
         *
         * @zh
         * 是否对齐上边。
         */
        get isAlignTop(): boolean;
        set isAlignTop(value: boolean);
        /**
         * @en
         * Whether to align to the bottom.
         *
         * @zh
         * 是否对齐下边。
         */
        get isAlignBottom(): boolean;
        set isAlignBottom(value: boolean);
        /**
         * @en
         * Whether to align to the left.
         *
         * @zh
         * 是否对齐左边。
         */
        get isAlignLeft(): boolean;
        set isAlignLeft(value: boolean);
        /**
         * @en
         * Whether to align to the right.
         *
         * @zh
         * 是否对齐右边。
         */
        get isAlignRight(): boolean;
        set isAlignRight(value: boolean);
        /**
         * @en
         * Whether to align vertically.
         *
         * @zh
         * 是否垂直方向对齐中点，开启此项会将垂直方向其他对齐选项取消。
         */
        get isAlignVerticalCenter(): boolean;
        set isAlignVerticalCenter(value: boolean);
        /**
         * @en
         * Whether to align horizontally.
         *
         * @zh
         * 是否水平方向对齐中点，开启此选项会将水平方向其他对齐选项取消。
         */
        get isAlignHorizontalCenter(): boolean;
        set isAlignHorizontalCenter(value: boolean);
        /**
         * @en
         * Whether to stretch horizontally, when enable the left and right alignment will be stretched horizontally,
         * the width setting is invalid (read only).
         *
         * @zh
         * 当前是否水平拉伸。当同时启用左右对齐时，节点将会被水平拉伸。此时节点的宽度（只读）。
         */
        get isStretchWidth(): boolean;
        /**
         * @en
         * Whether to stretch vertically, when enable the left and right alignment will be stretched vertically,
         * then height setting is invalid (read only).
         *
         * @zh
         * 当前是否垂直拉伸。当同时启用上下对齐时，节点将会被垂直拉伸，此时节点的高度（只读）。
         */
        get isStretchHeight(): boolean;
        /**
         * @en
         * The margins between the top of this node and the top of parent node,
         * the value can be negative, Only available in 'isAlignTop' open.
         *
         * @zh
         * 本节点顶边和父节点顶边的距离，可填写负值，只有在 isAlignTop 开启时才有作用。
         */
        get top(): number;
        set top(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorTop(): number;
        set editorTop(value: number);
        /**
         * @en
         * The margins between the bottom of this node and the bottom of parent node,
         * the value can be negative, Only available in 'isAlignBottom' open.
         *
         * @zh
         * 本节点底边和父节点底边的距离，可填写负值，只有在 isAlignBottom 开启时才有作用。
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorBottom(): number;
        set editorBottom(value: number);
        /**
         * @en
         * The margins between the left of this node and the left of parent node,
         * the value can be negative, Only available in 'isAlignLeft' open.
         *
         * @zh
         * 本节点左边和父节点左边的距离，可填写负值，只有在 isAlignLeft 开启时才有作用。
         */
        get left(): number;
        set left(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorLeft(): number;
        set editorLeft(value: number);
        /**
         * @en
         * The margins between the right of this node and the right of parent node,
         * the value can be negative, Only available in 'isAlignRight' open.
         *
         * @zh
         * 本节点右边和父节点右边的距离，可填写负值，只有在 isAlignRight 开启时才有作用。
         */
        get right(): number;
        set right(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorRight(): number;
        set editorRight(value: number);
        /**
         * @en
         * Horizontally aligns the midpoint offset value,
         * the value can be negative, Only available in 'isAlignHorizontalCenter' open.
         *
         * @zh
         * 水平居中的偏移值，可填写负值，只有在 isAlignHorizontalCenter 开启时才有作用。
         */
        get horizontalCenter(): number;
        set horizontalCenter(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorHorizontalCenter(): number;
        set editorHorizontalCenter(value: number);
        /**
         * @en
         * Vertically aligns the midpoint offset value,
         * the value can be negative, Only available in 'isAlignVerticalCenter' open.
         *
         * @zh
         * 垂直居中的偏移值，可填写负值，只有在 isAlignVerticalCenter 开启时才有作用。
         */
        get verticalCenter(): number;
        set verticalCenter(value: number);
        /**
         * @EditorOnly Not for user
         */
        get editorVerticalCenter(): number;
        set editorVerticalCenter(value: number);
        /**
         * @en
         * If true, top is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's height.
         *
         * @zh
         * 如果为 true，"top" 将会以像素作为边距，否则将会以相对父物体高度的比例（0 到 1）作为边距。
         */
        get isAbsoluteTop(): boolean;
        set isAbsoluteTop(value: boolean);
        /**
         * @en
         * If true, bottom is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's height.
         *
         * @zh
         * 如果为 true，"bottom" 将会以像素作为边距，否则将会以相对父物体高度的比例（0 到 1）作为边距。
         */
        get isAbsoluteBottom(): boolean;
        set isAbsoluteBottom(value: boolean);
        /**
         * @en
         * If true, left is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's width.
         *
         * @zh
         * 如果为 true，"left" 将会以像素作为边距，否则将会以相对父物体宽度的比例（0 到 1）作为边距。
         */
        get isAbsoluteLeft(): boolean;
        set isAbsoluteLeft(value: boolean);
        /**
         * @en
         * If true, right is pixel margin, otherwise is percentage (0 - 1) margin relative to the parent's width.
         *
         * @zh
         * 如果为 true，"right" 将会以像素作为边距，否则将会以相对父物体宽度的比例（0 到 1）作为边距。
         */
        get isAbsoluteRight(): boolean;
        set isAbsoluteRight(value: boolean);
        /**
         * @en
         * If true, horizontalCenter is pixel margin, otherwise is percentage (0 - 1) margin.
         *
         * @zh
         * 如果为 true，"horizontalCenter" 将会以像素作为偏移值，反之为比例（0 到 1）。
         */
        get isAbsoluteHorizontalCenter(): boolean;
        set isAbsoluteHorizontalCenter(value: boolean);
        /**
         * @en
         * If true, verticalCenter is pixel margin, otherwise is percentage (0 - 1) margin.
         *
         * @zh
         * 如果为 true，"verticalCenter" 将会以像素作为偏移值，反之为比例（0 到 1）。
         */
        get isAbsoluteVerticalCenter(): boolean;
        set isAbsoluteVerticalCenter(value: boolean);
        /**
         * @en
         * Specifies the alignment mode of the Widget, which determines when the widget should refresh.
         *
         * @zh
         * 指定 Widget 的对齐模式，用于决定 Widget 应该何时刷新。
         *
         * @example
         * ```
         * import { Widget } from 'cc';
         * widget.alignMode = Widget.AlignMode.ON_WINDOW_RESIZE;
         * ```
         */
        get alignMode(): AlignMode;
        set alignMode(value: AlignMode);
        /**
         * @zh
         * 对齐开关，由 AlignFlags 组成
         */
        get alignFlags(): number;
        set alignFlags(value: number);
        static AlignMode: typeof AlignMode;
        _lastPos: Vec3;
        _lastSize: Size;
        _dirty: boolean;
        private _alignFlags;
        private _target;
        private _left;
        private _right;
        private _top;
        private _bottom;
        private _horizontalCenter;
        private _verticalCenter;
        private _isAbsLeft;
        private _isAbsRight;
        private _isAbsTop;
        private _isAbsBottom;
        private _isAbsHorizontalCenter;
        private _isAbsVerticalCenter;
        private _originalWidth;
        private _originalHeight;
        private _alignMode;
        private _lockFlags;
        /**
         * @en
         * Immediately perform the widget alignment. You need to manually call this method only if
         * you need to get the latest results after the alignment before the end of current frame.
         *
         * @zh
         * 立刻执行 widget 对齐操作。这个接口一般不需要手工调用。
         * 只有当你需要在当前帧结束前获得 widget 对齐后的最新结果时才需要手动调用这个方法。
         *
         * @example
         * ```ts
         * import { log } from 'cc';
         * widget.top = 10;       // change top margin
         * log(widget.node.y); // not yet changed
         * widget.updateAlignment();
         * log(widget.node.y); // changed
         * ```
         */
        updateAlignment(): void;
        _validateTargetInDEV(): void;
        setDirty(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _adjustWidgetToAllowMovingInEditor(eventType: TransformBit): void;
        _adjustWidgetToAllowResizingInEditor(): void;
        _adjustWidgetToAnchorChanged(): void;
        _adjustTargetToParentChanged(oldParent: Node): void;
        protected _registerEvent(): void;
        protected _unregisterEvent(): void;
        protected _removeParentEvent(): void;
        protected _autoChangedValue(flag: AlignFlags, isAbs: boolean): void;
        protected _registerTargetEvents(): void;
        protected _unregisterTargetEvents(): void;
        protected _unregisterOldParentEvents(oldParent: Node): void;
        protected _targetChangedOperation(): void;
        private _setAlign;
        private _recursiveDirty;
    }
    export namespace Widget {
        type AlignMode = EnumAlias<typeof AlignMode>;
    }
}
declare module "cocos/ui/components/page-view-indicator" {
    /**
     * @category ui
     */
    import { SpriteFrame } from "cocos/core/assets/index";
    import { Component } from "cocos/core/components/index";
    import { Size } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    import { Layout } from "cocos/ui/components/layout";
    import { PageView } from "cocos/ui/components/page-view";
    /**
     * @en Enum for PageView Indicator direction.
     *
     * @zh 页面视图指示器的摆放方向
     *
     * @enum PageViewIndicator.Direction
     */
    enum Direction {
        /**
         * @en The horizontal direction.
         *
         * @zh 水平方向
         */
        HORIZONTAL = 0,
        /**
         * @en The vertical direction.
         *
         * @zh 垂直方向
         */
        VERTICAL = 1
    }
    /**
     * @en
     * The Page View Indicator Component.
     *
     * @zh
     * 页面视图每页标记组件
     */
    export class PageViewIndicator extends Component {
        /**
         * @en
         * The spriteFrame for each element.
         *
         * @zh
         * 每个页面标记显示的图片
         */
        get spriteFrame(): SpriteFrame | null;
        set spriteFrame(value: SpriteFrame | null);
        /**
         * @en
         * The location direction of PageViewIndicator.
         *
         * @zh
         * 页面标记摆放方向
         *
         * @param direction 摆放方向
         */
        get direction(): Direction;
        set direction(value: Direction);
        /**
         * @en
         * The cellSize for each element.
         *
         * @zh
         * 每个页面标记的大小
         */
        get cellSize(): Size;
        set cellSize(value: Size);
        static Direction: typeof Direction;
        /**
         * @en
         * The distance between each element.
         *
         * @zh
         * 每个页面标记之间的边距
         */
        spacing: number;
        protected _spriteFrame: SpriteFrame | null;
        protected _direction: Direction;
        protected _cellSize: Size;
        protected _layout: Layout | null;
        protected _pageView: PageView | null;
        protected _indicators: Node[];
        onLoad(): void;
        /**
         * @en
         * Set Page View.
         *
         * @zh
         * 设置页面视图
         *
         * @param target 页面视图对象
         */
        setPageView(target: PageView): void;
        _updateLayout(): void;
        _createIndicator(): Node;
        _changedState(): void;
        _refresh(): void;
    }
}
declare module "cocos/ui/components/page-view" {
    /**
     * @category ui
     */
    import { EventHandler as ComponentEventHandler } from "cocos/core/components/index";
    import { EventTouch } from "cocos/core/platform/index";
    import { Vec3 } from "cocos/core/math/index";
    import { PageViewIndicator } from "cocos/ui/components/page-view-indicator";
    import { ScrollView } from "cocos/ui/components/scroll-view";
    import { ScrollBar } from "cocos/ui/components/scroll-bar";
    import { EventType as ScrollEventType } from "cocos/ui/components/scroll-view";
    import { Node } from "cocos/core/index";
    /**
     * @en Enum for Page View Size Mode.
     *
     * @zh 页面视图每个页面统一的大小类型
     */
    enum SizeMode {
        /**
         * @en Each page is unified in size
         * @zh 每个页面统一大小
         */
        Unified = 0,
        /**
         * @en Each page is in free size
         * @zh 每个页面大小随意
         */
        Free = 1
    }
    /**
     * @en Enum for Page View Direction.
     *
     * @zh 页面视图滚动类型
     */
    enum Direction {
        /**
         * @en Horizontal scroll.
         * @zh 水平滚动
         */
        Horizontal = 0,
        /**
         * @en Vertical scroll.
         * @zh 垂直滚动
         */
        Vertical = 1
    }
    /**
     * @en Enum for ScrollView event type.
     *
     * @zh 滚动视图事件类型
     */
    enum EventType {
        PAGE_TURNING = "page-turning"
    }
    /**
     * @en
     * The PageView control.
     *
     * @zh
     * 页面视图组件
     */
    export class PageView extends ScrollView {
        /**
         * @en
         * Specify the size type of each page in PageView.
         *
         * @zh
         * 页面视图中每个页面大小类型
         */
        get sizeMode(): SizeMode;
        set sizeMode(value: SizeMode);
        /**
         * @en
         * The page view direction.
         *
         * @zh
         * 页面视图滚动类型
         */
        get direction(): Direction;
        set direction(value: Direction);
        /**
         * @en
         * The scroll threshold value, when drag exceeds this value,
         * release the next page will automatically scroll, less than the restore.
         *
         * @zh
         * 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原。
         */
        get scrollThreshold(): number;
        set scrollThreshold(value: number);
        /**
         * @en
         * Change the PageTurning event timing of PageView.
         *
         * @zh
         * 设置 PageView PageTurning 事件的发送时机。
         */
        get pageTurningEventTiming(): number;
        set pageTurningEventTiming(value: number);
        /**
         * @en
         * The Page View Indicator.
         *
         * @zh
         * 页面视图指示器组件
         */
        get indicator(): PageViewIndicator | null;
        set indicator(value: PageViewIndicator | null);
        get curPageIdx(): number;
        static SizeMode: typeof SizeMode;
        static Direction: typeof Direction;
        static EventType: typeof EventType & typeof ScrollEventType;
        /**
         * @en
         * Auto page turning velocity threshold. When users swipe the PageView quickly,
         * it will calculate a velocity based on the scroll distance and time,
         * if the calculated velocity is larger than the threshold, then it will trigger page turning.
         *
         * @zh
         * 快速滑动翻页临界值。
         * 当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，
         * 该值与此临界值相比较，如果大于临界值，则进行自动翻页。
         */
        autoPageTurningThreshold: number;
        get verticalScrollBar(): ScrollBar | null;
        set verticalScrollBar(value: ScrollBar | null);
        get horizontalScrollBar(): ScrollBar | null;
        set horizontalScrollBar(value: ScrollBar | null);
        horizontal: boolean;
        vertical: boolean;
        cancelInnerEvents: boolean;
        scrollEvents: ComponentEventHandler[];
        /**
         * @en The time required to turn over a page. unit: second
         * @zh 每个页面翻页时所需时间。单位：秒
         */
        pageTurningSpeed: number;
        /**
         * @en PageView events callback
         * @zh 滚动视图的事件回调函数
         */
        pageEvents: ComponentEventHandler[];
        protected _sizeMode: SizeMode;
        protected _direction: Direction;
        protected _scrollThreshold: number;
        protected _pageTurningEventTiming: number;
        protected _indicator: PageViewIndicator | null;
        protected _curPageIdx: number;
        protected _lastPageIdx: number;
        protected _pages: Node[];
        protected _initContentPos: Vec3;
        protected _scrollCenterOffsetX: number[];
        protected _scrollCenterOffsetY: number[];
        protected _touchBeganPosition: Vec3;
        protected _touchEndPosition: Vec3;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onLoad(): void;
        onDestroy(): void;
        /**
         * @en
         * Returns current page index.
         *
         * @zh
         * 返回当前页面索引。
         *
         * @returns 当前页面索引。
         */
        getCurrentPageIndex(): number;
        /**
         * @en
         * Set current page index.
         *
         * @zh
         * 设置当前页面索引。
         * @param index 索引。
         */
        setCurrentPageIndex(index: number): void;
        /**
         * @en
         * Returns all pages of pageview.
         *
         * @zh
         * 返回视图中的所有页面。
         *
         * @returns 输=视图所有页面。
         */
        getPages(): Node[];
        /**
         * @en
         * At the end of the current page view to insert a new view.
         *
         * @zh
         * 在当前页面视图的尾部插入一个新视图。
         *
         * @param page 新视图。
         */
        addPage(page: Node): void;
        /**
         * @en
         * Inserts a page in the specified location.
         *
         * @zh
         * 将页面插入指定位置中。
         *
         * @param page 新视图。
         * @param index 指定位置。
         */
        insertPage(page: Node, index: number): void;
        /**
         * @en
         * Removes a page from PageView.
         *
         * @zh
         * 移除指定页面。
         *
         * @param page 指定页面。
         */
        removePage(page: Node): void;
        /**
         * @en
         * Removes a page at index of PageView.
         *
         * @zh
         * 移除指定下标的页面。
         *
         * @param index 页面下标。
         */
        removePageAtIndex(index: number): void;
        /**
         * @en
         * Removes all pages from PageView.
         *
         * @zh
         * 移除所有页面。
         */
        removeAllPages(): void;
        /**
         * @en
         * Scroll PageView to index.
         *
         * @zh
         * 滚动到指定页面
         *
         * @param idx index of page.
         * @param timeInSecond scrolling time.
         */
        scrollToPage(idx: number, timeInSecond?: number): void;
        getScrollEndedEventTiming(): number;
        protected _updatePageView(): void;
        protected _updateAllPagesSize(): void;
        protected _handleReleaseLogic(): void;
        protected _onTouchBegan(event: EventTouch, captureListeners: any): void;
        protected _onTouchMoved(event: EventTouch, captureListeners: any): void;
        protected _onTouchEnded(event: EventTouch, captureListeners: any): void;
        protected _onTouchCancelled(event: EventTouch, captureListeners: any): void;
        protected _onMouseWheel(): void;
        protected _syncScrollDirection(): void;
        protected _syncSizeMode(): void;
        protected _initPages(): void;
        protected _dispatchPageTurningEvent(): void;
        protected _isQuicklyScrollable(touchMoveVelocity: Vec3): boolean;
        protected _moveOffsetValue(idx: number): Vec3;
        protected _getDragDirection(moveOffset: Vec3): 1 | 0 | -1;
        protected _isScrollable(offset: Vec3, index: number, nextIndex: number): boolean | undefined;
        protected _autoScrollToPage(): void;
    }
}
declare module "cocos/core/renderer/ui/mesh-buffer" {
    /**
     * @category ui
     */
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { InputAssemblerHandle } from "cocos/core/renderer/core/memory-pools";
    export class MeshBuffer {
        static OPACITY_OFFSET: number;
        vData: Float32Array | null;
        iData: Uint16Array | null;
        attributes: IGFXAttribute[];
        vertexBuffers: GFXBuffer[];
        indexBuffer: GFXBuffer;
        byteStart: number;
        byteOffset: number;
        indicesStart: number;
        indicesOffset: number;
        vertexStart: number;
        vertexOffset: number;
        lastByteOffset: number;
        private _batcher;
        private _dirty;
        private _vertexFormatBytes;
        private _initVDataCount;
        private _initIDataCount;
        private _outOfCallback;
        private _hInputAssemblers;
        private _nextFreeIAHandle;
        constructor(batcher: UI);
        initialize(attrs: IGFXAttribute[], outOfCallback: ((...args: number[]) => void) | null): void;
        request(vertexCount?: number, indicesCount?: number): boolean;
        reset(): void;
        destroy(): void;
        recordBatch(): InputAssemblerHandle;
        uploadData(): void;
        private _reallocBuffer;
        private _reallocVData;
        private _reallocIData;
    }
}
declare module "cocos/core/renderer/ui/ui-draw-batch" {
    /**
     * @hidden
     */
    import { MeshBuffer } from "cocos/ui/index";
    import { Material } from "cocos/core/assets/material";
    import { GFXTexture, GFXSampler } from "cocos/core/gfx/index";
    import { Node } from "cocos/core/scene-graph/index";
    import { Camera } from "cocos/core/renderer/scene/camera";
    import { Model } from "cocos/core/renderer/scene/model";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { InputAssemblerHandle, DescriptorSetHandle } from "cocos/core/renderer/core/memory-pools";
    export class UIDrawBatch {
        bufferBatch: MeshBuffer | null;
        camera: Camera | null;
        model: Model | null;
        material: Material | null;
        texture: GFXTexture | null;
        sampler: GFXSampler | null;
        hInputAssembler: InputAssemblerHandle;
        hDescriptorSet: DescriptorSetHandle;
        useLocalData: Node | null;
        isStatic: boolean;
        constructor();
        destroy(ui: UI): void;
        clear(): void;
    }
}
declare module "cocos/core/renderer/ui/ui-vertex-format" {
    /**
     * @category ui
     */
    import { GFXAttributeName, GFXFormat } from "cocos/core/gfx/define";
    export const vfmt: {
        name: GFXAttributeName;
        format: GFXFormat;
    }[];
}
declare module "cocos/ui/components/ui-static-batch" {
    /**
     * @category ui
     */
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { MeshBuffer } from "cocos/core/renderer/ui/mesh-buffer";
    import { UIDrawBatch } from "cocos/core/renderer/ui/ui-draw-batch";
    import { Color, Material } from "cocos/core/index";
    import { GFXBlendFactor } from "cocos/core/gfx/index";
    /**
     * @en
     * Static batch component of UI.
     * This component is placed on the root node of all node objects that need to be batch.
     * Only sprites and label participate in the batch.
     * Static batch must be enabled manually, otherwise dynamic batch is still used.
     * Note: Do not place mask, Graphics, and objects such as UI models or particles under child nodes,
     * otherwise rendering will be skipped after static batching is enabled.
     *
     * @zh
     * UI 静态合批组件。
     * 该组件放在所有需要被静态合批的节点对象的根节点上，子节点放置对象必须是精灵和文本，其余对象不参与静态合批。
     * 用户必须通过手动方式启用收集静态合批数据[[markAsDirty]]，否则合批方式仍然采用动态合批（采集数据的流程相同）。此后渲染的内容是采用收集到的合批渲染数据，子节点的任何修改将不再有效。
     * 注意：子节点下不要放置 Mask，Graphics，以及 UI 模型或者粒子之类对象，否则会在启用完静态合批后跳过渲染。
     */
    export class UIStaticBatch extends UIRenderable {
        get dstBlendFactor(): GFXBlendFactor;
        set dstBlendFactor(value: GFXBlendFactor);
        get srcBlendFactor(): GFXBlendFactor;
        set srcBlendFactor(value: GFXBlendFactor);
        get color(): Readonly<Color>;
        set color(value: Readonly<Color>);
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        get drawBatchList(): UIDrawBatch[];
        protected _init: boolean;
        protected _meshBuffer: MeshBuffer | null;
        protected _dirty: boolean;
        private _lastMeshBuffer;
        private _uiDrawBatchList;
        onLoad(): void;
        onDestroy(): void;
        updateAssembler(render: UI): void;
        postUpdateAssembler(render: UI): void;
        /**
         * @en
         * Recollect data tags.
         * The render data will be recollected during the render phase of the current frame, and the next frame will be rendered using fixed data.
         * Note: 尽量不要频繁调用此接口, 会有一定内存损耗.
         *
         * @zh
         * 重新采集数据标记，会在当前帧的渲染阶段重新采集渲染数据，下一帧开始将会使用固定数据进行渲染。
         * 注意：尽量不要频繁调用此接口，因为会清空原先存储的 ia 数据重新采集，会有一定内存损耗。
         */
        markAsDirty(): void;
        _requireDrawBatch(): UIDrawBatch;
        protected _clearData(): void;
        protected _getUI(): UI | null;
        protected _arrivalMaxBuffer(): void;
    }
}
declare module "cocos/ui/components/ui-opacity" {
    /**
     * @category ui
     */
    import { Component } from "cocos/core/components/component";
    /**
     * @en
     * Set the UI transparency component.
     * This component can be used to influence subsequent render nodes.
     * Nodes that already have a rendering component can modify the alpha channel of color directly.
     *
     * @zh
     * UI 透明度设置组件。可以通过该组件设置透明度来影响后续的渲染节点。已经带有渲染组件的节点可以直接修改 color 的 alpha 通道。
     */
    export class UIOpacity extends Component {
        /**
         * @en
         * The transparency value of the impact.
         *
         * @zh
         * 透明度。
         */
        get opacity(): number;
        set opacity(value: number);
        protected _opacity: number;
        onEnable(): void;
        onDisable(): void;
    }
}
declare module "cocos/ui/components/safe-area" {
    import { Component } from "cocos/core/components/index";
    /**
     * @en
     * This component is used to adjust the layout of current node to respect the safe area of a notched mobile device such as the iPhone X.
     * It is typically used for the top node of the UI interaction area. For specific usage, refer to the official [test-cases-3d/assets/cases/ui/20.safe-area/safe-area.scene](https://github.com/cocos-creator/test-cases-3d).
     *
     * The concept of safe area is to give you a fixed inner rectangle in which you can safely display content that will be drawn on screen.
     * You are strongly discouraged from providing controls outside of this area. But your screen background could embellish edges.
     *
     * This component internally uses the API `sys.getSafeAreaRect();` to obtain the safe area of the current iOS or Android device,
     * and implements the adaptation by using the Widget component and set anchor.
     *
     * @zh
     * 该组件会将所在节点的布局适配到 iPhone X 等异形屏手机的安全区域内，通常用于 UI 交互区域的顶层节点，具体用法可参考官方范例 [test-cases-3d/assets/cases/ui/20.safe-area/safe-area.scene](https://github.com/cocos-creator/test-cases-3d)。
     *
     * 该组件内部通过 API `sys.getSafeAreaRect();` 获取到当前 iOS 或 Android 设备的安全区域，并通过 Widget 组件实现适配。
     *
     */
    export class SafeArea extends Component {
        onEnable(): void;
        onDisable(): void;
        /**
         * @en Adapt to safe area
         * @zh 立即适配安全区域
         * @method updateArea
         * @example
         * let safeArea = this.node.addComponent(cc.SafeArea);
         * safeArea.updateArea();
         */
        updateArea(): void;
    }
}
declare module "cocos/core/animation/bound-target" {
    import { IValueProxyFactory } from "cocos/core/animation/value-proxy";
    import { TargetPath } from "cocos/core/animation/target-path";
    export interface IBoundTarget {
        setValue(value: any): void;
        getValue(): any;
    }
    export interface IBufferedTarget extends IBoundTarget {
        peek(): any;
        pull(): void;
        push(): void;
    }
    export function createBoundTarget(target: any, modifiers: TargetPath[], valueAdapter?: IValueProxyFactory): null | IBoundTarget;
    export function createBufferedTarget(target: any, modifiers: TargetPath[], valueAdapter?: IValueProxyFactory): null | IBufferedTarget;
}
declare module "cocos/core/animation/playable" {
    export class Playable {
        /**
         * @en Whether if this `Playable` is in playing.
         * @zh 该 `Playable` 是否正在播放状态。
         * @default false
         */
        get isPlaying(): boolean;
        /**
         * @en Whether if this `Playable` has been paused. This can be true even if in edit mode(isPlaying == false).
         * @zh 该 `Playable` 是否已被暂停。
         * @default false
         */
        get isPaused(): boolean;
        /**
         * @en Whether if this `Playable` has been paused or stopped.
         * @zh 该 `Playable` 是否已被暂停或停止。
         */
        get isMotionless(): boolean;
        private _isPlaying;
        private _isPaused;
        private _stepOnce;
        /**
         * @en Play this animation.
         * @zh 播放动画。
         */
        play(): void;
        /**
         * @en Stop this animation.
         * @zh 停止动画播放。
         */
        stop(): void;
        /**
         * @en Pause this animation.
         * @zh 暂停动画。
         */
        pause(): void;
        /**
         * @en Resume this animation.
         * @zh 重新播放动画。
         */
        resume(): void;
        /**
         * @en Perform a single frame step.
         * @zh 执行一帧动画。
         */
        step(): void;
        update(deltaTime: number): void;
        protected onPlay(): void;
        protected onPause(): void;
        protected onResume(): void;
        protected onStop(): void;
        protected onError(message: string): void;
    }
}
declare module "cocos/core/animation/skeletal-animation-blending" {
    /**
     * @hidden
     */
    import { Vec3, Quat } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    import { IValueProxyFactory } from "cocos/core/animation/value-proxy";
    export class BlendStateBuffer {
        private _nodeBlendStates;
        ref(node: Node, property: BlendingProperty): PropertyBlendState<Vec3> | PropertyBlendState<Quat>;
        deRef(node: Node, property: BlendingProperty): void;
        apply(): void;
    }
    export type IBlendStateWriter = IValueProxyFactory & {
        destroy: () => void;
    };
    export function createBlendStateWriter<P extends BlendingProperty>(blendState: BlendStateBuffer, node: Node, property: P, weightProxy: {
        weight: number;
    }, // Effectively equals to AnimationState
    /**
     * True if this writer will write constant value each time.
     */
    constants: boolean): IBlendStateWriter;
    type BlendingProperty = keyof NodeBlendState['properties'];
    class PropertyBlendState<T> {
        weight: number;
        value: T;
        /**
         * How many writer reference this property.
         */
        refCount: number;
        private _node;
        constructor(node: NodeBlendState, value: T);
        markAsDirty(): void;
    }
    interface NodeBlendState {
        dirty: boolean;
        properties: {
            position?: PropertyBlendState<Vec3>;
            rotation?: PropertyBlendState<Quat>;
            eulerAngles?: PropertyBlendState<Vec3>;
            scale?: PropertyBlendState<Vec3>;
        };
    }
}
declare module "cocos/core/animation/animation-state" {
    /**
     * @category animation
     */
    import { Node } from "cocos/core/scene-graph/node";
    import { AnimationClip, IRuntimeCurve } from "cocos/core/animation/animation-clip";
    import { RatioSampler } from "cocos/core/animation/animation-curve";
    import { IBufferedTarget, IBoundTarget } from "cocos/core/animation/bound-target";
    import { Playable } from "cocos/core/animation/playable";
    import { WrapMode, WrappedInfo } from "cocos/core/animation/types";
    /**
     * @en The event type supported by Animation
     * @zh Animation 支持的事件类型。
     */
    export enum EventType {
        /**
         * @en Emit when begin playing animation
         * @zh 开始播放时触发。
         */
        PLAY = "play",
        /**
         * @en Emit when stop playing animation
         * @zh 停止播放时触发。
         */
        STOP = "stop",
        /**
         * @en Emit when pause animation
         * @zh 暂停播放时触发。
         */
        PAUSE = "pause",
        /**
         * @en Emit when resume animation
         * @zh 恢复播放时触发。
         */
        RESUME = "resume",
        /**
         * @en If animation repeat count is larger than 1, emit when animation play to the last frame.
         * @zh 假如动画循环次数大于 1，当动画播放到最后一帧时触发。
         */
        LASTFRAME = "lastframe",
        /**
         * @en Triggered when finish playing animation.
         * @zh 动画完成播放时触发。
         */
        FINISHED = "finished"
    }
    export class ICurveInstance {
        commonTargetIndex?: number;
        private _curve;
        private _boundTarget;
        private _rootTargetProperty?;
        private _curveDetail;
        constructor(runtimeCurve: Omit<IRuntimeCurve, 'sampler'>, target: any, boundTarget: IBoundTarget);
        applySample(ratio: number, index: number, lerpRequired: boolean, samplerResultCache: any, weight: number): void;
        private _setValue;
        get propertyName(): string;
        get curveDetail(): Pick<IRuntimeCurve, "modifiers" | "valueAdapter" | "commonTarget" | "curve">;
    }
    /**
     * The curves in ISamplerSharedGroup share a same keys.
     */
    interface ISamplerSharedGroup {
        sampler: RatioSampler | null;
        curves: ICurveInstance[];
        samplerResultCache: {
            from: number;
            fromRatio: number;
            to: number;
            toRatio: number;
        };
    }
    /**
     * @en
     * The AnimationState gives full control over animation playback process.
     * In most cases the Animation Component is sufficient and easier to use. Use the AnimationState if you need full control.
     * @zh
     * AnimationState 完全控制动画播放过程。<br/>
     * 大多数情况下 动画组件 是足够和易于使用的。如果您需要更多的动画控制接口，请使用 AnimationState。
     *
     */
    export class AnimationState extends Playable {
        /**
         * @en The clip that is being played by this animation state.
         * @zh 此动画状态正在播放的剪辑。
         */
        get clip(): AnimationClip;
        /**
         * @en The name of the playing animation.
         * @zh 动画的名字。
         */
        get name(): string;
        get length(): number;
        /**
         * @en
         * Wrapping mode of the playing animation.
         * Notice : dynamic change wrapMode will reset time and repeatCount property
         * @zh
         * 动画循环方式。
         * 需要注意的是，动态修改 wrapMode 时，会重置 time 以及 repeatCount。
         * @default: WrapMode.Normal
         */
        get wrapMode(): WrapMode;
        set wrapMode(value: WrapMode);
        /**
         * @en The animation's iteration count property.
         *
         * A real number greater than or equal to zero (including positive infinity) representing the number of times
         * to repeat the animation node.
         *
         * Values less than zero and NaN values are treated as the value 1.0 for the purpose of timing model
         * calculations.
         *
         * @zh 迭代次数，指动画播放多少次后结束, normalize time。 如 2.5（2次半）。
         *
         * @default 1
         */
        get repeatCount(): number;
        set repeatCount(value: number);
        /**
         * @en The start delay which represents the number of seconds from an animation's start time to the start of
         * the active interval.
         * @zh 延迟多少秒播放。
         * @default 0
         */
        get delay(): number;
        set delay(value: number);
        /**
         * @en The iteration duration of this animation in seconds. (length)
         * @zh 单次动画的持续时间，秒。（动画长度）
         * @readOnly
         */
        duration: number;
        /**
         * @en The animation's playback speed. 1 is normal playback speed.
         * @zh 播放速率。
         * @default: 1.0
         */
        speed: number;
        /**
         * @en The current time of this animation in seconds.
         * @zh 动画当前的时间，秒。
         * @default 0
         */
        time: number;
        /**
         * The weight.
         */
        weight: number;
        frameRate: number;
        protected _wrapMode: WrapMode;
        protected _repeatCount: number;
        /**
         * Mark whether the current frame is played.
         * When set new time to animation state, we should ensure the frame at the specified time being played at next update.
         */
        protected _currentFramePlayed: boolean;
        protected _delay: number;
        protected _delayTime: number;
        protected _wrappedInfo: WrappedInfo;
        protected _lastWrapInfo: WrappedInfo | null;
        protected _lastWrapInfoEvent: WrappedInfo | null;
        protected _process: () => void;
        protected _target: Node | null;
        protected _targetNode: Node | null;
        protected _clip: AnimationClip;
        protected _name: string;
        protected _lastIterations?: number;
        protected _samplerSharedGroups: ISamplerSharedGroup[];
        /**
         * May be `null` due to failed to initialize.
         */
        protected _commonTargetStatuses: (null | {
            target: IBufferedTarget;
            changed: boolean;
        })[];
        protected _curveLoaded: boolean;
        protected _ignoreIndex: number;
        private _blendStateBuffer;
        private _blendStateWriters;
        private _allowLastFrame;
        constructor(clip: AnimationClip, name?: string);
        get curveLoaded(): boolean;
        initialize(root: Node, propertyCurves?: readonly IRuntimeCurve[]): void;
        destroy(): void;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        emit(...args: any[]): void;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        on(type: string, callback: Function, target?: any): void | null;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        once(type: string, callback: Function, target?: any): void | null;
        /**
         * @deprecated Since V1.1.1, animation states were no longer defined as event targets.
         * To process animation events, use `Animation` instead.
         */
        off(type: string, callback: Function, target?: any): void;
        /**
         * @zh
         * 是否允许触发 `LastFrame` 事件。
         * @en
         * Whether `LastFrame` should be triggered.
         * @param allowed True if the last frame events may be triggered.
         */
        allowLastFrameEvent(allowed: boolean): void;
        _setEventTarget(target: any): void;
        setTime(time: number): void;
        update(delta: number): void;
        _needReverse(currentIterations: number): boolean;
        getWrappedInfo(time: number, info?: WrappedInfo): WrappedInfo;
        sample(): WrappedInfo;
        process(): void;
        simpleProcess(): void;
        cache(frames: number): void;
        protected onPlay(): void;
        protected onStop(): void;
        protected onResume(): void;
        protected onPause(): void;
        protected _sampleCurves(ratio: number): void;
        private _sampleEvents;
        private _emit;
        private _fireEvent;
        private _onReplayOrResume;
        private _onPauseOrStop;
        private _destroyBlendStateWriters;
    }
}
declare module "cocos/core/animation/cross-fade" {
    import { AnimationState } from "cocos/core/animation/animation-state";
    import { Playable } from "cocos/core/animation/playable";
    export class CrossFade extends Playable {
        private readonly _managedStates;
        private readonly _fadings;
        constructor();
        update(deltaTime: number): void;
        /**
         * 在指定时间内将从当前动画状态切换到指定的动画状态。
         * @param state 指定的动画状态。
         * @param duration 切换时间。
         */
        crossFade(state: AnimationState | null, duration: number): void;
        clear(): void;
        protected onPlay(): void;
        /**
         * 停止我们淡入淡出的所有动画状态并停止淡入淡出。
         */
        protected onPause(): void;
        /**
         * 恢复我们淡入淡出的所有动画状态并继续淡入淡出。
         */
        protected onResume(): void;
        /**
         * 停止所有淡入淡出的动画状态。
         */
        protected onStop(): void;
    }
}
declare module "cocos/core/animation/animation-component" {
    /**
     * @category animation
     */
    import { Component } from "cocos/core/components/component";
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { AnimationState, EventType } from "cocos/core/animation/animation-state";
    import { CrossFade } from "cocos/core/animation/cross-fade";
    const Animation_base: new (...args: any[]) => Component & import("cocos/core/event/eventify").IEventified;
    /**
     * @en
     * Animation component governs a group of animation states to control playback of the states.
     * For convenient, it stores a group of animation clips.
     * Each of those clips would have an associated animation state uniquely created.
     * Animation component is eventful, it dispatch a serials playback status events.
     * See [[EventType]].
     * @zh
     * 动画组件管理一组动画状态，控制它们的播放。
     * 为了方便，动画组件还存储了一组动画剪辑。
     * 每个剪辑都会独自创建一个关联的动画状态对象。
     * 动画组件具有事件特性，它会派发一系列播放状态相关的事件。
     * 参考 [[EventType]]
     */
    export class Animation extends Animation_base {
        /**
         * @en
         * Gets or sets clips this component governs.
         * When set, associated animation state of each existing clip will be stopped.
         * If the existing default clip is not in the set of new clips, default clip will be reset to null.
         * @zh
         * 获取或设置此组件管理的剪辑。
         * 设置时，已有剪辑关联的动画状态将被停止；若默认剪辑不在新的动画剪辑中，将被重置为空。
         */
        get clips(): (AnimationClip | null)[];
        set clips(value: (AnimationClip | null)[]);
        /**
         * @en
         * Gets or sets the default clip.
         * @en
         * 获取或设置默认剪辑。
         * 设置时，若指定的剪辑不在 `this.clips` 中则会被自动添加至 `this.clips`。
         * @see [[playOnLoad]]
         */
        get defaultClip(): AnimationClip | null;
        set defaultClip(value: AnimationClip | null);
        static EventType: typeof EventType;
        /**
         * @en
         * Whether the default clip should get into playing when this components starts.
         * Note, this field takes no effect if `crossFade()` or `play()` has been called before this component starts.
         * @zh
         * 是否在组件开始运行时自动播放默认剪辑。
         * 注意，若在组件开始运行前调用了 `crossFade` 或 `play()`，此字段将不会生效。
         */
        playOnLoad: boolean;
        protected _crossFade: CrossFade;
        protected _nameToState: Record<string, AnimationState>;
        protected _clips: (AnimationClip | null)[];
        protected _defaultClip: AnimationClip | null;
        /**
         * Whether if `crossFade()` or `play()` has been called before this component starts.
         */
        private _hasBeenPlayed;
        onLoad(): void;
        start(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Switch to play specified animation state, without fading.
         * @zh
         * 立即切换到指定动画状态。
         * @param name The name of the animation to be played, if absent, the default clip will be played
         */
        play(name?: string): void;
        /**
         * @en
         * Smoothly switch to play specified animation state.
         * @zn
         * 平滑地切换到指定动画状态。
         * @param name The name of the animation to switch to
         * @param duration The duration of the cross fade, default value is 0.3s
         */
        crossFade(name: string, duration?: number): void;
        /**
         * @en
         * Pause all animation states and all switching.
         * @zh
         * 暂停所有动画状态，并暂停所有切换。
         */
        pause(): void;
        /**
         * @en
         * Resume all animation states and all switching.
         * @zh
         * 恢复所有动画状态，并恢复所有切换。
         */
        resume(): void;
        /**
         * @en
         * Stop all animation states and all switching.
         * @zh
         * 停止所有动画状态，并停止所有切换。
         */
        stop(): void;
        /**
         * @en
         * Get specified animation state.
         * @zh
         * 获取指定的动画状态。
         * @deprecated please use [[getState]]
         */
        getAnimationState(name: string): AnimationState;
        /**
         * @en
         * Get specified animation state.
         * @zh
         * 获取指定的动画状态。
         * @param name The name of the animation
         * @returns If no animation found, return null, otherwise the correspond animation state is returned
         */
        getState(name: string): AnimationState;
        /**
         * @en
         * Creates a state for specified clip.
         * If there is already a clip with same name, the existing animation state will be stopped and overridden.
         * @zh
         * 使用指定的动画剪辑创建一个动画状态。
         * 若指定名称的动画状态已存在，已存在的动画状态将先被设为停止并被覆盖。
         * @param clip The animation clip
         * @param name The animation state name, if absent, the default clip's name will be used
         * @returns The animation state created
         */
        createState(clip: AnimationClip, name?: string): AnimationState;
        /**
         * @en
         * Stops and removes specified clip.
         * @zh
         * 停止并移除指定的动画状态。
         * @param name The name of the animation state
         */
        removeState(name: string): void;
        /**
         * 添加一个动画剪辑到 `this.clips`中并以此剪辑创建动画状态。
         * @deprecated please use [[createState]]
         * @param clip The animation clip
         * @param name The animation state name, if absent, the default clip's name will be used
         * @returns The created animation state
         */
        addClip(clip: AnimationClip, name?: string): AnimationState;
        /**
         * @en
         * Remove clip from the animation list. This will remove the clip and any animation states based on it.<br>
         * If there are animation states depend on the clip are playing or clip is defaultClip, it will not delete the clip.<br>
         * But if force is true, then will always remove the clip and any animation states based on it. If clip is defaultClip, defaultClip will be reset to null
         * @zh
         * 从动画列表中移除指定的动画剪辑，<br/>
         * 如果依赖于 clip 的 AnimationState 正在播放或者 clip 是 defaultClip 的话，默认是不会删除 clip 的。<br/>
         * 但是如果 force 参数为 true，则会强制停止该动画，然后移除该动画剪辑和相关的动画。这时候如果 clip 是 defaultClip，defaultClip 将会被重置为 null。<br/>
         * @deprecated please use [[removeState]]
         * @param force - If force is true, then will always remove the clip and any animation states based on it.
         */
        removeClip(clip: AnimationClip, force?: boolean): void;
        /**
         * @en
         * Register animation event callback.<bg>
         * The event arguments will provide the AnimationState which emit the event.<bg>
         * When play an animation, will auto register the event callback to the AnimationState,<bg>
         * and unregister the event callback from the AnimationState when animation stopped.
         * @zh
         * 注册动画事件回调。<bg>
         * 回调的事件里将会附上发送事件的 AnimationState。<bg>
         * 当播放一个动画时，会自动将事件注册到对应的 AnimationState 上，停止播放时会将事件从这个 AnimationState 上取消注册。
         * @param type The event type to listen to
         * @param callback The callback when event triggered
         * @param target The callee when invoke the callback, could be absent
         * @return The registered callback
         * @example
         * ```ts
         * onPlay: function (type, state) {
         *     // callback
         * }
         *
         * // register event to all animation
         * animation.on('play', this.onPlay, this);
         * ```
         */
        on<TFunction extends Function>(type: EventType, callback: TFunction, thisArg?: any, once?: boolean): TFunction;
        once<TFunction extends Function>(type: EventType, callback: TFunction, thisArg?: any): TFunction;
        /**
         * @en
         * Unregister animation event callback.
         * @zh
         * 取消注册动画事件回调。
         * @param {String} type The event type to unregister
         * @param {Function} callback The callback to unregister
         * @param {Object} target The callee of the callback, could be absent
         * @example
         * ```ts
         * // unregister event to all animation
         * animation.off('play', this.onPlay, this);
         * ```
         */
        off(type: EventType, callback?: Function, thisArg?: any): void;
        protected _createState(clip: AnimationClip, name?: string): AnimationState;
        protected _doCreateState(clip: AnimationClip, name: string): AnimationState;
        private _getStateByNameOrDefaultClip;
        private _removeStateOfAutomaticClip;
        private _syncAllowLastFrameEvent;
        private _syncDisallowLastFrameEvent;
    }
    export namespace Animation {
        type EventType = EnumAlias<typeof EventType>;
    }
}
declare module "cocos/core/animation/skeletal-animation-state" {
    /**
     * @category animation
     */
    import { SkinnedMeshRenderer } from "cocos/core/3d/framework/skinned-mesh-renderer";
    import { Quat, Vec3 } from "cocos/core/math/index";
    import { IAnimInfo, JointAnimationInfo } from "cocos/core/renderer/models/skeletal-animation-utils";
    import { Node } from "cocos/core/scene-graph/node";
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { AnimationState } from "cocos/core/animation/animation-state";
    import { SkeletalAnimation, Socket } from "cocos/core/animation/skeletal-animation";
    interface ITransform {
        pos: Vec3;
        rot: Quat;
        scale: Vec3;
    }
    interface ISocketData {
        target: Node;
        frames: ITransform[];
    }
    export class SkeletalAnimationState extends AnimationState {
        protected _frames: number;
        protected _bakedDuration: number;
        protected _animInfo: IAnimInfo | null;
        protected _sockets: ISocketData[];
        protected _animInfoMgr: JointAnimationInfo;
        protected _comps: SkinnedMeshRenderer[];
        protected _parent: SkeletalAnimation | null;
        protected _curvesInited: boolean;
        constructor(clip: AnimationClip, name?: string);
        initialize(root: Node): void;
        onPlay(): void;
        rebuildSocketCurves(sockets: Socket[]): null | undefined;
        private _sampleCurvesBaked;
    }
}
declare module "cocos/core/animation/animation-manager" {
    /**
     * @category animation
     */
    import System from "cocos/core/components/system";
    import { Node } from "cocos/core/scene-graph/index";
    import { BlendStateBuffer } from "cocos/core/animation/skeletal-animation-blending";
    import { AnimationState } from "cocos/core/animation/animation-state";
    import { CrossFade } from "cocos/core/animation/cross-fade";
    import { Socket } from "cocos/core/animation/skeletal-animation";
    export class AnimationManager extends System {
        get blendState(): BlendStateBuffer;
        static ID: string;
        private _anims;
        private _delayEvents;
        private _blendStateBuffer;
        private _crossFades;
        private _sockets;
        addCrossFade(crossFade: CrossFade): void;
        removeCrossFade(crossFade: CrossFade): void;
        update(dt: number): void;
        destruct(): void;
        addAnimation(anim: AnimationState): void;
        removeAnimation(anim: AnimationState): void;
        pushDelayEvent(fn: Function, thisArg: any, args: any[]): void;
        addSockets(root: Node, sockets: Socket[]): void;
        removeSockets(root: Node, sockets: Socket[]): void;
    }
}
declare module "cocos/core/animation/skeletal-animation" {
    import { Node } from "cocos/core/scene-graph/node";
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { Animation } from "cocos/core/animation/animation-component";
    import { SkeletalAnimationState } from "cocos/core/animation/skeletal-animation-state";
    export class Socket {
        /**
         * @en Path of the target joint.
         * @zh 此挂点的目标骨骼路径。
         */
        path: string;
        /**
         * @en Transform output node.
         * @zh 此挂点的变换信息输出节点。
         */
        target: Node | null;
        constructor(path?: string, target?: Node | null);
    }
    /**
     * @en
     * Skeletal animation component, offers the following features on top of [[Animation]]:
     * * Choice between baked animation and real-time calculation, to leverage efficiency and expressiveness.
     * * Joint socket system: Create any socket node directly under the animation component root node,
     *   find your target joint and register both to the socket list, so that the socket node would be in-sync with the joint.
     * @zh
     * 骨骼动画组件，在普通动画组件基础上额外提供以下功能：
     * * 可选预烘焙动画模式或实时计算模式，用以权衡运行时效率与效果；
     * * 提供骨骼挂点功能：通过在动画根节点下创建挂点节点，并在骨骼动画组件上配置 socket 列表，挂点节点的 Transform 就能与骨骼保持同步。
     */
    export class SkeletalAnimation extends Animation {
        static Socket: typeof Socket;
        /**
         * @en
         * The joint sockets this animation component maintains.<br>
         * Sockets have to be registered here before attaching custom nodes to animated joints.
         * @zh
         * 当前动画组件维护的挂点数组。要挂载自定义节点到受动画驱动的骨骼上，必须先在此注册挂点。
         */
        get sockets(): Socket[];
        set sockets(val: Socket[]);
        /**
         * @en
         * Whether to bake animations. Default to true,<br>
         * which substantially increases performance while making all animations completely fixed.<br>
         * Dynamically changing this property will take effect when playing the next animation clip.
         * @zh
         * 是否使用预烘焙动画，默认启用，可以大幅提高运行效时率，但所有动画效果会被彻底固定，不支持任何形式的编辑和混合。<br>
         * 运行时动态修改此选项会在播放下一条动画片段时生效。
         */
        get useBakedAnimation(): boolean;
        set useBakedAnimation(val: boolean);
        protected _useBakedAnimation: boolean;
        protected _sockets: Socket[];
        onDestroy(): void;
        start(): void;
        querySockets(): string[];
        rebuildSocketAnimations(): void;
        createSocket(path: string): Node | null;
        protected _createState(clip: AnimationClip, name?: string): SkeletalAnimationState;
        protected _doCreateState(clip: AnimationClip, name: string): SkeletalAnimationState;
    }
}
declare module "cocos/core/3d/framework/skinned-mesh-renderer" {
    /**
     * @category model
     */
    import { AnimationClip } from "cocos/core/animation/animation-clip";
    import { Material } from "cocos/core/assets/index";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { models } from "cocos/core/renderer/index";
    import { Node } from "cocos/core/scene-graph/node";
    import { MeshRenderer } from "cocos/core/3d/framework/mesh-renderer";
    /**
     * @en The skinned mesh renderer component.
     * @zh 蒙皮网格渲染器组件。
     */
    export class SkinnedMeshRenderer extends MeshRenderer {
        protected _skeleton: Skeleton | null;
        protected _skinningRoot: Node | null;
        protected _clip: AnimationClip | null;
        /**
         * @en The skeleton asset.
         * @zh 骨骼资源。
         */
        get skeleton(): Skeleton | null;
        set skeleton(val: Skeleton | null);
        /**
         * @en The skinning root. (The node where the controlling Animation is located)
         * 骨骼根节点的引用，对应控制此模型的动画组件所在节点。
         */
        get skinningRoot(): Node | null;
        set skinningRoot(value: Node | null);
        get model(): models.SkinningModel | models.BakedSkinningModel | null;
        constructor();
        __preload(): void;
        uploadAnimation(clip: AnimationClip | null): void;
        setUseBakedAnimation(val?: boolean): void;
        setMaterial(material: Material | null, index: number): void;
        protected _updateModelParams(): void;
        private _updateModelType;
        private _update;
    }
}
declare module "cocos/core/3d/framework/skinned-mesh-batch-renderer" {
    import { Material } from "cocos/core/assets/material";
    import { Mesh } from "cocos/core/assets/mesh";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { Texture2D } from "cocos/core/assets/texture-2d";
    import { Mat4, Vec2 } from "cocos/core/math/index";
    import { SkinnedMeshRenderer } from "cocos/core/3d/framework/skinned-mesh-renderer";
    export class SkinnedMeshUnit {
        /**
         * @en Skinned mesh of this unit.
         * @zh 子蒙皮模型的网格模型。
         */
        mesh: Mesh | null;
        /**
         * @en Skeleton of this unit.
         * @zh 子蒙皮模型的骨骼。
         */
        skeleton: Skeleton | null;
        /**
         * @en Skinning material of this unit.
         * @zh 子蒙皮模型使用的材质。
         */
        material: Material | null;
        _localTransform: Mat4;
        private _offset;
        private _size;
        /**
         * @en UV offset on texture atlas.
         * @zh 在图集中的 uv 坐标偏移。
         */
        set offset(offset: Vec2);
        get offset(): Vec2;
        /**
         * @en UV extent on texture atlas.
         * @zh 在图集中占的 UV 尺寸。
         */
        set size(size: Vec2);
        get size(): Vec2;
        /**
         * @en Convenient setter, copying all necessary information from target [[SkinnedMeshRenderer]] component.
         * @zh 复制目标 [[SkinnedMeshRenderer]] 的所有属性到本单元，方便快速配置。
         */
        set copyFrom(comp: SkinnedMeshRenderer | null);
        get copyFrom(): SkinnedMeshRenderer | null;
    }
    /**
     * @en The skinned mesh batch renderer component, batches multiple skeleton-sharing [[SkinnedMeshRenderer]].
     * @zh 蒙皮模型合批组件，用于合并绘制共享同一骨骼资源的所有蒙皮网格。
     */
    export class SkinnedMeshBatchRenderer extends SkinnedMeshRenderer {
        /**
         * @en Size of the generated texture atlas.
         * @zh 合图生成的最终图集的边长。
         */
        atlasSize: number;
        /**
         * @en
         * Texture properties that will be actually using the generated atlas.<br>
         * The first unit's texture will be used if not specified.
         * @zh
         * 材质中真正参与合图的贴图属性，不参与的属性统一使用第一个 unit 的贴图。
         */
        batchableTextureNames: string[];
        /**
         * @en Source skinning model components, containing all the data to be batched.
         * @zh 合批前的子蒙皮模型数组，最主要的数据来源。
         */
        units: SkinnedMeshUnit[];
        private _textures;
        private _batchMaterial;
        get mesh(): Mesh | null;
        set mesh(val: Mesh | null);
        get skeleton(): Skeleton | null;
        set skeleton(val: Skeleton | null);
        onLoad(): void;
        onDestroy(): void;
        _onMaterialModified(idx: number, material: Material | null): void;
        cook(): void;
        cookMaterials(): void;
        cookSkeletons(): void;
        cookMeshes(): void;
        protected cookTextures(target: Texture2D, prop: string, passIdx: number): void;
        protected createTexture(prop: string): Texture2D;
        protected resizeAtlases(): void;
        private _createUnitMesh;
    }
}
declare module "cocos/core/3d/framework/light-component" {
    /**
     * @category component/light
     */
    import { Component } from "cocos/core/components/component";
    import { Color } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    export const PhotometricTerm: {
        LUMINOUS_POWER: number;
        LUMINANCE: number;
    };
    /**
     * @en static light settings.
     * @zh 静态灯光设置
     */
    class StaticLightSettings {
        protected _editorOnly: boolean;
        protected _bakeable: boolean;
        protected _castShadow: boolean;
        /**
         * @en editor only.
         * @zh 是否只在编辑器里生效。
         */
        get editorOnly(): boolean;
        set editorOnly(val: boolean);
        /**
         * @en bakeable.
         * @zh 是否可烘培。
         */
        get bakeable(): boolean;
        set bakeable(val: boolean);
        /**
         * @en cast shadow.
         * @zh 是否投射阴影。
         */
        get castShadow(): boolean;
        set castShadow(val: boolean);
    }
    export namespace Light {
        type Type = EnumAlias<typeof scene.LightType>;
        type PhotometricTerm = EnumAlias<typeof PhotometricTerm>;
    }
    export class Light extends Component {
        static Type: typeof scene.LightType;
        static PhotometricTerm: {
            LUMINOUS_POWER: number;
            LUMINANCE: number;
        };
        protected _color: Color;
        protected _useColorTemperature: boolean;
        protected _colorTemperature: number;
        protected _staticSettings: StaticLightSettings;
        protected _type: scene.LightType;
        protected _lightType: typeof scene.Light;
        protected _light: scene.Light | null;
        /**
         * @en
         * Color of the light.
         * @zh
         * 光源颜色。
         */
        get color(): Readonly<Color>;
        set color(val: Readonly<Color>);
        /**
         * @en
         * Whether to enable light color temperature.
         * @zh
         * 是否启用光源色温。
         */
        get useColorTemperature(): boolean;
        set useColorTemperature(enable: boolean);
        /**
         * @en
         * The light color temperature.
         * @zh
         * 光源色温。
         */
        get colorTemperature(): number;
        set colorTemperature(val: number);
        /**
         * @en
         * static light settings.
         * @zh
         * 静态灯光设置。
         */
        get staticSettings(): StaticLightSettings;
        set staticSettings(val: StaticLightSettings);
        /**
         * @en
         * The light type.
         * @zh
         * 光源类型。
         */
        get type(): scene.LightType;
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        protected _createLight(): void;
        protected _destroyLight(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
    }
}
declare module "cocos/core/3d/framework/directional-light-component" {
    import { scene } from "cocos/core/renderer/index";
    import { Light } from "cocos/core/3d/framework/light-component";
    export class DirectionalLight extends Light {
        protected _illuminance: number;
        protected _type: scene.LightType;
        protected _light: scene.DirectionalLight | null;
        /**
         * @en
         * The light source intensity.
         * @zh
         * 光源强度。
         */
        get illuminance(): number;
        set illuminance(val: number);
        constructor();
        protected _createLight(): void;
    }
}
declare module "cocos/core/3d/framework/sphere-light-component" {
    import { scene } from "cocos/core/renderer/index";
    import { Light } from "cocos/core/3d/framework/light-component";
    export class SphereLight extends Light {
        protected _size: number;
        protected _luminance: number;
        protected _term: number;
        protected _range: number;
        protected _type: scene.LightType;
        protected _light: scene.SphereLight | null;
        /**
         * @en Luminous power of the light.
         * @zh 光通量。
         */
        get luminousPower(): number;
        set luminousPower(val: number);
        /**
         * @en Luminance of the light.
         * @zh 光亮度。
         */
        get luminance(): number;
        set luminance(val: number);
        /**
         * @en The photometric term currently being used.
         * @zh 当前使用的光度学计量单位。
         */
        get term(): number;
        set term(val: number);
        /**
         * @en
         * Size of the light.
         * @zh
         * 光源大小。
         */
        get size(): number;
        set size(val: number);
        /**
         * @en
         * Range of the light.
         * @zh
         * 光源范围。
         */
        get range(): number;
        set range(val: number);
        constructor();
        protected _createLight(): void;
    }
}
declare module "cocos/core/3d/framework/spot-light-component" {
    import { scene } from "cocos/core/renderer/index";
    import { Light } from "cocos/core/3d/framework/light-component";
    export class SpotLight extends Light {
        protected _size: number;
        protected _luminance: number;
        protected _term: number;
        protected _range: number;
        protected _spotAngle: number;
        protected _type: scene.LightType;
        protected _light: scene.SpotLight | null;
        /**
         * @en Luminous power of the light.
         * @zh 光通量。
         */
        get luminousPower(): number;
        set luminousPower(val: number);
        /**
         * @en Luminance of the light.
         * @zh 光亮度。
         */
        get luminance(): number;
        set luminance(val: number);
        /**
         * @en The photometric term currently being used.
         * @zh 当前使用的光度学计量单位。
         */
        get term(): number;
        set term(val: number);
        /**
         * @en
         * Size of the light.
         * @zh
         * 光源大小。
         */
        get size(): number;
        set size(val: number);
        /**
         * @en
         * Range of the light.
         * @zh
         * 光源范围。
         */
        get range(): number;
        set range(val: number);
        /**
         * @en
         * The spot light cone angle.
         * @zh
         * 聚光灯锥角。
         */
        get spotAngle(): number;
        set spotAngle(val: number);
        constructor();
        protected _createLight(): void;
    }
}
declare module "cocos/core/3d/framework/deprecated" {
    import { MeshRenderer } from "cocos/core/3d/framework/mesh-renderer";
    import { Camera } from "cocos/core/3d/framework/camera-component";
    import { Light } from "cocos/core/3d/framework/light-component";
    import { SpotLight } from "cocos/core/3d/framework/spot-light-component";
    import { SphereLight } from "cocos/core/3d/framework/sphere-light-component";
    import { DirectionalLight } from "cocos/core/3d/framework/directional-light-component";
    import { SkinnedMeshRenderer } from "cocos/core/3d/framework/skinned-mesh-renderer";
    import { SkinnedMeshBatchRenderer, SkinnedMeshUnit } from "cocos/core/3d/framework/skinned-mesh-batch-renderer";
    /**
     * Alias of [[Camera]]
     * @deprecated Since v1.2
     */
    export { Camera as CameraComponent };
    /**
     * Alias of [[Light]]
     * @deprecated Since v1.2
     */
    export { Light as LightComponent };
    /**
     * Alias of [[DirectionalLight]]
     * @deprecated Since v1.2
     */
    export { DirectionalLight as DirectionalLightComponent };
    /**
     * Alias of [[SphereLight]]
     * @deprecated Since v1.2
     */
    export { SphereLight as SphereLightComponent };
    /**
     * Alias of [[SpotLight]]
     * @deprecated Since v1.2
     */
    export { SpotLight as SpotLightComponent };
    /**
     * Alias of [[MeshRenderer]]
     * @deprecated Since v1.2
     */
    export { MeshRenderer as ModelComponent };
    /**
     * Alias of [[SkinnedMeshRenderer]]
     * @deprecated Since v1.2
     */
    export { SkinnedMeshRenderer as SkinningModelComponent };
    /**
     * Alias of [[SkinnedMeshUnit]]
     * @deprecated Since v1.2
     */
    export { SkinnedMeshUnit as SkinningModelUnit };
    /**
     * Alias of [[SkinnedMeshBatchRenderer]]
     * @deprecated Since v1.2
     */
    export { SkinnedMeshBatchRenderer as BatchedSkinningModelComponent };
}
declare module "cocos/core/3d/framework/index" {
    import { SkinnedMeshBatchRenderer, SkinnedMeshUnit } from "cocos/core/3d/framework/skinned-mesh-batch-renderer";
    import { Camera } from "cocos/core/3d/framework/camera-component";
    import { DirectionalLight } from "cocos/core/3d/framework/directional-light-component";
    import { Light } from "cocos/core/3d/framework/light-component";
    import { MeshRenderer } from "cocos/core/3d/framework/mesh-renderer";
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    import { SkinnedMeshRenderer } from "cocos/core/3d/framework/skinned-mesh-renderer";
    import { SphereLight } from "cocos/core/3d/framework/sphere-light-component";
    import { SpotLight } from "cocos/core/3d/framework/spot-light-component";
    export { Camera, Light, MeshRenderer, SkinnedMeshRenderer, SkinnedMeshBatchRenderer, SkinnedMeshUnit, RenderableComponent, DirectionalLight, SphereLight, SpotLight, };
    /** deprecated */
    export * from "cocos/core/3d/framework/deprecated";
}
declare module "cocos/core/3d/index" {
    /**
     * @hidden
     */
    export * from "cocos/core/3d/builtin/index";
    export * from "cocos/core/3d/framework/index";
    import * as utils from "cocos/core/3d/misc/utils";
    export { utils, };
}
declare module "cocos/ui/components/ui-coodinate-tracker" {
    /**
     * @category component
     */
    import { Component } from "cocos/core/components/component";
    import { EventHandler } from "cocos/core/components/component-event-handler";
    import { Node } from "cocos/core/scene-graph/index";
    import { Camera } from "cocos/core/3d/index";
    import { Vec3 } from "cocos/core/math/index";
    /**
     * @zh 3D 节点映射 UI 节点组件
     * 主要提供映射后的转换世界坐标以及模拟透视相机远近比。
     */
    export class UICoordinateTracker extends Component {
        /**
         * @zh
         * 目标对象。
         */
        get target(): Node | null;
        set target(value: Node | null);
        /**
         * @zh
         * 照射相机。
         */
        get camera(): Camera | null;
        set camera(value: Camera | null);
        /**
         * @zh
         * 是否是缩放映射。
         */
        get useScale(): boolean;
        set useScale(value: boolean);
        /**
         * @zh
         * 距相机多少距离为正常显示计算大小。
         */
        get distance(): number;
        set distance(value: number);
        /**
         * @zh
         * 映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比。
         */
        syncEvents: EventHandler[];
        protected _target: Node | null;
        protected _camera: Camera | null;
        protected _useScale: boolean;
        protected _distance: number;
        protected _transformPos: Vec3;
        protected _viewPos: Vec3;
        protected _canMove: boolean;
        protected _lastWpos: Vec3;
        protected _lastCameraPos: Vec3;
        onEnable(): void;
        update(): void;
        protected _checkCanMove(): void;
    }
}
declare module "cocos/ui/components/block-input-events" {
    import { Component } from "cocos/core/components/component";
    export class BlockInputEvents extends Component {
        onEnable(): void;
        onDisable(): void;
    }
}
declare module "cocos/ui/components/widget-manager" {
    import { Node } from "cocos/core/scene-graph/node";
    import { AlignFlags, AlignMode, Widget } from "cocos/ui/components/widget";
    function updateAlignment(node: Node): void;
    export const widgetManager: {
        isAligning: boolean;
        _nodesOrderDirty: boolean;
        _activeWidgetsIterator: import("cocos/core/utils/mutable-forward-iterator").default<Widget>;
        animationState: {
            previewing: boolean;
            time: number;
            animatedSinceLastFrame: boolean;
        } | null;
        init(): void;
        add(widget: Widget): void;
        remove(widget: Widget): void;
        onResized(): void;
        refreshWidgetOnResized(node: Node): void;
        updateOffsetsToStayPut(widget: Widget, e?: AlignFlags | undefined): void;
        updateAlignment: typeof updateAlignment;
        AlignMode: typeof AlignMode;
        AlignFlags: typeof AlignFlags;
    };
}
declare module "cocos/ui/components/index" {
    /**
     * @hidden
     */
    export { Button } from "cocos/ui/components/button";
    export { EditBox } from "cocos/ui/components/editbox/edit-box";
    export * from "cocos/ui/components/label";
    export { Layout } from "cocos/ui/components/layout";
    export { Mask } from "cocos/ui/components/mask";
    export { ProgressBar } from "cocos/ui/components/progress-bar";
    export { RichText } from "cocos/ui/components/rich-text";
    export { ScrollBar } from "cocos/ui/components/scroll-bar";
    export { ScrollView } from "cocos/ui/components/scroll-view";
    export { Slider } from "cocos/ui/components/slider";
    export { Sprite } from "cocos/ui/components/sprite";
    export { Toggle } from "cocos/ui/components/toggle";
    export { ToggleContainer } from "cocos/ui/components/toggle-container";
    export { UIMeshRenderer } from "cocos/ui/components/ui-mesh-renderer";
    export { ViewGroup } from "cocos/ui/components/view-group";
    export { Widget } from "cocos/ui/components/widget";
    export { LabelOutline } from "cocos/ui/components/label-outline";
    export { Graphics } from "cocos/ui/components/graphics";
    export { PageView } from "cocos/ui/components/page-view";
    export { PageViewIndicator } from "cocos/ui/components/page-view-indicator";
    export { UIStaticBatch } from "cocos/ui/components/ui-static-batch";
    export { UIOpacity } from "cocos/ui/components/ui-opacity";
    export { SafeArea } from "cocos/ui/components/safe-area";
    export { UICoordinateTracker } from "cocos/ui/components/ui-coodinate-tracker";
    export { BlockInputEvents } from "cocos/ui/components/block-input-events";
    export { widgetManager } from "cocos/ui/components/widget-manager";
}
declare module "cocos/ui/assembler/graphics/webgl/earcut" {
    export function earcut(datas: number[], holeIndices: number[] | null, dim: number): never[];
}
declare module "cocos/ui/assembler/graphics/webgl/graphics-assembler" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * graphics 组装器
     * 可通过 `UI.graphicsAssembler` 获取该组装器。
     */
    export const graphicsAssembler: IAssembler;
}
declare module "cocos/ui/assembler/graphics/webgl/index" {
    import { IAssemblerManager } from "cocos/core/renderer/ui/base";
    import { graphicsAssembler as graphics } from "cocos/ui/assembler/graphics/webgl/graphics-assembler";
    const graphicsAssemblerManager: IAssemblerManager;
    export { graphics, graphicsAssemblerManager as graphicsAssembler, };
}
declare module "cocos/ui/assembler/graphics/index" {
    export * from "cocos/ui/assembler/graphics/webgl/index";
}
declare module "cocos/ui/assembler/label/bmfont" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * bmfont 组装器
     * 可通过 `UI.bmfont` 获取该组装器。
     */
    export const bmfont: IAssembler;
}
declare module "cocos/ui/assembler/label/letter" {
    import { UI } from "cocos/core/renderer/ui/ui";
    import { Label } from "cocos/ui/components/label";
    /**
     * letter 组装器
     * 可通过 `UI.letter` 获取该组装器。
     */
    export const letter: {
        createData(comp: Label): import("cocos/core/renderer/ui/render-data").RenderData;
        fillBuffers(comp: Label, renderer: UI): void;
        appendQuad: any;
    };
}
declare module "cocos/ui/assembler/label/ttfUtils" {
    import { Vec2 } from "cocos/core/math/index";
    import { Label } from "cocos/ui/components/index";
    import { ISharedLabelData } from "cocos/ui/assembler/label/font-utils";
    import { UITransform } from "cocos/core/components/ui-base/ui-transform";
    export const ttfUtils: {
        getAssemblerData(): ISharedLabelData;
        resetAssemblerData(assemblerData: ISharedLabelData): void;
        updateRenderData(comp: Label): void;
        updateVertexData(comp: Label): void;
        _updateFontFamily(comp: Label): void;
        _updateProperties(comp: Label, trans: UITransform): void;
        _calculateFillTextStartPosition(): Vec2;
        _updateTexture(): void;
        _calculateUnderlineStartPosition(): Vec2;
        _updateLabelDimensions(): void;
        _calculateTextBaseline(): void;
        _calculateSplitStrings(): void;
        _getFontDesc(): string;
        _getLineHeight(): number;
        _calculateParagraphLength(paragraphedStrings: string[], ctx: CanvasRenderingContext2D): number[];
        _measureText(ctx: CanvasRenderingContext2D): (string: string) => number;
        _calculateLabelFont(): void;
    };
}
declare module "cocos/ui/assembler/label/ttf" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * ttf 组装器
     * 可通过 `UI.ttf` 获取该组装器。
     */
    export const ttf: IAssembler;
}
declare module "cocos/ui/assembler/label/index" {
    import { IAssemblerManager } from "cocos/core/renderer/ui/base";
    import { bmfont } from "cocos/ui/assembler/label/bmfont";
    import { CanvasPool } from "cocos/ui/assembler/label/font-utils";
    import { letter } from "cocos/ui/assembler/label/letter";
    import { ttf } from "cocos/ui/assembler/label/ttf";
    const labelAssembler: IAssemblerManager;
    export { labelAssembler, ttf, bmfont, letter, CanvasPool, };
}
declare module "cocos/core/renderer/ui/stencil-manager" {
    /**
     * @hidden
     */
    import { Material } from "cocos/core/assets/material";
    import { GFXComparisonFunc, GFXStencilOp } from "cocos/core/gfx/define";
    export enum Stage {
        DISABLED = 0,
        CLEAR = 1,
        ENTER_LEVEL = 2,
        ENABLED = 3,
        EXIT_LEVEL = 4
    }
    export class StencilManager {
        static sharedManager: StencilManager | null;
        stage: Stage;
        private _maskStack;
        private _stencilPattern;
        get pattern(): {
            stencilTest: boolean;
            func: GFXComparisonFunc;
            stencilMask: number;
            writeMask: number;
            failOp: GFXStencilOp;
            zFailOp: GFXStencilOp;
            passOp: GFXStencilOp;
            ref: number;
        };
        pushMask(mask: any): void;
        clear(): void;
        enterLevel(): void;
        enableMask(): void;
        exitMask(): void;
        handleMaterial(mat: Material): boolean;
        getWriteMask(): number;
        getExitWriteMask(): number;
        getStencilRef(): number;
        reset(): void;
        private _changed;
    }
}
declare module "cocos/ui/assembler/mask/mask-assembler" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    export const maskAssembler: IAssembler;
    export const maskEndAssembler: IAssembler;
}
declare module "cocos/ui/assembler/mask/index" {
    /**
     * @hidden
     */
    import { maskAssembler as mask, maskEndAssembler as maskEnd } from "cocos/ui/assembler/mask/mask-assembler";
    export { mask, maskEnd, };
}
declare module "cocos/ui/assembler/sprite/bar-filled" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * barFilled 组装器
     * 可通过 `UI.barFilled` 获取该组装器。
     */
    export const barFilled: IAssembler;
}
declare module "cocos/ui/assembler/sprite/radial-filled" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * radialFilled 组装器
     * 可通过 `UI.radialFilled` 获取该组装器。
     */
    export const radialFilled: IAssembler;
}
declare module "cocos/ui/assembler/sprite/simple" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * simple 组装器
     * 可通过 `UI.simple` 获取该组装器。
     */
    export const simple: IAssembler;
}
declare module "cocos/ui/assembler/sprite/sliced" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    /**
     * sliced 组装器
     * 可通过 `UI.sliced` 获取该组装器。
     */
    export const sliced: IAssembler;
}
declare module "cocos/ui/assembler/sprite/tiled" {
    import { IAssembler } from "cocos/core/renderer/ui/base";
    export const tilled: IAssembler;
}
declare module "cocos/ui/assembler/sprite/index" {
    import { IAssemblerManager } from "cocos/core/renderer/ui/base";
    import { barFilled } from "cocos/ui/assembler/sprite/bar-filled";
    import { radialFilled } from "cocos/ui/assembler/sprite/radial-filled";
    import { simple } from "cocos/ui/assembler/sprite/simple";
    import { sliced } from "cocos/ui/assembler/sprite/sliced";
    const spriteAssembler: IAssemblerManager;
    export { spriteAssembler, simple, sliced, barFilled, radialFilled, };
}
declare module "cocos/ui/assembler/index" {
    /**
     * @category ui
     */
    import "cocos/ui/assembler/utils";
    export * from "cocos/ui/assembler/graphics/index";
    export * from "cocos/ui/assembler/label/index";
    export * from "cocos/ui/assembler/mask/index";
    export * from "cocos/ui/assembler/sprite/index";
    export * from "cocos/core/renderer/ui/base";
}
declare module "cocos/ui/deprecated" {
    import { BlockInputEvents, Button, EditBox, Layout, Mask, Label, LabelOutline, ProgressBar, RichText, ScrollView, ScrollBar, Slider, Sprite, Toggle, ToggleContainer, UIMeshRenderer, Widget, Graphics, PageView, PageViewIndicator, UIStaticBatch, UIOpacity, SafeArea, UICoordinateTracker } from "cocos/ui/components/index";
    /**
     * @deprecated Since v1.2
     */
    export class UIReorderComponent {
        constructor();
    }
    /**
     * Alias of [[Button]]
     * @deprecated Since v1.2
     */
    export { Button as ButtonComponent };
    /**
     * Alias of [[EditBox]]
     * @deprecated Since v1.2
     */
    export { EditBox as EditBoxComponent };
    /**
     * Alias of [[Layout]]
     * @deprecated Since v1.2
     */
    export { Layout as LayoutComponent };
    /**
     * Alias of [[Mask]]
     * @deprecated Since v1.2
     */
    export { Mask as MaskComponent };
    /**
     * Alias of [[Label]]
     * @deprecated Since v1.2
     */
    export { Label as LabelComponent };
    /**
     * Alias of [[LabelOutline]]
     * @deprecated Since v1.2
     */
    export { LabelOutline as LabelOutlineComponent };
    /**
     * Alias of [[ProgressBar]]
     * @deprecated Since v1.2
     */
    export { ProgressBar as ProgressBarComponent };
    /**
     * Alias of [[RichText]]
     * @deprecated Since v1.2
     */
    export { RichText as RichTextComponent };
    /**
     * Alias of [[ScrollView]]
     * @deprecated Since v1.2
     */
    export { ScrollView as ScrollViewComponent };
    /**
     * Alias of [[ScrollBar]]
     * @deprecated Since v1.2
     */
    export { ScrollBar as ScrollBarComponent };
    /**
     * Alias of [[Slider]]
     * @deprecated Since v1.2
     */
    export { Slider as SliderComponent };
    /**
     * Alias of [[Sprite]]
     * @deprecated Since v1.2
     */
    export { Sprite as SpriteComponent };
    /**
     * Alias of [[Toggle]]
     * @deprecated Since v1.2
     */
    export { Toggle as ToggleComponent };
    /**
     * Alias of [[ToggleContainer]]
     * @deprecated Since v1.2
     */
    export { ToggleContainer as ToggleContainerComponent };
    /**
     * Alias of [[UIMeshRenderer]]
     * @deprecated Since v1.2
     */
    export { UIMeshRenderer as UIModelComponent };
    /**
     * Alias of [[Widget]]
     * @deprecated Since v1.2
     */
    export { Widget as WidgetComponent };
    /**
     * Alias of [[Graphics]]
     * @deprecated Since v1.2
     */
    export { Graphics as GraphicsComponent };
    /**
     * Alias of [[PageView]]
     * @deprecated Since v1.2
     */
    export { PageView as PageViewComponent };
    /**
     * Alias of [[PageViewIndicator]]
     * @deprecated Since v1.2
     */
    export { PageViewIndicator as PageViewIndicatorComponent };
    /**
     * Alias of [[UIStaticBatch]]
     * @deprecated Since v1.2
     */
    export { UIStaticBatch as UIStaticBatchComponent };
    /**
     * Alias of [[UIOpacity]]
     * @deprecated Since v1.2
     */
    export { UIOpacity as UIOpacityComponent };
    /**
     * Alias of [[SafeArea]]
     * @deprecated Since v1.2
     */
    export { SafeArea as SafeAreaComponent };
    /**
     * Alias of [[UICoordinateTracker]]
     * @deprecated Since v1.2
     */
    export { UICoordinateTracker as UICoordinateTrackerComponent };
    /**
     * Alias of [[BlockInputEvents]]
     * @deprecated Since v1.2
     */
    export { BlockInputEvents as BlockInputEventsComponent };
}
declare module "cocos/ui/index" {
    /**
     * @hidden
     */
    import { CanvasPool, graphicsAssembler, labelAssembler, spriteAssembler } from "cocos/ui/assembler/index";
    import { MeshBuffer } from "cocos/core/renderer/ui/mesh-buffer";
    import * as UIVertexFormat from "cocos/core/renderer/ui/ui-vertex-format";
    import { StencilManager } from "cocos/core/renderer/ui/stencil-manager";
    export * from "cocos/ui/components/index";
    export * from "cocos/ui/deprecated";
    export { MeshBuffer, UIVertexFormat, StencilManager, CanvasPool, spriteAssembler, labelAssembler, graphicsAssembler, };
}
declare module "cocos/core/renderer/ui/ui-batch-model" {
    /**
     * @hidden
     */
    import { Model } from "cocos/core/renderer/scene/model";
    import { UIDrawBatch } from "cocos/core/renderer/ui/ui-draw-batch";
    export class UIBatchModel extends Model {
        private _subModel;
        constructor();
        updateTransform(): void;
        updateUBOs(stamp: number): void;
        directInitialize(batch: UIDrawBatch): void;
        destroy(): void;
    }
}
declare module "cocos/core/renderer/ui/ui-material" {
    /**
     * @hidden
     */
    import { Material } from "cocos/core/assets/material";
    import { Pass } from "cocos/core/renderer/core/pass";
    import { DescriptorSetHandle } from "cocos/core/renderer/core/memory-pools";
    export interface IUIMaterialInfo {
        material: Material;
    }
    export class UIMaterial {
        protected _material: Material | null;
        protected _pass: Pass | null;
        protected _hDescriptorSet: DescriptorSetHandle;
        private _refCount;
        get material(): Material;
        get pass(): Pass;
        get hDescriptorSet(): DescriptorSetHandle;
        initialize(info: IUIMaterialInfo): boolean;
        increase(): number;
        decrease(): number;
        destroy(): void;
    }
}
declare module "cocos/core/renderer/ui/ui" {
    /**
     * @hidden
     */
    import { UIStaticBatch } from "cocos/ui/index";
    import { Material } from "cocos/core/assets/material";
    import { Canvas, UIComponent, UIRenderable } from "cocos/core/components/ui-base/index";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXSampler } from "cocos/core/gfx/sampler";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { Model } from "cocos/core/renderer/scene/model";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { Root } from "cocos/core/root";
    import { MeshBuffer } from "cocos/core/renderer/ui/mesh-buffer";
    import { UIMaterial } from "cocos/core/renderer/ui/ui-material";
    /**
     * @zh
     * UI 渲染流程
     */
    export class UI {
        private _root;
        get renderScene(): RenderScene;
        get currBufferBatch(): MeshBuffer | null;
        set currBufferBatch(value: MeshBuffer | null);
        set currStaticRoot(value: UIStaticBatch | null);
        device: GFXDevice;
        private _screens;
        private _bufferBatchPool;
        private _drawBatchPool;
        private _scene;
        private _attributes;
        private _meshBuffers;
        private _meshBufferUseCount;
        private _uiMaterials;
        private _canvasMaterials;
        private _batches;
        private _uiModelPool;
        private _modelInUse;
        private _emptyMaterial;
        private _currMaterial;
        private _currTexture;
        private _currSampler;
        private _currCanvas;
        private _currMeshBuffer;
        private _currStaticRoot;
        private _currComponent;
        private _parentOpacity;
        constructor(_root: Root);
        initialize(): boolean;
        destroy(): void;
        getRenderSceneGetter(): () => any;
        _getUIMaterial(mat: Material): UIMaterial;
        _removeUIMaterial(hash: number): void;
        /**
         * @en
         * Add the managed Canvas.
         *
         * @zh
         * 添加屏幕组件管理。
         *
         * @param comp - 屏幕组件。
         */
        addScreen(comp: Canvas): void;
        /**
         * @en
         * Get the Canvas by number.
         *
         * @zh
         * 通过屏幕编号获得屏幕组件。
         *
         * @param visibility - 屏幕编号。
         */
        getScreen(visibility: number): Canvas | null;
        /**
         * @zh
         * Removes the Canvas from the list.
         *
         * @param comp - 被移除的屏幕。
         */
        removeScreen(comp: Canvas): void;
        update(dt: number): void;
        sortScreens(): void;
        render(): void;
        /**
         * @en
         * Render component data submission process of UI.
         * The submitted vertex data is the UI for world coordinates.
         * For example: The UI components except Graphics and UIModel.
         *
         * @zh
         * UI 渲染组件数据提交流程（针对提交的顶点数据是世界坐标的提交流程，例如：除 Graphics 和 UIModel 的大部分 ui 组件）。
         * 此处的数据最终会生成需要提交渲染的 model 数据。
         *
         * @param comp - 当前执行组件。
         * @param frame - 当前执行组件贴图。
         * @param assembler - 当前组件渲染数据组装器。
         */
        commitComp(comp: UIRenderable, frame: GFXTexture | null | undefined, assembler: any, sampler?: GFXSampler | null): void;
        /**
         * @en
         * Render component data submission process of UI.
         * The submitted vertex data is the UI for local coordinates.
         * For example: The UI components of Graphics and UIModel.
         *
         * @zh
         * UI 渲染组件数据提交流程（针对例如： Graphics 和 UIModel 等数据量较为庞大的 ui 组件）。
         *
         * @param comp - 当前执行组件。
         * @param model - 提交渲染的 model 数据。
         * @param mat - 提交渲染的材质。
         */
        commitModel(comp: UIComponent | UIRenderable, model: Model | null, mat: Material | null): void;
        /**
         * @en
         * Submit separate render data.
         * This data does not participate in the batch.
         *
         * @zh
         * 提交独立渲染数据.
         * @param comp 静态组件
         */
        commitStaticBatch(comp: UIStaticBatch): void;
        /**
         * @en
         * End a section of render data and submit according to the batch condition.
         *
         * @zh
         * 根据合批条件，结束一段渲染数据并提交。
         */
        autoMergeBatches(renderComp?: UIRenderable): void;
        /**
         * @en
         * Force changes to current batch data and merge
         *
         * @zh
         * 强行修改当前批次数据并合并。
         *
         * @param material - 当前批次的材质。
         * @param sprite - 当前批次的精灵帧。
         */
        forceMergeBatches(material: Material, sprite: GFXTexture | null): void;
        /**
         * @en
         * Forced to merge the data of the previous batch to start a new batch.
         *
         * @zh
         * 强制合并上一个批次的数据，开启新一轮合批。
         */
        finishMergeBatches(): void;
        private _destroyUIMaterials;
        private _walk;
        private _renderScreens;
        private _preprocess;
        private _postprocess;
        private _recursiveScreenNode;
        private _reset;
        private _createMeshBuffer;
        private _requireBufferBatch;
        private _screenSort;
        private _applyOpacity;
    }
}
declare module "cocos/core/components/ui-base/ui-component" {
    import { UI } from "cocos/core/renderer/ui/ui";
    import { Component } from "cocos/core/components/component";
    import { Node } from "cocos/core/scene-graph/index";
    /**
     * @zh
     * UI 及 UI 模型渲染基类。
     */
    export class UIComponent extends Component {
        protected _lastParent: Node | null;
        __preload(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        updateAssembler(render: UI): void;
        postUpdateAssembler(render: UI): void;
    }
}
declare module "cocos/core/scene-graph/node-ui-properties" {
    /**
     * @category scene-graph
     */
    import { UIComponent } from "cocos/core/components/ui-base/ui-component";
    import { UITransform } from "cocos/core/components/ui-base/ui-transform";
    import { UIRenderable } from "cocos/core/components/ui-base/ui-renderable";
    /**
     * @en Node's UI properties abstraction
     * @zh 节点上 UI 相关的属性抽象类
     */
    export class NodeUIProperties {
        /**
         * @en The UI transform component
         * @zh UI 变换组件
         */
        get uiTransformComp(): UITransform | null;
        set uiTransformComp(value: UITransform | null);
        /**
         * @en The base UI component
         * @zh UI 基类组件
         */
        uiComp: UIComponent | UIRenderable | null;
        /**
         * @en The opacity of the UI node
         * @zh UI 透明度
         */
        opacity: number;
        protected _uiTransformComp: UITransform | null;
        private _node;
        constructor(node: any);
    }
}
declare module "cocos/core/scene-graph/node" {
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import { SystemEventType } from "cocos/core/platform/event-manager/event-enum";
    import { BaseNode } from "cocos/core/scene-graph/base-node";
    import { NodeSpace, TransformBit } from "cocos/core/scene-graph/node-enum";
    import { NodeUIProperties } from "cocos/core/scene-graph/node-ui-properties";
    /**
     * @zh
     * 场景树中的基本节点，基本特性有：
     * * 具有层级关系
     * * 持有各类组件
     * * 维护空间变换（坐标、旋转、缩放）信息
     */
    /**
     * !#en
     * Class of all entities in Cocos Creator scenes.
     * Basic functionalities include:
     * * Hierarchy management with parent and children
     * * Components management
     * * Coordinate system with position, scale, rotation in 3d space
     * !#zh
     * Cocos Creator 场景中的所有节点类。
     * 基本特性有：
     * * 具有层级关系
     * * 持有各类组件
     * * 维护 3D 空间左边变换（坐标、旋转、缩放）信息
     */
    export class Node extends BaseNode {
        static bookOfChange: Map<string, number>;
        /**
         * @en Event types emitted by Node
         * @zh 节点可能发出的事件类型
         */
        static EventType: typeof SystemEventType;
        /**
         * @en Coordinates space
         * @zh 空间变换操作的坐标系
         */
        static NodeSpace: typeof NodeSpace;
        /**
         * @en Bit masks for Node transformation parts
         * @zh 节点变换更新的具体部分
         * @deprecated please use [[Node.TransformBit]]
         */
        static TransformDirtyBit: typeof TransformBit;
        /**
         * @en Bit masks for Node transformation parts, can be used to determine which part changed in [[SystemEventType.TRANSFORM_CHANGED]] event
         * @zh 节点变换更新的具体部分，可用于判断 [[SystemEventType.TRANSFORM_CHANGED]] 事件的具体类型
         */
        static TransformBit: typeof TransformBit;
        /**
         * @en Determine whether the given object is a normal Node. Will return false if [[Scene]] given.
         * @zh 指定对象是否是普通的节点？如果传入 [[Scene]] 会返回 false。
         */
        static isNode(obj: object | null): obj is Node;
        _uiProps: NodeUIProperties;
        _static: boolean;
        protected _pos: Vec3;
        protected _rot: Quat;
        protected _scale: Vec3;
        protected _mat: Mat4;
        protected _lpos: Vec3;
        protected _lrot: Quat;
        protected _lscale: Vec3;
        protected _layer: number;
        protected _euler: Vec3;
        protected _dirtyFlags: TransformBit;
        protected _eulerDirty: boolean;
        /**
         * @en Position in local coordinate system
         * @zh 本地坐标系下的坐标
         */
        get position(): Readonly<Vec3>;
        set position(val: Readonly<Vec3>);
        /**
         * @en Position in world coordinate system
         * @zh 世界坐标系下的坐标
         */
        get worldPosition(): Readonly<Vec3>;
        set worldPosition(val: Readonly<Vec3>);
        /**
         * @en Rotation in local coordinate system, represented by a quaternion
         * @zh 本地坐标系下的旋转，用四元数表示
         */
        get rotation(): Readonly<Quat>;
        set rotation(val: Readonly<Quat>);
        /**
         * @en Rotation in local coordinate system, represented by euler angles
         * @zh 本地坐标系下的旋转，用欧拉角表示
         */
        set eulerAngles(val: Readonly<Vec3>);
        get eulerAngles(): Readonly<Vec3>;
        /**
         * @en Rotation in world coordinate system, represented by a quaternion
         * @zh 世界坐标系下的旋转，用四元数表示
         */
        get worldRotation(): Readonly<Quat>;
        set worldRotation(val: Readonly<Quat>);
        /**
         * @en Scale in local coordinate system
         * @zh 本地坐标系下的缩放
         */
        get scale(): Readonly<Vec3>;
        set scale(val: Readonly<Vec3>);
        /**
         * @en Scale in world coordinate system
         * @zh 世界坐标系下的缩放
         */
        get worldScale(): Readonly<Vec3>;
        set worldScale(val: Readonly<Vec3>);
        /**
         * @en Local transformation matrix
         * @zh 本地坐标系变换矩阵
         */
        set matrix(val: Readonly<Mat4>);
        /**
         * @en World transformation matrix
         * @zh 世界坐标系变换矩阵
         */
        get worldMatrix(): Readonly<Mat4>;
        /**
         * @en The vector representing forward direction in local coordinate system, it's the minus z direction by default
         * @zh 当前节点面向的前方方向，默认前方为 -z 方向
         */
        get forward(): Vec3;
        set forward(dir: Vec3);
        /**
         * @en Layer of the current Node, it affects raycast, physics etc, refer to [[Layers]]
         * @zh 节点所属层，主要影响射线检测、物理碰撞等，参考 [[Layers]]
         */
        set layer(l: number);
        get layer(): number;
        /**
         * @en Whether the node's transformation have changed during the current frame.
         * @zh 这个节点的空间变换信息在当前帧内是否有变过？
         */
        get hasChangedFlags(): number;
        set hasChangedFlags(val: number);
        /**
         * @en Set parent of the node.
         * @zh 设置该节点的父节点。
         * @param value Parent node
         * @param keepWorldTransform Whether keep node's current world transform unchanged after this operation
         */
        setParent(value: this | null, keepWorldTransform?: boolean): void;
        _onSetParent(oldParent: this | null, keepWorldTransform: boolean): void;
        _onBatchCreated(): void;
        _onBatchRestored(): void;
        _onBeforeSerialize(): void;
        _onPostActivated(active: boolean): void;
        /**
         * @en Perform a translation on the node
         * @zh 移动节点
         * @param trans The increment on position
         * @param ns The operation coordinate space
         */
        translate(trans: Vec3, ns?: NodeSpace): void;
        /**
         * @en Perform a rotation on the node
         * @zh 旋转节点
         * @param trans The increment on position
         * @param ns The operation coordinate space
         */
        rotate(rot: Quat, ns?: NodeSpace): void;
        /**
         * @en Set the orientation of the node to face the target position, the node is facing minus z direction by default
         * @zh 设置当前节点旋转为面向目标位置，默认前方为 -z 方向
         * @param pos Target position
         * @param up Up direction
         */
        lookAt(pos: Vec3, up?: Vec3): void;
        /**
         * @en Invalidate the world transform information
         * for this node and all its children recursively
         * @zh 递归标记节点世界变换为 dirty
         * @param dirtyBit The dirty bits to setup to children, can be composed with multiple dirty bits
         */
        invalidateChildren(dirtyBit: TransformBit): void;
        /**
         * @en Update the world transform information if outdated
         * @zh 更新节点的世界变换信息
         */
        updateWorldTransform(): void;
        /**
         * @en Set position in local coordinate system
         * @zh 设置本地坐标
         * @param position Target position
         */
        setPosition(position: Vec3): void;
        /**
         * @en Set position in local coordinate system
         * @zh 设置本地坐标
         * @param x X axis position
         * @param y Y axis position
         * @param z Z axis position
         */
        setPosition(x: number, y: number, z: number): void;
        /**
         * @en Get position in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取本地坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getPosition(out?: Vec3): Vec3;
        /**
         * @en Set rotation in local coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置本地旋转
         * @param rotation Rotation in quaternion
         */
        setRotation(rotation: Quat): void;
        /**
         * @en Set rotation in local coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置本地旋转
         * @param x X value in quaternion
         * @param y Y value in quaternion
         * @param z Z value in quaternion
         * @param w W value in quaternion
         */
        setRotation(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set rotation in local coordinate system with euler angles
         * @zh 用欧拉角设置本地旋转
         * @param x X axis rotation
         * @param y Y axis rotation
         * @param z Z axis rotation
         */
        setRotationFromEuler(x: number, y: number, z: number): void;
        /**
         * @en Get rotation as quaternion in local coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
         * @zh 获取本地旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
         * @param out Set the result to out quaternion
         * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
         */
        getRotation(out?: Quat): Quat;
        /**
         * @en Set scale in local coordinate system
         * @zh 设置本地缩放
         * @param scale Target scale
         */
        setScale(scale: Vec3): void;
        /**
         * @en Set scale in local coordinate system
         * @zh 设置本地缩放
         * @param x X axis scale
         * @param y Y axis scale
         * @param z Z axis scale
         */
        setScale(x: number, y: number, z: number): void;
        /**
         * @en Get scale in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取本地缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getScale(out?: Vec3): Vec3;
        /**
         * @en Inversely transform a point from world coordinate system to local coordinate system.
         * @zh 逆向变换一个空间点，一般用于将世界坐标转换到本地坐标系中。
         * @param out The result point in local coordinate system will be stored in this vector
         * @param p A position in world coordinate system
         */
        inverseTransformPoint(out: Vec3, p: Vec3): Vec3;
        /**
         * @en Set position in world coordinate system
         * @zh 设置世界坐标
         * @param position Target position
         */
        setWorldPosition(position: Vec3): void;
        /**
         * @en Set position in world coordinate system
         * @zh 设置世界坐标
         * @param x X axis position
         * @param y Y axis position
         * @param z Z axis position
         */
        setWorldPosition(x: number, y: number, z: number): void;
        /**
         * @en Get position in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取世界坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getWorldPosition(out?: Vec3): Vec3;
        /**
         * @en Set rotation in world coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置世界坐标系下的旋转
         * @param rotation Rotation in quaternion
         */
        setWorldRotation(rotation: Quat): void;
        /**
         * @en Set rotation in world coordinate system with a quaternion representing the rotation
         * @zh 用四元数设置世界坐标系下的旋转
         * @param x X value in quaternion
         * @param y Y value in quaternion
         * @param z Z value in quaternion
         * @param w W value in quaternion
         */
        setWorldRotation(x: number, y: number, z: number, w: number): void;
        /**
         * @en Set rotation in world coordinate system with euler angles
         * @zh 用欧拉角设置世界坐标系下的旋转
         * @param x X axis rotation
         * @param y Y axis rotation
         * @param z Z axis rotation
         */
        setWorldRotationFromEuler(x: number, y: number, z: number): void;
        /**
         * @en Get rotation as quaternion in world coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
         * @zh 获取世界坐标系下的旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
         * @param out Set the result to out quaternion
         * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
         */
        getWorldRotation(out?: Quat): Quat;
        /**
         * @en Set scale in world coordinate system
         * @zh 设置世界坐标系下的缩放
         * @param scale Target scale
         */
        setWorldScale(scale: Vec3): void;
        /**
         * @en Set scale in world coordinate system
         * @zh 设置世界坐标系下的缩放
         * @param x X axis scale
         * @param y Y axis scale
         * @param z Z axis scale
         */
        setWorldScale(x: number, y: number, z: number): void;
        /**
         * @en Get scale in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
         * @zh 获取世界缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
         * @param out Set the result to out vector
         * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
         */
        getWorldScale(out?: Vec3): Vec3;
        /**
         * @en Get a world transform matrix
         * @zh 获取世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldMatrix(out?: Mat4): Mat4;
        /**
         * @en Get a world transform matrix with only rotation and scale
         * @zh 获取只包含旋转和缩放的世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldRS(out?: Mat4): Mat4;
        /**
         * @en Get a world transform matrix with only rotation and translation
         * @zh 获取只包含旋转和位移的世界变换矩阵
         * @param out Set the result to out matrix
         * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
         */
        getWorldRT(out?: Mat4): Mat4;
        /**
         * @en Set local transformation with rotation, position and scale separately.
         * @zh 一次性设置所有局部变换（平移、旋转、缩放）信息
         * @param rot The rotation
         * @param pos The position
         * @param scale The scale
         */
        setRTS(rot?: Quat | Vec3, pos?: Vec3, scale?: Vec3): void;
        /**
         * @en Pause all system events which is dispatched by [[SystemEvent]]
         * @zh 暂停所有 [[SystemEvent]] 派发的系统事件
         * @param recursive Whether pause system events recursively for the child node tree
         */
        pauseSystemEvents(recursive: boolean): void;
        /**
         * @en Resume all paused system events which is dispatched by [[SystemEvent]]
         * @zh 恢复所有 [[SystemEvent]] 派发的系统事件
         * @param recursive Whether resume system events recursively for the child node tree
         */
        resumeSystemEvents(recursive: boolean): void;
    }
}
declare module "cocos/core/data/instantiate" {
    import Prefab from "cocos/core/assets/prefab";
    import { Node } from "cocos/core/scene-graph/node";
    /**
     * @zh 从 Prefab 实例化出新节点。
     * @en Instantiate a node from the Prefab.
     * @param prefab The prefab.
     * @returns The instantiated node.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Instantiate node from prefab.
     * const node = instantiate(prefabAsset);
     * node.parent = director.getScene();
     * ```
     */
    export function instantiate(prefab: Prefab): Node;
    /**
     * @zh 从 Prefab 实例化出新节点。
     * @en Instantiate a node from the Prefab.
     * @param prefab The prefab.
     * @returns The instantiated node.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Instantiate node from prefab.
     * const node = instantiate(prefabAsset);
     * node.parent = director.getScene();
     * ```
     */
    export namespace instantiate {
        var _clone: typeof doInstantiate;
    }
    /**
     * @en Clones the object `original.
     * @zh 克隆指定的任意类型的对象。
     * @param original An existing object that you want to make a copy of.
     * It can be any JavaScript object(`typeof original === 'object'`) but:
     * - it shall not be array or null;
     * - it shall not be object of `Asset`;
     * - if it's an object of `CCObject`, it should not have been destroyed.
     * @returns The newly instantiated object.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Clone a node.
     * const node = instantiate(targetNode);
     * node.parent = director.getScene();
     * ```
     */
    export function instantiate<T>(original: T): T;
    /**
     * @en Clones the object `original.
     * @zh 克隆指定的任意类型的对象。
     * @param original An existing object that you want to make a copy of.
     * It can be any JavaScript object(`typeof original === 'object'`) but:
     * - it shall not be array or null;
     * - it shall not be object of `Asset`;
     * - if it's an object of `CCObject`, it should not have been destroyed.
     * @returns The newly instantiated object.
     * @example
     * ```ts
     * import { instantiate, director } from 'cc';
     * // Clone a node.
     * const node = instantiate(targetNode);
     * node.parent = director.getScene();
     * ```
     */
    export namespace instantiate {
        var _clone: typeof doInstantiate;
    }
    function doInstantiate(obj: any, parent?: any): any;
}
declare module "cocos/core/data/index" {
    /**
     * @category core/data
     */
    import * as _decorator from "cocos/core/data/class-decorator";
    export { _decorator };
    export { CCClass } from "cocos/core/data/class";
    export { CCObject, isValid } from "cocos/core/data/object";
    export { deserialize } from "cocos/core/data/deserialize";
    export { instantiate } from "cocos/core/data/instantiate";
    export { CCInteger, CCFloat, CCBoolean, CCString } from "cocos/core/data/utils/attribute";
    export { CompactValueTypeArray } from "cocos/core/data/utils/compact-value-type-array";
}
declare module "cocos/core/pipeline/pipeline-serialization" {
    import { GFXFormat, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXTextureType, GFXTextureUsageBit } from "cocos/core/gfx/define";
    import { RenderTexture } from "cocos/core/assets/render-texture";
    import { Material } from "cocos/core/assets/material";
    /**
     * @en The tag of the render flow, including SCENE, POSTPROCESS and UI.
     * @zh 渲染流程的标签，包含：常规场景（SCENE），后处理（POSTPROCESS），UI 界面（UI）
     */
    export enum RenderFlowTag {
        SCENE = 0,
        POSTPROCESS = 1,
        UI = 2
    }
    export class RenderTextureDesc {
        name: string;
        type: GFXTextureType;
        usage: GFXTextureUsageBit;
        format: GFXFormat;
        width: number;
        height: number;
    }
    export class RenderTextureConfig {
        name: string;
        texture: RenderTexture | null;
    }
    export class MaterialConfig {
        name: string;
        material: Material | null;
    }
    export class FrameBufferDesc {
        name: string;
        renderPass: number;
        colorTextures: string[];
        depthStencilTexture: string;
        texture: RenderTexture | null;
    }
    export class ColorDesc {
        format: GFXFormat;
        loadOp: GFXLoadOp;
        storeOp: GFXStoreOp;
        sampleCount: number;
        beginLayout: GFXTextureLayout;
        endLayout: GFXTextureLayout;
    }
    export class DepthStencilDesc {
        format: GFXFormat;
        depthLoadOp: GFXLoadOp;
        depthStoreOp: GFXStoreOp;
        stencilLoadOp: GFXLoadOp;
        stencilStoreOp: GFXStoreOp;
        sampleCount: number;
        beginLayout: GFXTextureLayout;
        endLayout: GFXTextureLayout;
    }
    export class RenderPassDesc {
        index: number;
        colorAttachments: never[];
        depthStencilAttachment: DepthStencilDesc;
    }
    export enum RenderQueueSortMode {
        FRONT_TO_BACK = 0,
        BACK_TO_FRONT = 1
    }
    /**
     * @en The render queue descriptor
     * @zh 渲染队列描述信息
     */
    export class RenderQueueDesc {
        /**
         * @en Whether the render queue is a transparent queue
         * @zh 当前队列是否是半透明队列
         */
        isTransparent: boolean;
        /**
         * @en The sort mode of the render queue
         * @zh 渲染队列的排序模式
         */
        sortMode: RenderQueueSortMode;
        /**
         * @en The stages using this queue
         * @zh 使用当前渲染队列的阶段列表
         */
        stages: string[];
    }
}
declare module "cocos/core/pipeline/render-window" {
    import { GFXRenderPass, GFXTexture, GFXFramebuffer, IGFXRenderPassInfo, GFXDevice } from "cocos/core/gfx/index";
    import { Root } from "cocos/core/root";
    export interface IRenderWindowInfo {
        title?: string;
        width: number;
        height: number;
        renderPassInfo: IGFXRenderPassInfo;
        swapchainBufferIndices?: number;
        shouldSyncSizeWithSwapchain?: boolean;
    }
    export class RenderWindow {
        /**
         * @en Get window width.
         * @zh 窗口宽度。
         */
        get width(): number;
        /**
         * @en Get window height.
         * @zh 窗口高度。
         */
        get height(): number;
        /**
         * @en Get window frame buffer.
         * @zh GFX帧缓冲。
         */
        get framebuffer(): GFXFramebuffer;
        get shouldSyncSizeWithSwapchain(): boolean;
        get hasOnScreenAttachments(): boolean;
        get hasOffScreenAttachments(): boolean;
        static registerCreateFunc(root: Root): void;
        protected _title: string;
        protected _width: number;
        protected _height: number;
        protected _nativeWidth: number;
        protected _nativeHeight: number;
        protected _renderPass: GFXRenderPass | null;
        protected _colorTextures: (GFXTexture | null)[];
        protected _depthStencilTexture: GFXTexture | null;
        protected _framebuffer: GFXFramebuffer | null;
        protected _swapchainBufferIndices: number;
        protected _shouldSyncSizeWithSwapchain: boolean;
        protected _hasOnScreenAttachments: boolean;
        protected _hasOffScreenAttachments: boolean;
        private constructor();
        initialize(device: GFXDevice, info: IRenderWindowInfo): boolean;
        destroy(): void;
        /**
         * @en Resize window.
         * @zh 重置窗口大小。
         * @param width The new width.
         * @param height The new height.
         */
        resize(width: number, height: number): void;
    }
}
declare module "cocos/core/pipeline/render-view" {
    /**
     * @category pipeline
     */
    import { Camera } from "cocos/core/renderer/scene/camera";
    import { RenderFlow } from "cocos/core/pipeline/render-flow";
    import { RenderWindow } from "cocos/core/pipeline/render-window";
    /**
     * @en The predefined priority of render view
     * @zh 预设渲染视图优先级。
     */
    export enum RenderViewPriority {
        GENERAL = 100
    }
    /**
     * @en Render view information descriptor
     * @zh 渲染视图描述信息。
     */
    export interface IRenderViewInfo {
        camera: Camera;
        name: string;
        priority: number;
        flows?: string[];
    }
    /**
     * @en Render target information descriptor
     * @zh 渲染目标描述信息。
     */
    export interface IRenderTargetInfo {
        width?: number;
        height?: number;
    }
    /**
     * @en Render view represents a view from its camera, it also manages a list of [[RenderFlow]]s which will be executed for it.
     * @zh 渲染视图代表了它的相机所拍摄的视图，它也管理一组在视图上执行的 [[RenderFlow]]。
     */
    export class RenderView {
        /**
         * @en Name
         * @zh 名称。
         */
        get name(): string;
        /**
         * @en The GFX window
         * @zh GFX 窗口。
         */
        get window(): RenderWindow;
        set window(val: RenderWindow);
        /**
         * @en The priority among other render views, used for sorting.
         * @zh 在所有 RenderView 中的优先级，用于排序。
         */
        get priority(): number;
        set priority(val: number);
        /**
         * @en The visibility is a mask which allows nodes in the scene be seen by the current view if their [[Node.layer]] bit is included in this mask.
         * @zh 可见性是一个掩码，如果场景中节点的 [[Node.layer]] 位被包含在该掩码中，则对应节点对该视图是可见的。
         */
        set visibility(vis: number);
        get visibility(): number;
        /**
         * @en The camera correspond to this render view
         * @zh 该视图对应的相机。
         * @readonly
         */
        get camera(): Camera;
        /**
         * @en Whether the view is enabled
         * @zh 是否启用。
         * @readonly
         */
        get isEnable(): boolean;
        /**
         * @en Render flow list
         * @zh 渲染流程列表。
         * @readonly
         */
        get flows(): RenderFlow[];
        private _name;
        private _window;
        private _priority;
        private _visibility;
        private _camera;
        private _isEnable;
        private _flows;
        /**
         * @en The constructor
         * @zh 构造函数。
         * @param camera
         */
        constructor();
        /**
         * @en Initialization function with a render view information descriptor
         * @zh 使用一个渲染视图描述信息来初始化。
         * @param info Render view information descriptor
         */
        initialize(info: IRenderViewInfo): boolean;
        /**
         * @en The destroy function
         * @zh 销毁函数。
         */
        destroy(): void;
        /**
         * @en Enable or disable this render view
         * @zh 启用或禁用该渲染视图。
         * @param isEnable Whether to enable or disable this view
         */
        enable(isEnable: boolean): void;
        /**
         * @en Set the execution render flows with their names, the flows found in the pipeline will then be executed for this view in the render process
         * @zh 使用对应的名字列表设置需要执行的渲染流程，所有在渲染管线中找到的对应渲染流程都会用来对当前视图执行渲染。
         * @param flows The names of all [[RenderFlow]]s
         */
        setExecuteFlows(flows: string[] | undefined): void;
        onGlobalPipelineStateChanged(): void;
    }
}
declare module "cocos/core/pipeline/render-stage" {
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    import { RenderFlow } from "cocos/core/pipeline/render-flow";
    /**
     * @en The render stage information descriptor
     * @zh 渲染阶段描述信息。
     */
    export interface IRenderStageInfo {
        name: string;
        priority: number;
        tag?: number;
    }
    /**
     * @en The render stage actually renders render objects to the output window or other [[GFXFrameBuffer]].
     * Typically, a render stage collects render objects it's responsible for, clear the camera,
     * record and execute command buffer, and at last present the render result.
     * @zh 渲染阶段是实质上的渲染执行者，它负责收集渲染数据并执行渲染将渲染结果输出到屏幕或其他 [[GFXFrameBuffer]] 中。
     * 典型的渲染阶段会收集它所管理的渲染对象，按照 [[Camera]] 的清除标记进行清屏，记录并执行渲染指令缓存，并最终呈现渲染结果。
     */
    export abstract class RenderStage {
        /**
         * @en Name of the current stage
         * @zh 当前渲染阶段的名字。
         */
        get name(): string;
        /**
         * @en Priority of the current stage
         * @zh 当前渲染阶段的优先级。
         */
        get priority(): number;
        /**
         * @en Tag of the current stage
         * @zh 当前渲染阶段的标签。
         */
        get tag(): number;
        /**
         * @en Name
         * @zh 名称。
         */
        protected _name: string;
        /**
         * @en Priority
         * @zh 优先级。
         */
        protected _priority: number;
        /**
         * @en Type
         * @zh 类型。
         */
        protected _tag: number;
        protected _pipeline: RenderPipeline;
        protected _flow: RenderFlow;
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render stage information
         */
        initialize(info: IRenderStageInfo): boolean;
        /**
         * @en Activate the current render stage in the given render flow
         * @zh 为指定的渲染流程开启当前渲染阶段
         * @param flow The render flow to activate this render stage
         */
        activate(pipeline: RenderPipeline, flow: RenderFlow): void;
        /**
         * @en Destroy function
         * @zh 销毁函数。
         */
        abstract destroy(): any;
        /**
         * @en Render function
         * @zh 渲染函数。
         * @param view The render view
         */
        abstract render(view: RenderView): any;
    }
}
declare module "cocos/core/pipeline/render-flow" {
    import { RenderStage } from "cocos/core/pipeline/render-stage";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    /**
     * @en Render flow information descriptor
     * @zh 渲染流程描述信息。
     */
    export interface IRenderFlowInfo {
        name: string;
        priority: number;
        tag?: number;
    }
    /**
     * @en Render flow is a sub process of the [[RenderPipeline]], it dispatch the render task to all the [[RenderStage]]s.
     * @zh 渲染流程是渲染管线（[[RenderPipeline]]）的一个子过程，它将渲染任务派发到它的所有渲染阶段（[[RenderStage]]）中执行。
     */
    export abstract class RenderFlow {
        /**
         * @en The name of the render flow
         * @zh 渲染流程的名字
         */
        get name(): string;
        /**
         * @en Priority of the current flow
         * @zh 当前渲染流程的优先级。
         */
        get priority(): number;
        /**
         * @en Tag of the current flow
         * @zh 当前渲染流程的标签。
         */
        get tag(): number;
        /**
         * @en The stages of flow.
         * @zh 渲染流程 stage 列表。
         * @readonly
         */
        get stages(): RenderStage[];
        protected _name: string;
        protected _priority: number;
        protected _tag: number;
        protected _stages: RenderStage[];
        protected _pipeline: RenderPipeline;
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render flow information
         */
        initialize(info: IRenderFlowInfo): boolean;
        /**
         * @en Activate the current render flow in the given pipeline
         * @zh 为指定的渲染管线开启当前渲染流程
         * @param pipeline The render pipeline to activate this render flow
         */
        activate(pipeline: RenderPipeline): void;
        /**
         * @en Render function, it basically run all render stages in sequence for the given view.
         * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染阶段。
         * @param view Render view。
         */
        render(view: RenderView): void;
        /**
         * @en Destroy function.
         * @zh 销毁函数。
         */
        destroy(): void;
    }
}
declare module "cocos/core/pipeline/render-pipeline" {
    import { Asset } from "cocos/core/assets/asset";
    import { RenderFlow } from "cocos/core/pipeline/render-flow";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    import { GFXDevice, GFXDescriptorSet, GFXCommandBuffer, GFXDescriptorSetLayout } from "cocos/core/gfx/index";
    import { IDescriptorSetLayoutInfo } from "cocos/core/pipeline/define";
    /**
     * @en Render pipeline information descriptor
     * @zh 渲染管线描述信息。
     */
    export interface IRenderPipelineInfo {
        flows: RenderFlow[];
        tag?: number;
    }
    /**
     * @en Render pipeline describes how we handle the rendering process for all render objects in the related render scene root.
     * It contains some general pipeline configurations, necessary rendering resources and some [[RenderFlow]]s.
     * The rendering process function [[render]] is invoked by [[Root]] for all [[RenderView]]s.
     * @zh 渲染管线对象决定了引擎对相关渲染场景下的所有渲染对象实施的完整渲染流程。
     * 这个类主要包含一些通用的管线配置，必要的渲染资源和一些 [[RenderFlow]]。
     * 渲染流程函数 [[render]] 会由 [[Root]] 发起调用并对所有 [[RenderView]] 执行预设的渲染流程。
     */
    export abstract class RenderPipeline extends Asset {
        /**
         * @en Layout of the pipeline-global descriptor set.
         * @zh 管线层的全局描述符集布局。
         * @readonly
         */
        get globalDescriptorSetLayout(): Readonly<IDescriptorSetLayoutInfo>;
        /**
         * @en Layout of the model-local descriptor set.
         * @zh 逐模型的描述符集布局。
         * @readonly
         */
        get localDescriptorSetLayout(): Readonly<IDescriptorSetLayoutInfo>;
        /**
         * @en The macros for this pipeline.
         * @zh 管线宏定义。
         * @readonly
         */
        get macros(): MacroRecord;
        /**
         * @en The flows of pipeline.
         * @zh 管线的渲染流程列表。
         * @readonly
         */
        get flows(): RenderFlow[];
        /**
         * @en The tag of pipeline.
         * @zh 管线的标签。
         * @readonly
         */
        get tag(): number;
        /**
         * @en Tag
         * @zh 标签
         * @readonly
         */
        protected _tag: number;
        /**
         * @en Flows
         * @zh 渲染流程列表
         * @readonly
         */
        protected _flows: RenderFlow[];
        protected _globalDescriptorSetLayout: IDescriptorSetLayoutInfo;
        protected _localDescriptorSetLayout: IDescriptorSetLayoutInfo;
        protected _macros: MacroRecord;
        get device(): GFXDevice;
        get descriptorSetLayout(): GFXDescriptorSetLayout;
        get descriptorSet(): GFXDescriptorSet;
        get commandBuffers(): GFXCommandBuffer[];
        protected _device: GFXDevice;
        protected _descriptorSetLayout: GFXDescriptorSetLayout;
        protected _descriptorSet: GFXDescriptorSet;
        protected _commandBuffers: GFXCommandBuffer[];
        /**
         * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
         * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
         * @param info The render pipeline information
         */
        initialize(info: IRenderPipelineInfo): boolean;
        /**
         * @en Activate the render pipeline after loaded, it mainly activate the flows
         * @zh 当渲染管线资源加载完成后，启用管线，主要是启用管线内的 flow
         */
        activate(): boolean;
        /**
         * @en Render function, it basically run the render process of all flows in sequence for the given view.
         * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染流程。
         * @param view Render view。
         */
        render(views: RenderView[]): void;
        /**
         * @en Internal destroy function
         * @zh 内部销毁函数。
         */
        destroy(): boolean;
    }
}
declare module "cocos/core/pipeline/forward/enum" {
    /**
     * @category pipeline
     */
    /**
     * @zh 前向阶段优先级。
     * @en The priority of stage in forward rendering
     */
    export enum ForwardStagePriority {
        FORWARD = 10,
        UI = 20
    }
    /**
     * @zh 前向渲染流程优先级。
     * @en The priority of flows in forward rendering
     */
    export enum ForwardFlowPriority {
        SHADOW = 0,
        FORWARD = 1,
        UI = 10
    }
}
declare module "cocos/core/pipeline/pass-phase" {
    /**
     * @hidden
     */
    export const getPhaseID: (phaseName: string | number) => number;
}
declare module "cocos/core/pipeline/render-queue" {
    /**
     * @category pipeline
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { CachedArray } from "cocos/core/memop/cached-array";
    import { IRenderObject, IRenderPass, IRenderQueueDesc } from "cocos/core/pipeline/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXRenderPass } from "cocos/core/gfx/index";
    /**
     * @en Comparison sorting function. Opaque objects are sorted by priority -> depth front to back -> shader ID.
     * @zh 比较排序函数。不透明对象按优先级 -> 深度由前向后 -> Shader ID 顺序排序。
     */
    export function opaqueCompareFn(a: IRenderPass, b: IRenderPass): number;
    /**
     * @en Comparison sorting function. Transparent objects are sorted by priority -> depth back to front -> shader ID.
     * @zh 比较排序函数。半透明对象按优先级 -> 深度由后向前 -> Shader ID 顺序排序。
     */
    export function transparentCompareFn(a: IRenderPass, b: IRenderPass): number;
    /**
     * @en The render queue. It manages a [[GFXRenderPass]] queue which will be executed by the [[RenderStage]].
     * @zh 渲染队列。它管理一个 [[GFXRenderPass]] 队列，队列中的渲染过程会被 [[RenderStage]] 所执行。
     */
    export class RenderQueue {
        /**
         * @en A cached array of render passes
         * @zh 基于缓存数组的渲染过程队列。
         */
        queue: CachedArray<IRenderPass>;
        private _passDesc;
        private _passPool;
        /**
         * @en Construct a RenderQueue with render queue descriptor
         * @zh 利用渲染队列描述来构造一个 RenderQueue。
         * @param desc Render queue descriptor
         */
        constructor(desc: IRenderQueueDesc);
        /**
         * @en Clear the render queue
         * @zh 清空渲染队列。
         */
        clear(): void;
        /**
         * @en Insert a render pass into the queue
         * @zh 插入渲染过程。
         * @param renderObj The render object of the pass
         * @param modelIdx The model id
         * @param passIdx The pass id
         * @returns Whether the new render pass is successfully added
         */
        insertRenderPass(renderObj: IRenderObject, subModelIdx: number, passIdx: number): boolean;
        /**
         * @en Sort the current queue
         * @zh 排序渲染队列。
         */
        sort(): void;
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
    }
}
declare module "cocos/core/pipeline/ui/ui-stage" {
    import { IRenderStageInfo, RenderStage } from "cocos/core/pipeline/render-stage";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { UIFlow } from "cocos/core/pipeline/ui/ui-flow";
    import { ForwardPipeline } from "cocos/core/pipeline/forward/forward-pipeline";
    import { RenderQueueDesc } from "cocos/core/pipeline/pipeline-serialization";
    import { RenderQueue } from "cocos/core/pipeline/render-queue";
    /**
     * @en The UI render stage
     * @zh UI渲阶段。
     */
    export class UIStage extends RenderStage {
        static initInfo: IRenderStageInfo;
        protected renderQueues: RenderQueueDesc[];
        protected _renderQueues: RenderQueue[];
        private _renderArea;
        initialize(info: IRenderStageInfo): boolean;
        activate(pipeline: ForwardPipeline, flow: UIFlow): void;
        destroy(): void;
        render(view: RenderView): void;
    }
}
declare module "cocos/core/pipeline/ui/ui-flow" {
    import { IRenderFlowInfo, RenderFlow } from "cocos/core/pipeline/render-flow";
    import { RenderView } from "cocos/core/pipeline/render-view";
    /**
     * @en The UI render flow
     * @zh UI渲染流程。
     */
    export class UIFlow extends RenderFlow {
        static initInfo: IRenderFlowInfo;
        initialize(info: IRenderFlowInfo): boolean;
        destroy(): void;
        render(view: RenderView): void;
    }
}
declare module "cocos/core/pipeline/pipeline-funcs" {
    /**
     * @category pipeline
     */
    import { GFXColor } from "cocos/core/gfx/define";
    /**
     * @en Convert color in SRGB space to linear space
     * @zh SRGB 颜色空间转换为线性空间。
     * @param out Output color object
     * @param gamma Gamma value in SRGB space
     */
    export function SRGBToLinear(out: GFXColor, gamma: GFXColor): void;
    /**
     * @en Convert color in linear space to SRGB space
     * @zh 线性空间转换为 SRGB 颜色空间。
     * @param out Output color object
     * @param linear Color value in linear space
     */
    export function LinearToSRGB(out: GFXColor, linear: GFXColor): void;
}
declare module "cocos/core/pipeline/batched-buffer" {
    /**
     * @hidden
     */
    import { GFXDescriptorSet } from "cocos/core/gfx/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { SubModel } from "cocos/core/renderer/scene/submodel";
    import { IRenderObject } from "cocos/core/pipeline/define";
    import { Pass } from "cocos/core/renderer/index";
    import { PassHandle, ShaderHandle } from "cocos/core/renderer/core/memory-pools";
    export interface IBatchedItem {
        vbs: GFXBuffer[];
        vbDatas: Uint8Array[];
        vbIdx: GFXBuffer;
        vbIdxData: Float32Array;
        vbCount: number;
        mergeCount: number;
        ia: GFXInputAssembler;
        ubo: GFXBuffer;
        uboData: Float32Array;
        descriptorSet: GFXDescriptorSet;
        hPass: PassHandle;
        hShader: ShaderHandle;
    }
    export class BatchedBuffer {
        private static _buffers;
        static get(pass: Pass, extraKey?: number): BatchedBuffer;
        batches: IBatchedItem[];
        dynamicOffsets: number[];
        private _device;
        constructor(pass: Pass);
        destroy(): void;
        merge(subModel: SubModel, passIdx: number, ro: IRenderObject): void;
        clear(): void;
    }
}
declare module "cocos/core/pipeline/render-batched-queue" {
    /**
     * @category pipeline
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { BatchedBuffer } from "cocos/core/pipeline/batched-buffer";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXRenderPass } from "cocos/core/gfx/index";
    /**
     * @en The render queue for dynamic batching
     * @zh 渲染合批队列。
     */
    export class RenderBatchedQueue {
        /**
         * @en A set of dynamic batched buffer
         * @zh 动态合批缓存集合。
         */
        queue: Set<BatchedBuffer>;
        /**
         * @en Clear the render queue
         * @zh 清空渲染队列。
         */
        clear(): void;
        /**
         * @en Record command buffer for the current queue
         * @zh 记录命令缓冲。
         * @param cmdBuff The command buffer to store the result
         */
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
    }
}
declare module "cocos/core/pipeline/render-instanced-queue" {
    /**
     * @category pipeline
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { InstancedBuffer } from "cocos/core/pipeline/instanced-buffer";
    import { GFXDevice, GFXRenderPass } from "cocos/core/gfx/index";
    /**
     * @en Render queue for instanced batching
     * @zh 渲染合批队列。
     */
    export class RenderInstancedQueue {
        /**
         * @en A set of instanced buffer
         * @zh Instance 合批缓存集合。
         */
        queue: Set<InstancedBuffer>;
        /**
         * @en Clear the render queue
         * @zh 清空渲染队列。
         */
        clear(): void;
        /**
         * @en Record command buffer for the current queue
         * @zh 记录命令缓冲。
         * @param cmdBuff The command buffer to store the result
         */
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
    }
}
declare module "predefine" {
    import { legacyCC } from "cocos/core/global-exports";
    export default legacyCC;
}
declare module "cocos/core/legacy" { }
declare module "extensions/ccpool/node-pool" {
    /**
     * @hidden
     */
    import { Component } from "cocos/core/components/component";
    import { Node } from "cocos/core/scene-graph/index";
    /****************************************************************************
     Copyright (c) 2016 Chukong Technologies Inc.
     Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
    
     http://www.cocos2d-x.org
    
     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:
    
     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.
    
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
     ****************************************************************************/
    type Constructor<T = {}> = new (...args: any[]) => T;
    interface IPoolHandlerComponent extends Component {
        unuse(): void;
        reuse(args: any): void;
    }
    /**
     * @en
     *  `NodePool` is the cache pool designed for node type.<br/>
     *  It can helps you to improve your game performance for objects which need frequent release and recreate operations<br/>
     *
     * It's recommended to create `NodePool` instances by node type, the type corresponds to node type in game design, not the class,
     * for example, a prefab is a specific node type. <br/>
     * When you create a node pool, you can pass a Component which contains `unuse`, `reuse` functions to control the content of node.<br/>
     *
     * Some common use case is :<br/>
     *      1. Bullets in game (die very soon, massive creation and recreation, no side effect on other objects)<br/>
     *      2. Blocks in candy crash (massive creation and recreation)<br/>
     *      etc...
     * @zh
     * `NodePool` 是用于管理节点对象的对象缓存池。<br/>
     * 它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁<br/>
     * 以前 cocos2d-x 中的 pool 和新的节点事件注册系统不兼容，因此请使用 `NodePool` 来代替。
     *
     * 新的 NodePool 需要实例化之后才能使用，每种不同的节点对象池需要一个不同的对象池实例，这里的种类对应于游戏中的节点设计，一个 prefab 相当于一个种类的节点。<br/>
     * 在创建缓冲池时，可以传入一个包含 unuse, reuse 函数的组件类型用于节点的回收和复用逻辑。<br/>
     *
     * 一些常见的用例是：<br/>
     *      1.在游戏中的子弹（死亡很快，频繁创建，对其他对象无副作用）<br/>
     *      2.糖果粉碎传奇中的木块（频繁创建）。
     *      等等....
     */
    export class NodePool {
        /**
         * @en The pool handler component, it could be the class name or the constructor.
         * @zh 缓冲池处理组件，用于节点的回收和复用逻辑，这个属性可以是组件类名或组件的构造函数。
         */
        poolHandlerComp?: Constructor<IPoolHandlerComponent> | string;
        private _pool;
        /**
         * @en
         * Constructor for creating a pool for a specific node template (usually a prefab).
         * You can pass a component (type or name) argument for handling event for reusing and recycling node.
         * @zh
         * 使用构造函数来创建一个节点专用的对象池，您可以传递一个组件类型或名称，用于处理节点回收和复用时的事件逻辑。
         * @param poolHandlerComp @en The constructor or the class name of the component to control the unuse/reuse logic. @zh 处理节点回收和复用事件逻辑的组件类型或名称。
         * @example
         * import { NodePool, Prefab } from 'cc';
         *  properties: {
         *      template: Prefab
         *     },
         *     onLoad () {
         *       // MyTemplateHandler is a component with 'unuse' and 'reuse' to handle events when node is reused or recycled.
         *       this.myPool = new NodePool('MyTemplateHandler');
         *     }
         *  }
         */
        constructor(poolHandlerComp?: Constructor<IPoolHandlerComponent> | string);
        /**
         * @en The current available size in the pool
         * @zh 获取当前缓冲池的可用对象数量
         */
        size(): number;
        /**
         * @en Destroy all cached nodes in the pool
         * @zh 销毁对象池中缓存的所有节点
         */
        clear(): void;
        /**
         * @en Put a new Node into the pool.
         * It will automatically remove the node from its parent without cleanup.
         * It will also invoke unuse method of the poolHandlerComp if exist.
         * @zh 向缓冲池中存入一个不再需要的节点对象。
         * 这个函数会自动将目标节点从父节点上移除，但是不会进行 cleanup 操作。
         * 这个函数会调用 poolHandlerComp 的 unuse 函数，如果组件和函数都存在的话。
         * @example
         * import { instantiate } from 'cc';
         * const myNode = instantiate(this.template);
         * this.myPool.put(myNode);
         */
        put(obj: Node): void;
        /**
         * @en Get a obj from pool, if no available object in pool, null will be returned.
         * This function will invoke the reuse function of poolHandlerComp if exist.
         * @zh 获取对象池中的对象，如果对象池没有可用对象，则返回空。
         * 这个函数会调用 poolHandlerComp 的 reuse 函数，如果组件和函数都存在的话。
         * @param args - 向 poolHandlerComp 中的 'reuse' 函数传递的参数
         * @example
         *   let newNode = this.myPool.get();
         */
        get(...args: any[]): Node | null;
    }
}
declare module "cocos/core/primitive/primitive" {
    import { Mesh } from "cocos/core/assets/mesh";
    enum PrimitiveType {
        BOX = 0,
        SPHERE = 1,
        CYLINDER = 2,
        CONE = 3,
        CAPSULE = 4,
        TORUS = 5,
        PLANE = 6,
        QUAD = 7
    }
    /**
     * @en
     * Basic primitive mesh, this can be generate some primitive mesh at runtime.
     * @zh
     * 基础图形网格，可以在运行时构建一些基础的网格。
     */
    export class Primitive extends Mesh {
        static PrimitiveType: typeof PrimitiveType;
        /**
         * @en
         * The type of the primitive mesh, set it before you call onLoaded.
         * @zh
         * 此基础图形网格的类型，请在 onLoaded 调用之前设置。
         */
        type: number;
        /**
         * @en
         * The option for build the primitive mesh, set it before you call onLoaded.
         * @zh
         * 创建此基础图形网格的可选参数，请在 onLoaded 调用之前设置。
         */
        info: Record<string, number>;
        constructor(type?: PrimitiveType);
        /**
         * @en
         * Construct the primitive mesh with `type` and `info`.
         * @zh
         * 根据`type`和`info`构建相应的网格。
         */
        onLoaded(): void;
    }
    export namespace Primitive {
        type PrimitiveType = EnumAlias<typeof PrimitiveType>;
    }
}
declare module "exports/base" {
    /**
     * @hidden
     */
    import { legacyCC } from "cocos/core/global-exports";
    import "predefine";
    import "cocos/core/legacy";
    export * from "cocos/core/index";
    import * as renderer from "cocos/core/renderer/index";
    export { renderer };
    export * from "extensions/ccpool/node-pool";
    export { legacyCC as cclegacy };
    import * as primitives from "cocos/core/primitive/index";
    export { primitives, };
    export * from "cocos/core/primitive/primitive";
}
declare module "cocos/core/pipeline/render-additive-light-queue" {
    /**
     * @category pipeline
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { GFXDevice, GFXRenderPass } from "cocos/core/gfx/index";
    import { ForwardPipeline } from "exports/base";
    /**
     * @zh 叠加光照队列。
     */
    export class RenderAdditiveLightQueue {
        private _device;
        private _validLights;
        private _lightPasses;
        private _lightBufferCount;
        private _lightBufferStride;
        private _lightBufferElementCount;
        private _lightBuffer;
        private _firstlightBufferView;
        private _lightBufferData;
        private _isHDR;
        private _fpScale;
        private _renderObjects;
        private _instancedQueue;
        private _batchedQueue;
        private _lightMeterScale;
        constructor(pipeline: ForwardPipeline);
        gatherLightPasses(view: RenderView): void;
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
        protected _updateUBOs(view: RenderView): void;
    }
}
declare module "cocos/core/pipeline/forward/forward-stage" {
    import { RenderQueue } from "cocos/core/pipeline/render-queue";
    import { IRenderStageInfo, RenderStage } from "cocos/core/pipeline/render-stage";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { ForwardFlow } from "cocos/core/pipeline/forward/forward-flow";
    import { ForwardPipeline } from "cocos/core/pipeline/forward/forward-pipeline";
    import { RenderQueueDesc } from "cocos/core/pipeline/pipeline-serialization";
    /**
     * @en The forward render stage
     * @zh 前向渲染阶段。
     */
    export class ForwardStage extends RenderStage {
        static initInfo: IRenderStageInfo;
        protected renderQueues: RenderQueueDesc[];
        protected _renderQueues: RenderQueue[];
        private _renderArea;
        private _batchedQueue;
        private _instancedQueue;
        private _phaseID;
        private _additiveLightQueue;
        constructor();
        initialize(info: IRenderStageInfo): boolean;
        activate(pipeline: ForwardPipeline, flow: ForwardFlow): void;
        destroy(): void;
        render(view: RenderView): void;
        /**
         * @en Clear the given render queue
         * @zh 清空指定的渲染队列
         * @param rq The render queue
         */
        protected renderQueueClearFunc(rq: RenderQueue): void;
        /**
         * @en Sort the given render queue
         * @zh 对指定的渲染队列执行排序
         * @param rq The render queue
         */
        protected renderQueueSortFunc(rq: RenderQueue): void;
    }
}
declare module "cocos/core/pipeline/forward/forward-flow" {
    import { IRenderFlowInfo, RenderFlow } from "cocos/core/pipeline/render-flow";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    /**
     * @en The forward flow in forward render pipeline
     * @zh 前向渲染流程。
     */
    export class ForwardFlow extends RenderFlow {
        /**
         * @en The shared initialization information of forward render flow
         * @zh 共享的前向渲染流程初始化参数
         */
        static initInfo: IRenderFlowInfo;
        initialize(info: IRenderFlowInfo): boolean;
        activate(pipeline: RenderPipeline): void;
        render(view: RenderView): void;
        destroy(): void;
    }
}
declare module "cocos/core/pipeline/render-shadowMap-batched-queue" {
    /**
     * @category pipeline
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { IRenderObject } from "cocos/core/pipeline/define";
    import { GFXDevice, GFXRenderPass, GFXBuffer } from "cocos/core/gfx/index";
    /**
     * @zh
     * 阴影渲染队列
     */
    export class RenderShadowMapBatchedQueue {
        private _subModelsArray;
        private _passArray;
        private _shaderArray;
        private _shadowMapBuffer;
        private _phaseID;
        private _instancedQueue;
        private _batchedQueue;
        /**
         * @zh
         * clear ligth-Batched-Queue
         */
        clear(shadowMapBuffer: GFXBuffer): void;
        add(renderObj: IRenderObject, subModelIdx: number, passIdx: number): void;
        /**
         * @zh
         * record CommandBuffer
         */
        recordCommandBuffer(device: GFXDevice, renderPass: GFXRenderPass, cmdBuff: GFXCommandBuffer): void;
    }
}
declare module "cocos/core/pipeline/shadow/shadow-stage" {
    import { IRenderStageInfo, RenderStage } from "cocos/core/pipeline/render-stage";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    /**
     * @zh
     * 阴影渲染阶段。
     */
    export class ShadowStage extends RenderStage {
        static initInfo: IRenderStageInfo;
        setShadowFrameBuffer(shadowFrameBuffer: GFXFramebuffer): void;
        private _additiveShadowQueue;
        private _shadowFrameBuffer;
        private _renderArea;
        /**
         * 构造函数。
         * @param flow 渲染阶段。
         */
        constructor();
        /**
         * @zh
         * 销毁函数。
         */
        destroy(): void;
        /**
         * @zh
         * 渲染函数。
         * @param view 渲染视图。
         */
        render(view: RenderView): void;
    }
}
declare module "cocos/core/pipeline/shadow/shadow-flow" {
    import { IRenderFlowInfo, RenderFlow } from "cocos/core/pipeline/render-flow";
    import { GFXFramebuffer } from "cocos/core/gfx/index";
    import { RenderView, ForwardPipeline } from "cocos/core/index";
    /**
     * @zh 阴影贴图绘制流程
     */
    export class ShadowFlow extends RenderFlow {
        get shadowFrameBuffer(): GFXFramebuffer | null;
        static initInfo: IRenderFlowInfo;
        private _shadowRenderPass;
        private _shadowRenderTargets;
        private _shadowFrameBuffer;
        private _depth;
        private _width;
        private _height;
        initialize(info: IRenderFlowInfo): boolean;
        activate(pipeline: ForwardPipeline): void;
        render(view: RenderView): void;
        private resizeShadowMap;
    }
}
declare module "cocos/core/pipeline/forward/scene-culling" {
    import { ForwardPipeline } from "cocos/core/pipeline/forward/forward-pipeline";
    import { RenderView } from "cocos/core/pipeline/render-view";
    export function sceneCulling(pipeline: ForwardPipeline, view: RenderView): void;
}
declare module "cocos/core/pipeline/forward/forward-pipeline" {
    import { RenderPipeline, IRenderPipelineInfo } from "cocos/core/pipeline/render-pipeline";
    import { RenderTextureConfig, MaterialConfig } from "cocos/core/pipeline/pipeline-serialization";
    import { IRenderObject } from "cocos/core/pipeline/define";
    import { GFXClearFlag } from "cocos/core/gfx/define";
    import { GFXRenderPass } from "cocos/core/gfx/index";
    import { RenderView } from "cocos/core/pipeline/render-view";
    import { Fog } from "cocos/core/renderer/scene/fog";
    import { Ambient } from "cocos/core/renderer/scene/ambient";
    import { Skybox } from "cocos/core/renderer/scene/skybox";
    import { Shadows } from "cocos/core/renderer/scene/shadows";
    /**
     * @en The forward render pipeline
     * @zh 前向渲染管线。
     */
    export class ForwardPipeline extends RenderPipeline {
        get isHDR(): boolean;
        set isHDR(val: boolean);
        get shadingScale(): number;
        get fpScale(): number;
        /**
         * @en Get shadow UBO.
         * @zh 获取阴影UBO。
         */
        get shadowUBO(): Float32Array;
        protected renderTextures: RenderTextureConfig[];
        protected materials: MaterialConfig[];
        fog: Fog;
        ambient: Ambient;
        skybox: Skybox;
        shadows: Shadows;
        /**
         * @en The list for render objects, only available after the scene culling of the current frame.
         * @zh 渲染对象数组，仅在当前帧的场景剔除完成后有效。
         * @readonly
         */
        renderObjects: IRenderObject[];
        shadowObjects: IRenderObject[];
        protected _isHDR: boolean;
        protected _shadingScale: number;
        protected _fpScale: number;
        protected _renderPasses: Map<GFXClearFlag, GFXRenderPass>;
        protected _globalUBO: Float32Array;
        protected _shadowUBO: Float32Array;
        initialize(info: IRenderPipelineInfo): boolean;
        activate(): boolean;
        render(views: RenderView[]): void;
        getRenderPass(clearFlags: GFXClearFlag): GFXRenderPass;
        /**
         * @en Update all UBOs
         * @zh 更新全部 UBO。
         */
        updateUBOs(view: RenderView): void;
        private _activeRenderer;
        private _updateUBO;
        private destroyUBOs;
        destroy(): boolean;
    }
}
declare module "cocos/core/root" {
    import { GFXDevice } from "cocos/core/gfx/device";
    import { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    import { IRenderViewInfo, RenderView } from "cocos/core/pipeline/render-view";
    import { Camera, Light, Model } from "cocos/core/renderer/scene/index";
    import { DataPoolManager } from "cocos/core/renderer/data-pool-manager";
    import { IRenderSceneInfo, RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { UI } from "cocos/core/renderer/ui/ui";
    import { RenderWindow, IRenderWindowInfo } from "cocos/core/pipeline/render-window";
    /**
     * @zh
     * Root描述信息
     */
    export interface IRootInfo {
        enableHDR?: boolean;
    }
    /**
     * @zh
     * 场景描述信息
     */
    export interface ISceneInfo {
        name: string;
    }
    /**
     * @zh
     * Root类
     */
    export class Root {
        /**
         * @zh
         * GFX设备
         */
        get device(): GFXDevice;
        /**
         * @zh
         * 主窗口
         */
        get mainWindow(): RenderWindow | null;
        /**
         * @zh
         * 当前窗口
         */
        set curWindow(window: RenderWindow | null);
        get curWindow(): RenderWindow | null;
        /**
         * @zh
         * 临时窗口（用于数据传输）
         */
        set tempWindow(window: RenderWindow | null);
        get tempWindow(): RenderWindow | null;
        /**
         * @zh
         * 窗口列表
         */
        get windows(): RenderWindow[];
        /**
         * @zh
         * 渲染管线
         */
        get pipeline(): RenderPipeline;
        /**
         * @zh
         * UI实例
         */
        get ui(): UI;
        /**
         * @zh
         * 场景列表
         */
        get scenes(): RenderScene[];
        /**
         * @zh
         * 累计时间（秒）
         */
        get cumulativeTime(): number;
        /**
         * @zh
         * 帧时间（秒）
         */
        get frameTime(): number;
        /**
         * @zh
         * 一秒内的累计帧数
         */
        get frameCount(): number;
        /**
         * @zh
         * 每秒帧率
         */
        get fps(): number;
        /**
         * @zh
         * 每秒固定帧率
         */
        set fixedFPS(fps: number);
        get fixedFPS(): number;
        get dataPoolManager(): DataPoolManager;
        _createSceneFun: (root: Root) => RenderScene;
        _createWindowFun: (root: Root) => RenderWindow;
        private _device;
        private _windows;
        private _mainWindow;
        private _curWindow;
        private _tempWindow;
        private _pipeline;
        private _ui;
        private _dataPoolMgr;
        private _scenes;
        private _cameras;
        private _views;
        private _modelPools;
        private _cameraPool;
        private _lightPools;
        private _time;
        private _frameTime;
        private _fpsTime;
        private _frameCount;
        private _fps;
        private _fixedFPS;
        private _fixedFPSFrameTime;
        /**
         * 构造函数
         * @param device GFX设备
         */
        constructor(device: GFXDevice);
        /**
         * @zh
         * 初始化函数
         * @param info Root描述信息
         */
        initialize(info: IRootInfo): boolean;
        destroy(): void;
        /**
         * @zh
         * 重置大小
         * @param width 屏幕宽度
         * @param height 屏幕高度
         */
        resize(width: number, height: number): void;
        setRenderPipeline(rppl: RenderPipeline): boolean;
        onGlobalPipelineStateChanged(): void;
        /**
         * @zh
         * 激活指定窗口为当前窗口
         * @param window GFX窗口
         */
        activeWindow(window: RenderWindow): void;
        /**
         * @zh
         * 重置累计时间
         */
        resetCumulativeTime(): void;
        /**
         * @zh
         * 每帧执行函数
         * @param deltaTime 间隔时间
         */
        frameMove(deltaTime: number): void;
        /**
         * @zh
         * 创建窗口
         * @param info GFX窗口描述信息
         */
        createWindow(info: IRenderWindowInfo): RenderWindow | null;
        /**
         * @zh
         * 销毁指定的窗口
         * @param window GFX窗口
         */
        destroyWindow(window: RenderWindow): void;
        /**
         * @zh
         * 销毁全部窗口
         */
        destroyWindows(): void;
        /**
         * @zh
         * 创建渲染场景
         * @param info 渲染场景描述信息
         */
        createScene(info: IRenderSceneInfo): RenderScene;
        /**
         * @zh
         * 销毁指定的渲染场景
         * @param scene 渲染场景
         */
        destroyScene(scene: RenderScene): void;
        /**
         * @zh
         * 销毁全部场景
         */
        destroyScenes(): void;
        /**
         * @zh
         * 创建渲染视图
         * @param info 渲染视图描述信息
         */
        createView(info: IRenderViewInfo): RenderView;
        /**
         * @zh
         * 添加渲染相机
         * @param camera 渲染相机
         */
        attachCamera(camera: Camera): void;
        /**
         * @zh
         * 移除渲染相机
         * @param camera 相机
         */
        detachCamera(camera: Camera): void;
        /**
         * @zh
         * 销毁全部渲染相机
         */
        clearCameras(): void;
        createModel<T extends Model>(mClass: typeof Model): T;
        destroyModel(m: Model): void;
        createCamera(): Camera;
        destroyCamera(c: Camera): void;
        createLight<T extends Light>(lClass: new () => T): T;
        destroyLight(l: Light): void;
        sortViews(): void;
    }
}
declare module "cocos/core/assets/effect-asset" {
    import { GFXDynamicStateFlags, GFXPrimitiveMode } from "cocos/core/gfx/define";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    import { GFXUniformBlock, GFXUniformSampler } from "cocos/core/gfx/shader";
    import { RenderPassStage } from "cocos/core/pipeline/define";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    import { Asset } from "cocos/core/assets/asset";
    import { IGFXDescriptorSetLayoutBinding } from "cocos/core/gfx/index";
    export interface IPropertyInfo {
        type: number;
        handleInfo?: [string, number, number];
        samplerHash?: number;
        value?: number[] | string;
    }
    export interface IPassStates {
        priority?: number;
        primitive?: GFXPrimitiveMode;
        stage?: RenderPassStage;
        rasterizerState?: GFXRasterizerState;
        depthStencilState?: GFXDepthStencilState;
        blendState?: GFXBlendState;
        dynamicStates?: GFXDynamicStateFlags;
        phase?: string | number;
    }
    export interface IPassInfo extends IPassStates {
        program: string;
        embeddedMacros?: MacroRecord;
        propertyIndex?: number;
        switch?: string;
        properties?: Record<string, IPropertyInfo>;
    }
    export interface ITechniqueInfo {
        passes: IPassInfo[];
        name?: string;
    }
    export interface IBlockInfo extends GFXUniformBlock, IGFXDescriptorSetLayoutBinding {
    }
    export interface ISamplerInfo extends GFXUniformSampler, IGFXDescriptorSetLayoutBinding {
    }
    export interface IAttributeInfo extends IGFXAttribute {
        defines: string[];
    }
    export interface IDefineInfo {
        name: string;
        type: string;
        range?: number[];
        options?: string[];
        default?: string;
    }
    export interface IBuiltin {
        name: string;
        defines: string[];
    }
    export interface IBuiltinInfo {
        blocks: IBuiltin[];
        samplers: IBuiltin[];
    }
    export interface IShaderInfo {
        name: string;
        hash: number;
        glsl4: {
            vert: string;
            frag: string;
        };
        glsl3: {
            vert: string;
            frag: string;
        };
        glsl1: {
            vert: string;
            frag: string;
        };
        builtins: {
            globals: IBuiltinInfo;
            locals: IBuiltinInfo;
        };
        defines: IDefineInfo[];
        blocks: IBlockInfo[];
        samplers: ISamplerInfo[];
        attributes: IAttributeInfo[];
    }
    export interface IPreCompileInfo {
        [name: string]: boolean[] | number[] | string[];
    }
    /**
     * @zh
     * Effect 资源，作为材质实例初始化的模板，每个 effect 资源都应是全局唯一的。
     */
    export class EffectAsset extends Asset {
        /**
         * @zh
         * 将指定 effect 注册到全局管理器。
         */
        static register(asset: EffectAsset): void;
        /**
         * @zh
         * 将指定 effect 从全局管理器移除。
         */
        static remove(name: string): void;
        /**
         * @zh
         * 获取指定名字的 effect 资源。
         */
        static get(name: string): EffectAsset | null;
        /**
         * @zh
         * 获取所有已注册的 effect 资源。
         */
        static getAll(): Record<string, EffectAsset>;
        protected static _effects: Record<string, EffectAsset>;
        /**
         * @zh
         * 当前 effect 的所有可用 technique。
         */
        techniques: ITechniqueInfo[];
        /**
         * @zh
         * 当前 effect 使用的所有 shader。
         */
        shaders: IShaderInfo[];
        /**
         * @zh
         * 每个 shader 需要预编译的宏定义组合。
         */
        combinations: IPreCompileInfo[];
        /**
         * @zh
         * 通过 Loader 加载完成时的回调，将自动注册 effect 资源。
         */
        onLoaded(): void;
        protected _precompile(): void;
    }
}
declare module "cocos/core/renderer/core/pass" {
    import { IPassInfo, IPassStates, IPropertyInfo } from "cocos/core/assets/effect-asset";
    import { GFXDescriptorSet } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    import { GFXSampler } from "cocos/core/gfx/sampler";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { RenderPassStage } from "cocos/core/pipeline/define";
    import { Root } from "cocos/core/root";
    import { IProgramInfo } from "cocos/core/renderer/core/program-lib";
    import { PassHandle, ShaderHandle } from "cocos/core/renderer/core/memory-pools";
    import { getBindingFromHandle, getPropertyTypeFromHandle, getOffsetFromHandle, getTypeFromHandle, MacroRecord, MaterialProperty, PropertyType } from "cocos/core/renderer/core/pass-utils";
    import { GFXPrimitiveMode, GFXType, GFXDynamicStateFlagBit } from "cocos/core/gfx/define";
    export interface IPassInfoFull extends IPassInfo {
        passIndex: number;
        defines: MacroRecord;
        stateOverrides?: PassOverrides;
    }
    export type PassOverrides = RecursivePartial<IPassStates>;
    export interface IMacroPatch {
        name: string;
        value: boolean | number | string;
    }
    interface IPassDynamics {
        [type: number]: {
            dirty: boolean;
            value: number[];
        };
    }
    export enum BatchingSchemes {
        INSTANCING = 1,
        VB_MERGING = 2
    }
    export namespace Pass {
        type getPropertyTypeFromHandle = typeof getPropertyTypeFromHandle;
        type getTypeFromHandle = typeof getTypeFromHandle;
        type getBindingFromHandle = typeof getBindingFromHandle;
        type fillPipelineInfo = typeof Pass.fillPipelineInfo;
        type getPassHash = typeof Pass.getPassHash;
        type getOffsetFromHandle = typeof getOffsetFromHandle;
        type PropertyType = typeof PropertyType;
    }
    /**
     * @zh
     * 渲染 pass，储存实际描述绘制过程的各项资源。
     */
    export class Pass {
        /**
         * @zh
         * 根据 handle 获取 unform 的绑定类型（UBO 或贴图等）。
         */
        static PropertyType: typeof PropertyType;
        static getPropertyTypeFromHandle: (handle: number) => number;
        /**
         * @zh
         * 根据 handle 获取 UBO member 的具体类型。
         */
        static getTypeFromHandle: (handle: number) => number;
        /**
         * @zh
         * 根据 handle 获取 binding。
         */
        static getBindingFromHandle: (handle: number) => number;
        static fillPipelineInfo(hPass: PassHandle, info: PassOverrides): void;
        /**
         * @en
         * Get pass hash value by [[Pass]] hash information.
         * @zh
         * 根据 [[Pass]] 的哈希信息获取哈希值。
         *
         * @param hPass Handle of the pass info used to compute hash value.
         */
        static getPassHash(hPass: PassHandle, hShader: ShaderHandle): number;
        protected static getOffsetFromHandle: (handle: number) => number;
        protected _rootBuffer: GFXBuffer | null;
        protected _rootBufferDirty: boolean;
        protected _buffers: GFXBuffer[];
        protected _descriptorSet: GFXDescriptorSet;
        protected _passIndex: number;
        protected _propertyIndex: number;
        protected _programName: string;
        protected _dynamics: IPassDynamics;
        protected _propertyHandleMap: Record<string, number>;
        protected _rootBlock: ArrayBuffer | null;
        protected _blocks: Float32Array[];
        protected _shaderInfo: IProgramInfo;
        protected _defines: MacroRecord;
        protected _properties: Record<string, IPropertyInfo>;
        protected _root: Root;
        protected _device: GFXDevice;
        protected _hShaderDefault: ShaderHandle;
        protected _handle: PassHandle;
        constructor(root: Root);
        /**
         * @zh
         * 根据指定参数初始化当前 pass，shader 会在这一阶段就尝试编译。
         */
        initialize(info: IPassInfoFull): void;
        /**
         * @en
         * Get the handle of a UBO member, or specific channels of it.
         * @zh
         * 获取指定 UBO 成员，或其更具体分量的读写句柄。默认以成员自身的类型为目标读写类型（即读写时必须传入与成员类型相同的变量）。
         * @param name Name of the target UBO member.
         * @param offset Channel offset into the member.
         * @param targetType Target type of the handle, i.e. the type of data when read/write to it.
         * @example
         * ```
         * import { Vec3, GFXType } from 'cc';
         * // say 'pbrParams' is a uniform vec4
         * const hParams = pass.getHandle('pbrParams'); // get the default handle
         * pass.setUniform(hAlbedo, new Vec3(1, 0, 0)); // wrong! pbrParams.w is NaN now
         *
         * // say 'albedoScale' is a uniform vec4, and we only want to modify the w component in the form of a single float
         * const hThreshold = pass.getHandle('albedoScale', 3, GFXType.FLOAT);
         * pass.setUniform(hThreshold, 0.5); // now, albedoScale.w = 0.5
         * ```
         */
        getHandle(name: string, offset?: number, targetType?: GFXType): number;
        /**
         * @zh
         * 获取指定 uniform 的 binding。
         * @param name 目标 uniform 名。
         */
        getBinding(name: string): number;
        /**
         * @zh
         * 设置指定普通向量类 uniform 的值，如果需要频繁更新请尽量使用此接口。
         * @param handle 目标 uniform 的 handle。
         * @param value 目标值。
         */
        setUniform(handle: number, value: MaterialProperty): void;
        /**
         * @zh
         * 获取指定普通向量类 uniform 的值。
         * @param handle 目标 uniform 的 handle。
         * @param out 输出向量。
         */
        getUniform(handle: number, out: MaterialProperty): any;
        /**
         * @zh
         * 设置指定数组类 uniform 的值，如果需要频繁更新请尽量使用此接口。
         * @param handle 目标 uniform 的 handle。
         * @param value 目标值。
         */
        setUniformArray(handle: number, value: MaterialProperty[]): void;
        /**
         * @zh
         * 绑定实际 [[GFXTexture]] 到指定 binding。
         * @param binding 目标贴图类 uniform 的 binding。
         * @param value 目标 texture
         */
        bindTexture(binding: number, value: GFXTexture, index?: number): void;
        /**
         * @zh
         * 绑定实际 [[GFXSampler]] 到指定 binding。
         * @param binding 目标贴图类 uniform 的 binding。
         * @param value 目标 sampler。
         */
        bindSampler(binding: number, value: GFXSampler, index?: number): void;
        /**
         * @zh
         * 设置运行时 pass 内可动态更新的管线状态属性。
         * @param state 目标管线状态。
         * @param value 目标值。
         */
        setDynamicState(state: GFXDynamicStateFlagBit, value: any): void;
        /**
         * @zh
         * 重载当前所有管线状态。
         * @param original 原始管线状态。
         * @param value 管线状态重载值。
         */
        overridePipelineStates(original: IPassInfo, overrides: PassOverrides): void;
        /**
         * @zh
         * 更新当前 Uniform 数据。
         */
        update(): void;
        /**
         * @zh
         * 销毁当前 pass。
         */
        destroy(): void;
        /**
         * @zh
         * 重置指定（非数组） Uniform 为 Effect 默认值。
         */
        resetUniform(name: string): void;
        /**
         * @zh
         * 重置指定贴图为 Effect 默认值。
         */
        resetTexture(name: string, index?: number): void;
        /**
         * @zh
         * 重置所有 UBO 为默认值。
         */
        resetUBOs(): void;
        /**
         * @zh
         * 重置所有 texture 和 sampler 为初始默认值。
         */
        resetTextures(): void;
        /**
         * @zh
         * 尝试编译 shader 并获取相关资源引用。
         * @param defineOverrides shader 预处理宏定义重载
         */
        tryCompile(): boolean | null;
        getShaderVariant(patches?: IMacroPatch[] | null): ShaderHandle;
        beginChangeStatesSilently(): void;
        endChangeStatesSilently(): void;
        protected _doInit(info: IPassInfoFull, copyDefines?: boolean): void;
        protected _syncBatchingScheme(): void;
        get root(): Root;
        get device(): GFXDevice;
        get shaderInfo(): IProgramInfo;
        get setLayouts(): import("index").GFXDescriptorSetLayout[];
        get program(): string;
        get properties(): Record<string, IPropertyInfo>;
        get defines(): Record<string, string | number | boolean>;
        get passIndex(): number;
        get propertyIndex(): number;
        get dynamics(): IPassDynamics;
        get blocks(): Float32Array[];
        get handle(): PassHandle;
        get priority(): number;
        get primitive(): GFXPrimitiveMode;
        get stage(): RenderPassStage;
        get phase(): number;
        get rasterizerState(): GFXRasterizerState;
        get depthStencilState(): GFXDepthStencilState;
        get blendState(): GFXBlendState;
        get dynamicStates(): GFXDynamicStateFlagBit;
        get batchingScheme(): BatchingSchemes;
        get hash(): number;
    }
}
declare module "cocos/core/pipeline/define" {
    /**
     * @category pipeline
     */
    import { Pass } from "cocos/core/renderer/core/pass";
    import { Model } from "cocos/core/renderer/scene/model";
    import { SubModel } from "cocos/core/renderer/scene/submodel";
    import { GFXBindingMappingInfo, IGFXDescriptorSetLayoutBinding } from "cocos/core/gfx/index";
    import { IBlockInfo, ISamplerInfo } from "cocos/core/assets/effect-asset";
    export const PIPELINE_FLOW_FORWARD: string;
    export const PIPELINE_FLOW_SHADOW: string;
    export const PIPELINE_FLOW_SMAA: string;
    export const PIPELINE_FLOW_TONEMAP: string;
    /**
     * @en The predefined render pass stage ids
     * @zh 预设的渲染阶段。
     */
    export enum RenderPassStage {
        DEFAULT = 100,
        UI = 200
    }
    /**
     * @en The predefined render priorities
     * @zh 预设的渲染优先级。
     */
    export enum RenderPriority {
        MIN = 0,
        MAX = 255,
        DEFAULT = 128
    }
    /**
     * @en Render object interface
     * @zh 渲染对象接口。
     */
    export interface IRenderObject {
        model: Model;
        depth: number;
    }
    export interface IRenderPass {
        hash: number;
        depth: number;
        shaderId: number;
        subModel: SubModel;
        passIdx: number;
    }
    /**
     * @en Render batch interface
     * @zh 渲染批次接口。
     */
    export interface IRenderBatch {
        pass: Pass;
    }
    /**
     * @en Render queue descriptor
     * @zh 渲染队列描述。
     */
    export interface IRenderQueueDesc {
        isTransparent: boolean;
        phases: number;
        sortFunc: (a: IRenderPass, b: IRenderPass) => number;
    }
    export interface IDescriptorSetLayoutInfo {
        bindings: IGFXDescriptorSetLayoutBinding[];
        record: Record<string, IBlockInfo | ISamplerInfo>;
    }
    export const globalDescriptorSetLayout: IDescriptorSetLayoutInfo;
    export const localDescriptorSetLayout: IDescriptorSetLayoutInfo;
    /**
     * @en The uniform bindings
     * @zh Uniform 参数绑定。
     */
    export enum PipelineGlobalBindings {
        UBO_GLOBAL = 0,
        UBO_SHADOW = 1,
        SAMPLER_ENVIRONMENT = 2,
        SAMPLER_SHADOWMAP = 3,
        COUNT = 4
    }
    export enum ModelLocalBindings {
        UBO_LOCAL = 0,
        UBO_FORWARD_LIGHTS = 1,
        UBO_SKINNING_ANIMATION = 2,
        UBO_SKINNING_TEXTURE = 3,
        UBO_MORPH = 4,
        SAMPLER_JOINTS = 5,
        SAMPLER_MORPH_POSITION = 6,
        SAMPLER_MORPH_NORMAL = 7,
        SAMPLER_MORPH_TANGENT = 8,
        SAMPLER_LIGHTING_MAP = 9,
        SAMPLER_SPRITE = 10,
        COUNT = 11
    }
    /**
     * @en Check whether the given uniform binding is a builtin binding
     * @zh 检查指定的 UniformBinding 是否是引擎内置的
     * @param binding
     */
    export const isBuiltinBinding: (set: number) => boolean;
    export enum SetIndex {
        GLOBAL = 0,
        MATERIAL = 1,
        LOCAL = 2
    }
    export const bindingMappingInfo: GFXBindingMappingInfo;
    /**
     * @en The global uniform buffer object
     * @zh 全局 UBO。
     */
    export class UBOGlobal {
        static TIME_OFFSET: number;
        static SCREEN_SIZE_OFFSET: number;
        static SCREEN_SCALE_OFFSET: number;
        static NATIVE_SIZE_OFFSET: number;
        static MAT_VIEW_OFFSET: number;
        static MAT_VIEW_INV_OFFSET: number;
        static MAT_PROJ_OFFSET: number;
        static MAT_PROJ_INV_OFFSET: number;
        static MAT_VIEW_PROJ_OFFSET: number;
        static MAT_VIEW_PROJ_INV_OFFSET: number;
        static CAMERA_POS_OFFSET: number;
        static EXPOSURE_OFFSET: number;
        static MAIN_LIT_DIR_OFFSET: number;
        static MAIN_LIT_COLOR_OFFSET: number;
        static AMBIENT_SKY_OFFSET: number;
        static AMBIENT_GROUND_OFFSET: number;
        static GLOBAL_FOG_COLOR_OFFSET: number;
        static GLOBAL_FOG_BASE_OFFSET: number;
        static GLOBAL_FOG_ADD_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    /**
     * @en The uniform buffer object for shadow
     * @zh 阴影 UBO。
     */
    export class UBOShadow {
        static MAT_LIGHT_PLANE_PROJ_OFFSET: number;
        static MAT_LIGHT_VIEW_PROJ_OFFSET: number;
        static SHADOW_COLOR_OFFSET: number;
        static SHADOW_PCF_OFFSET: number;
        static SHADOW_SIZE_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    export const UNIFORM_SHADOWMAP: ISamplerInfo;
    export const UNIFORM_ENVIRONMENT: ISamplerInfo;
    /**
     * @en The local uniform buffer object
     * @zh 本地 UBO。
     */
    export class UBOLocal {
        static MAT_WORLD_OFFSET: number;
        static MAT_WORLD_IT_OFFSET: number;
        static LIGHTINGMAP_UVPARAM: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    export const INST_MAT_WORLD = "a_matWorld0";
    export class UBOLocalBatched {
        static BATCHING_COUNT: number;
        static MAT_WORLDS_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    /**
     * @en The uniform buffer object for forward lighting
     * @zh 前向灯光 UBO。
     */
    export class UBOForwardLight {
        static LIGHTS_PER_PASS: number;
        static LIGHT_POS_OFFSET: number;
        static LIGHT_COLOR_OFFSET: number;
        static LIGHT_SIZE_RANGE_ANGLE_OFFSET: number;
        static LIGHT_DIR_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    export const JOINT_UNIFORM_CAPACITY = 30;
    /**
     * @en The uniform buffer object for skinning texture
     * @zh 骨骼贴图 UBO。
     */
    export class UBOSkinningTexture {
        static JOINTS_TEXTURE_INFO_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    export class UBOSkinningAnimation {
        static JOINTS_ANIM_INFO_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    export const INST_JOINT_ANIM_INFO = "a_jointAnimInfo";
    export class UBOSkinning {
        static JOINTS_OFFSET: number;
        static COUNT: number;
        static SIZE: number;
        static BLOCK: IBlockInfo;
    }
    /**
     * @en The uniform buffer object for morph setting
     * @zh 形变配置的 UBO
     */
    export class UBOMorph {
        static readonly MAX_MORPH_TARGET_COUNT = 60;
        static readonly OFFSET_OF_WEIGHTS = 0;
        static readonly OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH: number;
        static readonly OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT: number;
        static readonly COUNT_BASE_4_BYTES: number;
        static readonly SIZE: number;
        static readonly BLOCK: IBlockInfo;
    }
    /**
     * @en The sampler for joint texture
     * @zh 骨骼纹理采样器。
     */
    export const UniformJointTexture: ISamplerInfo;
    /**
     * @en The sampler for morph texture of position
     * @zh 位置形变纹理采样器。
     */
    export const UniformPositionMorphTexture: Readonly<ISamplerInfo>;
    /**
     * @en The sampler for morph texture of normal
     * @zh 法线形变纹理采样器。
     */
    export const UniformNormalMorphTexture: Readonly<ISamplerInfo>;
    /**
     * @en The sampler for morph texture of tangent
     * @zh 切线形变纹理采样器。
     */
    export const UniformTangentMorphTexture: Readonly<ISamplerInfo>;
    /**
     * @en The sampler for light map texture
     * @zh 光照图纹理采样器。
     */
    export const UniformLightingMapSampler: Readonly<ISamplerInfo>;
    /**
     * @en The sampler for UI sprites.
     * @zh UI 精灵纹理采样器。
     */
    export const UniformSpriteSampler: Readonly<ISamplerInfo>;
    export const CAMERA_DEFAULT_MASK: number;
    export const CAMERA_EDITOR_MASK: number;
    export const MODEL_ALWAYS_MASK: number;
}
declare module "cocos/core/pipeline/index" {
    /**
     * @category pipeline
     */
    import * as pipelineDefine from "cocos/core/pipeline/define";
    export const pipeline: typeof pipelineDefine;
    export { RenderPipeline } from "cocos/core/pipeline/render-pipeline";
    export { RenderFlow } from "cocos/core/pipeline/render-flow";
    export { RenderStage } from "cocos/core/pipeline/render-stage";
    export { RenderView } from "cocos/core/pipeline/render-view";
    export { RenderWindow } from "cocos/core/pipeline/render-window";
    export { ForwardPipeline } from "cocos/core/pipeline/forward/forward-pipeline";
    export { ForwardFlow } from "cocos/core/pipeline/forward/forward-flow";
    export { ForwardStage } from "cocos/core/pipeline/forward/forward-stage";
    export { ShadowFlow } from "cocos/core/pipeline/shadow/shadow-flow";
    export { ShadowStage } from "cocos/core/pipeline/shadow/shadow-stage";
    export { UIFlow } from "cocos/core/pipeline/ui/ui-flow";
    export { UIStage } from "cocos/core/pipeline/ui/ui-stage";
}
declare module "cocos/core/assets/render-texture" {
    import { GFXTexture, GFXSampler, IGFXRenderPassInfo } from "cocos/core/gfx/index";
    import { RenderWindow } from "cocos/core/pipeline/index";
    import { Asset } from "cocos/core/assets/asset";
    export interface IRenderTextureCreateInfo {
        name?: string;
        width: number;
        height: number;
        passInfo?: IGFXRenderPassInfo;
    }
    export class RenderTexture extends Asset {
        private _width;
        private _height;
        private _window;
        get width(): number;
        get height(): number;
        get window(): RenderWindow | null;
        initialize(info: IRenderTextureCreateInfo): void;
        reset(info: IRenderTextureCreateInfo): void;
        destroy(): boolean;
        resize(width: number, height: number): void;
        getGFXTexture(): GFXTexture | null;
        getGFXSampler(): GFXSampler;
        onLoaded(): void;
        protected _initWindow(info?: IRenderTextureCreateInfo): void;
    }
}
declare module "cocos/core/assets/sprite-frame" {
    import { Rect, Size, Vec2 } from "cocos/core/math/index";
    import { Asset } from "cocos/core/assets/asset";
    import { RenderTexture } from "cocos/core/assets/render-texture";
    import { TextureBase } from "cocos/core/assets/texture-base";
    import { ImageAsset, ImageSource } from "cocos/core/assets/image-asset";
    export interface IUV {
        u: number;
        v: number;
    }
    interface IVertices {
        x: any;
        y: any;
        triangles: any;
        nu: number[];
        u: number[];
        nv: number[];
        v: number[];
    }
    interface ISpriteFrameInitInfo {
        /**
         * @zh Texture 对象资源。
         */
        texture?: TextureBase | RenderTexture;
        /**
         * @zh 精灵帧原始尺寸。
         */
        originalSize?: Size;
        /**
         * @zh 精灵帧裁切矩形。
         */
        rect?: Rect;
        /**
         * @zh 精灵帧偏移量。
         */
        offset?: Vec2;
        /**
         * @zh 上边界。
         */
        borderTop?: number;
        /**
         * @zh 下边界。
         */
        borderBottom?: number;
        /**
         * @zh 左边界
         */
        borderLeft?: number;
        /**
         * @zh 右边界
         */
        borderRight?: number;
        /**
         * @zh 是否旋转。
         */
        isRotate?: boolean;
        /**
         * @zh 是否转置 UV。
         */
        isFlipUv?: boolean;
    }
    /**
     * @en
     * A `SpriteFrame` has:<br/>
     *  - texture: A `Texture2D` that will be used by render components<br/>
     *  - rectangle: A rectangle of the texture
     *
     * @zh
     * 精灵帧资源。
     * 一个 SpriteFrame 包含：<br/>
     *  - 纹理：会被渲染组件使用的 Texture2D 对象。<br/>
     *  - 矩形：在纹理中的矩形区域。
     * 可通过 `SpriteFrame` 获取该组件。
     *
     * @example
     * ```ts
     * import { loader } from 'cc';
     * // First way to use a SpriteFrame
     * const url = "assets/PurpleMonster/icon/spriteFrame";
     * loader.loadRes(url, (err, spriteFrame) => {
     *   const node = new Node("New Sprite");
     *   const sprite = node.addComponent(Sprite);
     *   sprite.spriteFrame = spriteFrame;
     *   node.parent = self.node;
     * });
     *
     * // Second way to use a SpriteFrame
     * const self = this;
     * const url = "test_assets/PurpleMonster";
     * loader.loadRes(url, (err, imageAsset) => {
     *  if(err){
     *    return;
     *  }
     *
     *  const node = new Node("New Sprite");
     *  const sprite = node.addComponent(Sprite);
     *  const spriteFrame = new SpriteFrame();
     *  const tex = imageAsset._texture;
     *  spriteFrame.texture = tex;
     *  sprite.spriteFrame = spriteFrame;
     *  node.parent = self.node;
     * });
     *
     * // Third way to use a SpriteFrame
     * const self = this;
     * const cameraComp = this.getComponent(Camera);
     * const renderTexture = new RenderTexture();
     * rendetTex.reset({
     *   width: 512,
     *   height: 512,
     *   depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8
     * });
     *
     * cameraComp.targetTexture = renderTexture;
     * const spriteFrame = new SpriteFrame();
     * spriteFrame.texture = renderTexture;
     * ```
     */
    export class SpriteFrame extends Asset {
        /**
         * @en
         * Create a SpriteFrame object by an image asset or an native image asset
         * @zh
         * 通过 Image 资源或者原始 image 资源创建一个 SpriteFrame 对象
         * @param imageSourceOrImageAsset ImageAsset or ImageSource, ImageSource support HTMLCanvasElement HTMLImageElement IMemoryImageSource
         */
        static createWithImage(imageSourceOrImageAsset: ImageSource | ImageAsset): SpriteFrame;
        /**
         * @en
         * Top border of the sprite.
         *
         * @zh
         * sprite 的顶部边框。
         */
        get insetTop(): number;
        set insetTop(value: number);
        /**
         * @en
         * Bottom border of the sprite.
         *
         * @zh
         * sprite 的底部边框。
         */
        get insetBottom(): number;
        set insetBottom(value: number);
        /**
         * @en
         * Left border of the sprite.
         *
         * @zh
         * sprite 的左边边框。
         */
        get insetLeft(): number;
        set insetLeft(value: number);
        /**
         * @en
         * Right border of the sprite.
         *
         * @zh
         * sprite 的右边边框。
         */
        get insetRight(): number;
        set insetRight(value: number);
        /**
         * @en
         * Returns the rect of the sprite frame in the texture.
         * If it's a atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
         *
         * @zh
         * 获取 SpriteFrame 的纹理矩形区域。
         * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
         */
        get rect(): Rect;
        set rect(value: Rect);
        /**
         * @en
         * Returns the original size of the trimmed image.
         *
         * @zh
         * 获取修剪前的原始大小。
         */
        get originalSize(): Size;
        set originalSize(value: Size);
        /**
         * @en
         * Returns the offset of the frame in the texture.
         *
         * @zh
         * 获取偏移量。
         */
        get offset(): Vec2;
        set offset(value: Vec2);
        /**
         * @en
         * Returns whether the sprite frame is rotated in the texture.
         *
         * @zh
         * 获取 SpriteFrame 是否旋转。
         */
        get rotated(): boolean;
        set rotated(rotated: boolean);
        get texture(): TextureBase | RenderTexture;
        set texture(value: TextureBase | RenderTexture);
        get atlasUuid(): string;
        set atlasUuid(value: string);
        get width(): number;
        get height(): number;
        set _textureSource(value: TextureBase);
        vertices: IVertices | null;
        /**
         * @zh
         * 不带裁切的 UV。
         */
        uv: number[];
        uvHash: number;
        /**
         * @zh
         * 带有裁切的 UV。
         */
        uvSliced: IUV[];
        protected _rect: Rect;
        protected _offset: Vec2;
        protected _originalSize: Size;
        protected _rotated: boolean;
        protected _capInsets: number[];
        protected _atlasUuid: string;
        protected _texture: TextureBase | RenderTexture;
        protected _flipUv: boolean;
        constructor();
        /**
         * @en
         * Returns whether the texture have been loaded.
         *
         * @zh
         * 返回是否已加载精灵帧。
         */
        textureLoaded(): boolean;
        /**
         * @en
         * Returns whether the sprite frame is rotated in the texture.
         *
         * @zh
         * 获取 SpriteFrame 是否旋转。
         * @deprecated 即将在 1.2 废除，请使用 `isRotated = rect.rotated`。
         */
        isRotated(): boolean;
        /**
         * @en
         * Set whether the sprite frame is rotated in the texture.
         *
         * @zh
         * 设置 SpriteFrame 是否旋转。
         * @param value
         * @deprecated 即将在 1.2 废除，请使用 `rect.rotated = true`。
         */
        setRotated(rotated: boolean): void;
        /**
         * @en
         * Returns the rect of the sprite frame in the texture.
         * If it's a atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
         *
         * @zh
         * 获取 SpriteFrame 的纹理矩形区域。
         * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
         * @deprecated 即将在 1.2 废除，请使用 `rect.set(spritFrame.rect)`。
         */
        getRect(out?: Rect): Rect;
        /**
         * @en
         * Sets the rect of the sprite frame in the texture.
         *
         * @zh
         * 设置 SpriteFrame 的纹理矩形区域。
         * @deprecated 即将在 1.2 废除，请使用 `spritFrame.rect = rect`。
         */
        setRect(rect: Rect): void;
        /**
         * @en
         * Returns the original size of the trimmed image.
         *
         * @zh
         * 获取修剪前的原始大小。
         * @deprecated 即将在 1.2 废除，请使用 `size.set(spritFrame.originalSize)`。
         */
        getOriginalSize(out?: Size): Size;
        /**
         * @en
         * Sets the original size of the trimmed image.
         *
         * @zh
         * 设置修剪前的原始大小。
         *
         * @param size - 设置精灵原始大小。
         * @deprecated 即将在 1.2 废除，请使用 `spritFrame.originalSize = size`。
         */
        setOriginalSize(size: Size): void;
        /**
         * @en
         * Returns the offset of the frame in the texture.
         *
         * @zh
         * 获取偏移量。
         *
         * @param out - 可复用的偏移量。
         * @deprecated 即将在 1.2 废除，请使用 `offset.set(spritFrame.offset)`。
         */
        getOffset(out?: Vec2): Vec2;
        /**
         * @en
         * Sets the offset of the frame in the texture.
         *
         * @zh
         * 设置偏移量。
         *
         * @param offsets - 偏移量。
         * @deprecated 即将在 1.2 废除，请使用 `spritFrame.offset = offset`。
         */
        setOffset(offset: Vec2): void;
        getGFXTexture(): import("index").GFXTexture | null;
        getGFXSampler(): import("index").GFXSampler;
        /**
         * 重置 SpriteFrame 数据。
         * @param info SpriteFrame 初始化数据。
         */
        reset(info?: ISpriteFrameInitInfo, clearData?: boolean): void;
        /**
         * @zh
         * 判断精灵计算的矩形区域是否越界。
         *
         * @param texture
         */
        checkRect(texture: TextureBase | RenderTexture): boolean;
        onLoaded(): void;
        destroy(): boolean;
        _calculateSlicedUV(): void;
        /**
         * @zh
         * 计算 UV。
         */
        _calculateUV(): void;
        _serialize(exporting?: any): any;
        _deserialize(serializeData: any, handle: any): void;
        protected _textureLoaded(): void;
        protected _refreshTexture(texture: TextureBase | RenderTexture): void;
    }
}
declare module "cocos/core/assets/text-asset" {
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @en Class for text file.
     * @zh 文本资源。
     */
    export default class TextAsset extends Asset {
        /**
         * 此资源包含的文本。
         */
        text: string;
        /**
         * @zh
         * 重载标准的 `toString()` 方法。
         */
        toString(): string;
    }
}
declare module "cocos/core/assets/json-asset" {
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @zh
     * Json 资源。
     * Json 资源加载后将直接解析为对象。如果你希望获得 JSON 的原始文本，你需要使用文本资源（使用文件名后缀“.txt”）。
     */
    export default class JsonAsset extends Asset {
        /**
         * 解析后的对象。
         */
        json: object | null;
    }
}
declare module "cocos/core/assets/ttf-font" {
    import { Font } from "cocos/core/assets/font";
    /**
     * @en
     * Class for TTFFont handling.
     *
     * @zh
     * TTF 字体资源类。
     */
    export class TTFFont extends Font {
        _fontFamily: any;
        get _nativeAsset(): any;
        set _nativeAsset(value: any);
    }
}
declare module "cocos/core/assets/label-atlas" {
    import { BitmapFont } from "cocos/core/assets/bitmap-font";
    /**
     * @en
     * Class for LabelAtlas handling.
     *
     * @zh
     * 艺术数字字体资源类。
     *
     */
    export class LabelAtlas extends BitmapFont {
    }
}
declare module "cocos/core/assets/texture-util" {
    import { ImageAsset, ImageSource } from "cocos/core/assets/image-asset";
    export type LoadImageCallback<T> = (this: T | undefined, error: Error | null | undefined, asset?: ImageAsset) => void;
    /**
     * 加载指定的图像资源。
     * @param url 图像资源的链接。
     * @param callback 回调函数。
     * @param target 回调函数的 `this` 参数。
     * @returns 图像资源，返回时可能还未完成加载；加载完成或失败时会调用回调函数。
     */
    export function loadImage<T extends object>(url: string, callback?: LoadImageCallback<T>, target?: T): ImageAsset;
    /**
     * 缓存指定的图像源，为它指定链接。此后，可以通过该链接直接加载它。
     * @param url 指定的链接。
     * @param image 缓存的图像源。
     */
    export function cacheImage(url: string, image: ImageSource): ImageAsset | undefined;
    /**
     * 尝试加载图像资源的实际数据。
     * @param imageAsset 图像资源。
     * @param callback 回调函数。
     */
    export function postLoadImage(imageAsset: ImageAsset, callback?: Function): void;
}
declare module "cocos/core/assets/deprecation" { }
declare module "cocos/core/assets/index" {
    export { RawAsset } from "cocos/core/assets/raw-asset";
    export { Asset } from "cocos/core/assets/asset";
    export { default as Prefab } from "cocos/core/assets/prefab";
    export * from "cocos/core/assets/scripts";
    export { default as SceneAsset } from "cocos/core/assets/scene-asset";
    export * from "cocos/core/assets/sprite-frame";
    export { SpriteAtlas } from "cocos/core/assets/sprite-atlas";
    export { default as TextAsset } from "cocos/core/assets/text-asset";
    export { default as JsonAsset } from "cocos/core/assets/json-asset";
    export { default as AssetLibrary } from "cocos/core/assets/asset-library";
    export { ImageAsset } from "cocos/core/assets/image-asset";
    export { Texture2D } from "cocos/core/assets/texture-2d";
    export { TextureCube } from "cocos/core/assets/texture-cube";
    export { TTFFont } from "cocos/core/assets/ttf-font";
    export { LabelAtlas } from "cocos/core/assets/label-atlas";
    export { BitmapFont } from "cocos/core/assets/bitmap-font";
    export { Font } from "cocos/core/assets/font";
    import * as textureUtil from "cocos/core/assets/texture-util";
    export { textureUtil };
    export { EffectAsset } from "cocos/core/assets/effect-asset";
    export { Material } from "cocos/core/assets/material";
    export { Mesh, RenderingSubMesh } from "cocos/core/assets/mesh";
    export { Skeleton } from "cocos/core/assets/skeleton";
    export { RenderTexture } from "cocos/core/assets/render-texture";
    import "cocos/core/assets/deprecation";
}
declare module "cocos/core/3d/framework/mesh-renderer" {
    /**
     * @category model
     */
    import { Texture2D } from "cocos/core/assets/index";
    import { Material } from "cocos/core/assets/material";
    import { Mesh } from "cocos/core/assets/mesh";
    import { Vec4 } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    /**
     * @en Shadow projection mode.
     * @zh 阴影投射方式。
     */
    const ModelShadowCastingMode: {
        /**
         * @en Disable shadow projection.
         * @zh 不投射阴影。
         */
        OFF: number;
        /**
         * @en Enable shadow projection.
         * @zh 开启阴影投射。
         */
        ON: number;
    };
    /**
     * @en Shadow receive mode.
     * @zh 阴影接收方式。
     */
    const ModelShadowReceivingMode: {
        /**
         * @en Disable shadow projection.
         * @zh 不接收阴影。
         */
        OFF: number;
        /**
         * @en Enable shadow projection.
         * @zh 开启阴影投射。
         */
        ON: number;
    };
    /**
     * @en model light map settings.
     * @zh 模型光照图设置
     */
    class ModelLightmapSettings {
        texture: Texture2D | null;
        uvParam: Vec4;
        protected _bakeable: boolean;
        protected _castShadow: boolean;
        protected _receiveShadow: boolean;
        protected _lightmapSize: number;
        /**
         * @en bakeable.
         * @zh 是否可烘培。
         */
        get bakeable(): boolean;
        set bakeable(val: boolean);
        /**
         * @en cast shadow.
         * @zh 是否投射阴影。
         */
        get castShadow(): boolean;
        set castShadow(val: boolean);
        /**
         * @en receive shadow.
         * @zh 是否接受阴影。
         */
        get receiveShadow(): boolean;
        set receiveShadow(val: boolean);
        /**
         * @en lightmap size.
         * @zh 光照图大小
         */
        get lightmapSize(): number;
        set lightmapSize(val: number);
    }
    /**
     * @en Mesh renderer component
     * @zh 网格渲染器组件。
     */
    export class MeshRenderer extends RenderableComponent {
        static ShadowCastingMode: {
            /**
             * @en Disable shadow projection.
             * @zh 不投射阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow projection.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        static ShadowReceivingMode: {
            /**
             * @en Disable shadow projection.
             * @zh 不接收阴影。
             */
            OFF: number;
            /**
             * @en Enable shadow projection.
             * @zh 开启阴影投射。
             */
            ON: number;
        };
        lightmapSettings: ModelLightmapSettings;
        protected _mesh: Mesh | null;
        protected _shadowCastingMode: number;
        protected _shadowReceivingMode: number;
        /**
         * @en Shadow projection mode.
         * @zh 阴影投射方式。
         */
        get shadowCastingMode(): number;
        set shadowCastingMode(val: number);
        /**
         * @en receive shadow.
         * @zh 是否接受阴影。
         */
        get receiveShadow(): number;
        set receiveShadow(val: number);
        /**
         * @en The mesh of the model.
         * @zh 模型的网格数据。
         */
        get mesh(): Mesh | null;
        set mesh(val: Mesh | null);
        get model(): scene.Model | null;
        get enableMorph(): boolean;
        set enableMorph(value: boolean);
        protected _modelType: typeof scene.Model;
        protected _model: scene.Model | null;
        private _morphInstance;
        private _enableMorph;
        constructor();
        onLoad(): void;
        onRestore(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        setWeights(weights: number[], subMeshIndex: number): void;
        setInstancedAttribute(name: string, value: ArrayLike<number>): void;
        _updateLightmap(lightmap: Texture2D | null, uOff: number, vOff: number, uScale: number, vScale: number): void;
        protected _updateModels(): void;
        protected _createModel(): void;
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        protected _updateModelParams(): void;
        protected _onUpdateLightingmap(): void;
        protected _onMaterialModified(idx: number, material: Material | null): void;
        protected _onRebuildPSO(idx: number, material: Material): void;
        protected _onMeshChanged(old: Mesh | null): void;
        protected _clearMaterials(): void;
        protected _getBuiltinMaterial(): Material;
        protected _onVisibilityChange(val: number): void;
        protected _updateCastShadow(): void;
        protected _updateReceiveShadow(): void;
        protected _isBatchingEnabled(): boolean;
        private _watchMorphInMesh;
        private _syncMorphWeights;
    }
    export namespace MeshRenderer {
        type ShadowCastingMode = EnumAlias<typeof ModelShadowCastingMode>;
        type ShadowReceivingMode = EnumAlias<typeof ModelShadowReceivingMode>;
    }
}
declare module "cocos/core/utils/batch-utils" {
    import { Node } from "cocos/core/scene-graph/node";
    export class BatchingUtility {
        /**
         * Collect the Models under `staticModelRoot`,
         * merge all the meshes statically into one (while disabling each component),
         * and attach it to a new Model on `batchedRoot`.
         * The world transform of each model is guaranteed to be preserved.
         *
         * For a more fine-grained control over the process, use `Mesh.merge` directly.
         * @param staticModelRoot root of all the static models to be batched
         * @param batchedRoot the target output node
         */
        static batchStaticModel(staticModelRoot: Node, batchedRoot: Node): boolean;
        /**
         * Undoes everything `batchStaticModel` did.
         *
         * @param staticModelRoot root of all the static models to be batched
         * @param batchedRoot the target output node
         */
        static unbatchStaticModel(staticModelRoot: Node, batchedRoot: Node): boolean;
    }
}
declare module "cocos/core/utils/coordinates-converts-utils" {
    /**
     * @category pipeline
     */
    import { Camera } from "cocos/core/3d/framework/camera-component";
    import { Vec3 } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    /**
     * @en
     * Conversion of non-UI nodes to UI Node (Local) Space coordinate system.
     * @zh
     * 非 UI 节点转换到 UI 节点(局部) 空间坐标系。
     * @deprecated 将在 1.2 移除，请使用 Camera 的 `convertToUINode`。
     * @param mainCamera 主相机。
     * @param wpos 世界空间位置。
     * @param uiNode UI节点。
     * @param out 返回局部坐标。
     */
    export function WorldNode3DToLocalNodeUI(mainCamera: Camera, wpos: Vec3, uiNode: Node, out?: Vec3): Vec3;
    /**
     * @en
     * Conversion of non-UI nodes to UI Node (World) Space coordinate system.
     * @zh
     * 非 UI 节点转换到 UI 节点(世界) 空间坐标系。
     * @deprecated 将在 1.2 移除，请使用 Camera 的 `convertToUINode`。
     * @param mainCamera 主相机。
     * @param wpos 世界空间位置。
     * @param out 返回世界坐标。
     */
    export function WorldNode3DToWorldNodeUI(mainCamera: Camera, wpos: Vec3, out?: Vec3): Vec3;
    /**
     * @deprecated 将在 1.2 移除，请使用 Camera 的 `convertToUINode`。
     */
    const convertUtils: {
        WorldNode3DToLocalNodeUI: typeof WorldNode3DToLocalNodeUI;
        WorldNode3DToWorldNodeUI: typeof WorldNode3DToWorldNodeUI;
    };
    export { convertUtils };
}
declare module "cocos/core/utils/index" {
    import * as js from "cocos/core/utils/js";
    /**
     * 杂项工具函数
     */
    import * as misc from "cocos/core/utils/misc";
    /**
     * 用于处理文件与目录的路径的模块
     */
    import * as path from "cocos/core/utils/path";
    export * from "cocos/core/utils/deprecated";
    export * from "cocos/core/utils/text-utils";
    export * from "cocos/core/utils/html-text-parser";
    export * from "cocos/core/utils/prefab-helper";
    export * from "cocos/core/utils/batch-utils";
    export * from "cocos/core/utils/murmurhash2_gc";
    export { js, misc, path, };
    export * from "cocos/core/utils/coordinates-converts-utils";
}
declare module "cocos/core/animation/value-proxy-factories/uniform" {
    import { Material } from "cocos/core/assets/material";
    import { IValueProxy, IValueProxyFactory } from "cocos/core/animation/value-proxy";
    /**
     * @en
     * Value proxy factory for setting uniform on material target.
     * @zh
     * 用于设置材质目标上指定 Uniform 的曲线值代理工厂。
     */
    export class UniformProxyFactory implements IValueProxyFactory {
        /**
         * @en Pass index.
         * @zh Pass 索引。
         */
        passIndex: number;
        /**
         * @en Uniform name.
         * @zh Uniform 名称。
         */
        uniformName: string;
        /**
         * @en
         * Specify the aimed channel of the uniform.
         * Use this when you're aiming at a single channel of the uniform instead of who uniform.
         * For example, only green(1) channel of a color uniform.
         * @zh
         * 指定目标 Uniform 的通道。
         * 当你希望设置 Uniform 单独的通道而非整个 Uniform 时应该当使用此字段。
         * 例如，仅设置颜色 Uniform 的红色通道。
         */
        channelIndex: number | undefined;
        constructor(uniformName?: string, passIndex?: number);
        forTarget(target: Material): IValueProxy;
    }
}
declare module "cocos/core/animation/value-proxy-factories/morph-weights" {
    import { MeshRenderer } from "cocos/core/3d/framework/mesh-renderer";
    import { IValueProxyFactory } from "cocos/core/animation/value-proxy";
    /**
     * @en
     * Value proxy factory for setting morph weights of specified sub-mesh on model component target.
     * @zh
     * 用于设置模型组件目标上指定子网格形变权重的曲线值代理工厂。
     */
    export class MorphWeightsValueProxy implements IValueProxyFactory {
        /**
         * @en Sub-mesh index.
         * @zh 子网格索引。
         */
        subMeshIndex: number;
        forTarget(target: MeshRenderer): {
            set: (value: number[]) => void;
        };
    }
    /**
     * @en
     * Value proxy factory for setting morph weights of each sub-mesh on model component target.
     * @zh
     * 用于设置模型组件目标上所有子网格形变权重的曲线值代理工厂。
     */
    export class MorphWeightsAllValueProxy implements IValueProxyFactory {
        forTarget(target: MeshRenderer): {
            set: (value: number[]) => void;
        };
    }
}
declare module "cocos/core/animation/cubic-spline-value" {
    import { Quat, Vec2, Vec3, Vec4 } from "cocos/core/math/index";
    import { ILerpable } from "cocos/core/animation/types";
    interface ICubicSplineValue<T> extends ILerpable {
        dataPoint: T;
        inTangent: T;
        outTangent: T;
        lerp(to: ICubicSplineValue<T>, t: number, dt: number): T;
        getNoLerp(): T;
    }
    type CubicSplineValueConstructor<T> = new (dataPoint: T, inTangent: T, outTangent: T) => ICubicSplineValue<T>;
    export const CubicSplineVec2Value: CubicSplineValueConstructor<Vec2>;
    export const CubicSplineVec3Value: CubicSplineValueConstructor<Vec3>;
    export const CubicSplineVec4Value: CubicSplineValueConstructor<Vec4>;
    export const CubicSplineQuatValue: CubicSplineValueConstructor<Quat>;
    export class CubicSplineNumberValue implements ICubicSplineValue<number> {
        dataPoint: number;
        inTangent: number;
        outTangent: number;
        constructor(dataPoint: number, inTangent: number, outTangent: number);
        lerp(to: CubicSplineNumberValue, t: number, dt: number): number;
        getNoLerp(): number;
    }
}
declare module "cocos/core/animation/animation" {
    /**
     * @hidden
     */
    export * from "cocos/core/animation/target-path";
    export * from "cocos/core/animation/value-proxy";
    export { UniformProxyFactory } from "cocos/core/animation/value-proxy-factories/uniform";
    export { MorphWeightsValueProxy, MorphWeightsAllValueProxy } from "cocos/core/animation/value-proxy-factories/morph-weights";
    export * from "cocos/core/animation/cubic-spline-value";
}
declare module "cocos/core/animation/deprecated" {
    import { Animation } from "cocos/core/animation/animation-component";
    import { SkeletalAnimation } from "cocos/core/animation/skeletal-animation";
    /**
     * Alias of [[Animation]]
     * @deprecated Since v1.2
     */
    export { Animation as AnimationComponent };
    /**
     * Alias of [[SkeletalAnimation]]
     * @deprecated Since v1.2
     */
    export { SkeletalAnimation as SkeletalAnimationComponent };
}
declare module "cocos/core/animation/index" {
    import * as animation from "cocos/core/animation/animation";
    import * as easing from "cocos/core/animation/easing";
    import { ComponentPath, HierarchyPath, ICustomTargetPath, TargetPath } from "cocos/core/animation/target-path";
    import { IValueProxyFactory } from "cocos/core/animation/value-proxy";
    import { UniformProxyFactory } from "cocos/core/animation/value-proxy-factories/uniform";
    export * from "cocos/core/animation/deprecated";
    export * from "cocos/core/animation/bezier";
    export { easing };
    export * from "cocos/core/animation/animation-curve";
    export * from "cocos/core/animation/animation-clip";
    export * from "cocos/core/animation/animation-manager";
    export { AnimationState, } from "cocos/core/animation/animation-state";
    export * from "cocos/core/animation/animation-component";
    export * from "cocos/core/animation/skeletal-animation-data-hub";
    export * from "cocos/core/animation/skeletal-animation-state";
    export * from "cocos/core/animation/skeletal-animation";
    export * from "cocos/core/animation/transform-utils";
    export { animation };
    /**
     * Use stuffs in `import('cc').animation` instead.
     * @deprecated Since v1.1.
     */
    export * from "cocos/core/animation/cubic-spline-value";
    /**
     * Alias of `HierarchyPath`.
     * @deprecated Since v1.1.
     */
    export class HierachyModifier extends HierarchyPath {
    }
    /**
     * Alias of `ComponentPath`.
     * @deprecated Since v1.1.
     */
    export class ComponentModifier extends ComponentPath {
    }
    /**
     * Implements `IValueProxyFactory` but do nothing.
     * @deprecated Since v1.1.
     */
    export class CurveValueAdapter implements IValueProxyFactory {
        forTarget(target: any): {
            set: () => void;
        };
    }
    /**
     * Alias of `UniformProxyFactory`.
     * @deprecated Since v1.1.
     */
    export class UniformCurveValueAdapter extends UniformProxyFactory {
    }
    /**
     * Alias of `isPropertyPath(path) && typeof path === 'string'`.
     * @deprecated Since v1.1.
     */
    export function isPropertyModifier(path: TargetPath): path is string;
    /**
     * Alias of `isPropertyPath(path) && typeof path === 'number'`.
     * @deprecated Since v1.1.
     */
    export function isElementModifier(path: TargetPath): path is number;
    /**
     * Alias of `isCustomPath()`.
     * @deprecated Since v1.1.
     */
    export function isCustomTargetModifier<T extends ICustomTargetPath>(path: TargetPath, constructor: Constructor<T>): path is T;
}
declare module "cocos/core/utils/profiler/counter" {
    export interface ICounterOption {
        desc: string;
        counter: Counter;
        min?: number;
        max?: number;
        average?: number;
        below?: number;
        over?: number;
        color?: string;
        isInteger?: boolean;
    }
    export class Counter {
        get value(): number;
        set value(val: number);
        protected _id: string;
        protected _opts: ICounterOption;
        protected _accumStart: number;
        protected _total: number;
        protected _value: number;
        protected _averageValue: number;
        protected _accumValue: number;
        protected _accumSamples: number;
        constructor(id: string, opts: ICounterOption, now: number);
        sample(now: number): void;
        human(): number;
        alarm(): boolean | 0 | undefined;
        protected _average(v: number, now?: number): void;
    }
}
declare module "cocos/core/utils/profiler/perf-counter" {
    import { Counter, ICounterOption } from "cocos/core/utils/profiler/counter";
    export class PerfCounter extends Counter {
        private _time;
        constructor(id: string, opts: ICounterOption, now: number);
        start(now?: number): void;
        end(now?: number): void;
        tick(): void;
        frame(now: number): void;
    }
}
declare module "cocos/core/utils/profiler/profiler" {
    import { ICounterOption } from "cocos/core/utils/profiler/counter";
    interface IProfilerState {
        frame: ICounterOption;
        fps: ICounterOption;
        draws: ICounterOption;
        instances: ICounterOption;
        tricount: ICounterOption;
        logic: ICounterOption;
        physics: ICounterOption;
        render: ICounterOption;
        textureMemory: ICounterOption;
        bufferMemory: ICounterOption;
    }
    export class Profiler {
        _stats: IProfilerState | null;
        id: string;
        private _showFPS;
        private _rootNode;
        private _device;
        private readonly _canvas;
        private readonly _ctx;
        private _texture;
        private readonly _region;
        private readonly _canvasArr;
        private readonly _regionArr;
        private digitsData;
        private pass;
        private _canvasDone;
        private _statsDone;
        private _inited;
        private readonly _lineHeight;
        private _wordHeight;
        private _eachNumWidth;
        private _totalLines;
        private lastTime;
        constructor();
        isShowingStats(): boolean;
        hideStats(): void;
        showStats(): void;
        generateCanvas(): void;
        generateStats(): void;
        generateNode(): void;
        beforeUpdate(): void;
        afterUpdate(): void;
        beforePhysics(): void;
        afterPhysics(): void;
        beforeDraw(): void;
        afterDraw(): void;
    }
    export const profiler: Profiler;
}
declare module "cocos/core/deprecated" {
    const vmath: {};
    export { vmath };
}
declare module "cocos/core/index" {
    import * as geometry from "cocos/core/geometry/index";
    import * as math from "cocos/core/math/index";
    import * as memop from "cocos/core/memop/index";
    export { math, memop, geometry };
    export * from "cocos/core/math/index";
    export * from "cocos/core/memop/index";
    export * from "cocos/core/value-types/index";
    export * from "cocos/core/utils/index";
    export * from "cocos/core/data/index";
    export * from "cocos/core/event/index";
    export * from "cocos/core/assets/index";
    export * from "cocos/core/platform/index";
    export * from "cocos/core/game";
    export * from "cocos/core/scheduler";
    export * from "cocos/core/director";
    export * from "cocos/core/gfx/index";
    export * from "cocos/core/pipeline/index";
    export * from "cocos/core/load-pipeline/index";
    export * from "cocos/core/scene-graph/index";
    export * from "cocos/core/components/index";
    export * from "cocos/core/3d/index";
    export * from "cocos/core/animation/index";
    import "cocos/core/primitive/index";
    export * from "cocos/core/utils/profiler/profiler";
    import "cocos/core/splash-screen";
    import "cocos/core/deprecated";
}
declare module "cocos/core/gfx/pipeline-state" {
    /**
     * @category gfx
     */
    import { GFXBlendFactor, GFXBlendOp, GFXColorMask, GFXComparisonFunc, GFXCullMode, GFXDynamicStateFlags, GFXObject, GFXPolygonMode, GFXPrimitiveMode, GFXShadeModel, GFXStencilOp, GFXColor } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    import { GFXShader } from "cocos/core/gfx/shader";
    import { GFXPipelineLayout } from "cocos/core/index";
    /**
     * @en GFX rasterizer state.
     * @zh GFX 光栅化状态。
     */
    export class GFXRasterizerState {
        isDiscard: boolean;
        polygonMode: GFXPolygonMode;
        shadeModel: GFXShadeModel;
        cullMode: GFXCullMode;
        isFrontFaceCCW: boolean;
        depthBias: number;
        depthBiasClamp: number;
        depthBiasSlop: number;
        isDepthClip: boolean;
        isMultisample: boolean;
        lineWidth: number;
        compare(state: GFXRasterizerState): boolean;
    }
    /**
     * @en GFX depth stencil state.
     * @zh GFX 深度模板状态。
     */
    export class GFXDepthStencilState {
        depthTest: boolean;
        depthWrite: boolean;
        depthFunc: GFXComparisonFunc;
        stencilTestFront: boolean;
        stencilFuncFront: GFXComparisonFunc;
        stencilReadMaskFront: number;
        stencilWriteMaskFront: number;
        stencilFailOpFront: GFXStencilOp;
        stencilZFailOpFront: GFXStencilOp;
        stencilPassOpFront: GFXStencilOp;
        stencilRefFront: number;
        stencilTestBack: boolean;
        stencilFuncBack: GFXComparisonFunc;
        stencilReadMaskBack: number;
        stencilWriteMaskBack: number;
        stencilFailOpBack: GFXStencilOp;
        stencilZFailOpBack: GFXStencilOp;
        stencilPassOpBack: GFXStencilOp;
        stencilRefBack: number;
        compare(state: GFXDepthStencilState): boolean;
    }
    /**
     * @en GFX blend target.
     * @zh GFX 混合目标。
     */
    export class GFXBlendTarget {
        blend: boolean;
        blendSrc: GFXBlendFactor;
        blendDst: GFXBlendFactor;
        blendEq: GFXBlendOp;
        blendSrcAlpha: GFXBlendFactor;
        blendDstAlpha: GFXBlendFactor;
        blendAlphaEq: GFXBlendOp;
        blendColorMask: GFXColorMask;
        compare(target: GFXBlendTarget): boolean;
    }
    /**
     * @en GFX blend state.
     * @zh GFX混合状态。
     */
    export class GFXBlendState {
        isA2C: boolean;
        isIndepend: boolean;
        blendColor: GFXColor;
        targets: GFXBlendTarget[];
    }
    /**
     * @en GFX input state.
     * @zh GFX 输入状态。
     */
    export class GFXInputState {
        attributes: IGFXAttribute[];
    }
    export interface IGFXPipelineStateInfo {
        primitive: GFXPrimitiveMode;
        shader: GFXShader;
        pipelineLayout: GFXPipelineLayout;
        inputState: GFXInputState;
        rasterizerState: GFXRasterizerState;
        depthStencilState: GFXDepthStencilState;
        blendState: GFXBlendState;
        dynamicStates?: GFXDynamicStateFlags;
        renderPass: GFXRenderPass;
    }
    /**
     * @en GFX pipeline state.
     * @zh GFX 管线状态。
     */
    export abstract class GFXPipelineState extends GFXObject {
        /**
         * @en Get current shader.
         * @zh GFX 着色器。
         */
        get shader(): GFXShader;
        /**
         * @en Get current pipeline layout.
         * @zh GFX 管线布局。
         */
        get pipelineLayout(): GFXPipelineLayout;
        /**
         * @en Get current primitve mode.
         * @zh GFX 图元模式。
         */
        get primitive(): GFXPrimitiveMode;
        /**
         * @en Get current rasterizer state.
         * @zh GFX 光栅化状态。
         */
        get rasterizerState(): GFXRasterizerState;
        /**
         * @en Get current depth stencil state.
         * @zh GFX 深度模板状态。
         */
        get depthStencilState(): GFXDepthStencilState;
        /**
         * @en Get current blend state.
         * @zh GFX 混合状态。
         */
        get blendState(): GFXBlendState;
        /**
         * @en Get current input state.
         * @zh GFX 输入状态。
         */
        get inputState(): GFXInputState;
        /**
         * @en Get current dynamic states.
         * @zh GFX 动态状态数组。
         */
        get dynamicStates(): GFXDynamicStateFlags;
        /**
         * @en Get current render pass.
         * @zh GFX 渲染过程。
         */
        get renderPass(): GFXRenderPass;
        protected _device: GFXDevice;
        protected _shader: GFXShader | null;
        protected _pipelineLayout: GFXPipelineLayout | null;
        protected _primitive: GFXPrimitiveMode;
        protected _is: GFXInputState | null;
        protected _rs: GFXRasterizerState | null;
        protected _dss: GFXDepthStencilState | null;
        protected _bs: GFXBlendState | null;
        protected _dynamicStates: GFXDynamicStateFlags;
        protected _renderPass: GFXRenderPass | null;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXPipelineStateInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/gfx/fence" {
    /**
     * @category gfx
     */
    import { GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    export interface IGFXFenceInfo {
    }
    /**
     * @en GFX Fence.
     * @zh GFX 同步信号。
     */
    export abstract class GFXFence extends GFXObject {
        protected _device: GFXDevice;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXFenceInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Wait for this fence.
         * @zh 等待当前 fence 信号。
         */
        abstract wait(): void;
        /**
         * @en Reset this fence to unsignaled state.
         * @zh 重置当前 fence。
         */
        abstract reset(): void;
    }
}
declare module "cocos/core/gfx/queue" {
    /**
     * @category gfx
     */
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { GFXObject, GFXQueueType } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXFence } from "cocos/core/gfx/fence";
    export interface IGFXQueueInfo {
        type: GFXQueueType;
    }
    /**
     * @en GFX Queue.
     * @zh GFX 队列。
     */
    export abstract class GFXQueue extends GFXObject {
        /**
         * @en Get current type.
         * @zh 队列类型。
         */
        get type(): number;
        protected _device: GFXDevice;
        protected _type: GFXQueueType;
        protected _isAsync: boolean;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXQueueInfo): boolean;
        abstract destroy(): void;
        isAsync(): boolean;
        /**
         * @en Submit command buffers.
         * @zh 提交命令缓冲数组。
         * @param cmdBuffs The command buffers to be submitted.
         * @param fence The syncing fence.
         */
        abstract submit(cmdBuffs: GFXCommandBuffer[], fence?: GFXFence): void;
    }
}
declare module "cocos/core/gfx/command-buffer" {
    /**
     * @category gfx
     */
    import { GFXDescriptorSet } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXBufferTextureCopy, GFXCommandBufferType, GFXObject, GFXStencilFace, GFXColor, GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState } from "cocos/core/gfx/pipeline-state";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    import { GFXQueue } from "cocos/core/gfx/queue";
    export interface IGFXCommandBufferInfo {
        queue: GFXQueue;
        type: GFXCommandBufferType;
    }
    export interface IGFXDepthBias {
        constantFactor: number;
        clamp: number;
        slopeFactor: number;
    }
    export interface IGFXDepthBounds {
        minBounds: number;
        maxBounds: number;
    }
    export interface IGFXStencilWriteMask {
        face: GFXStencilFace;
        writeMask: number;
    }
    export interface IGFXStencilCompareMask {
        face: GFXStencilFace;
        reference: number;
        compareMask: number;
    }
    /**
     * @en GFX command buffer.
     * @zh GFX 命令缓冲。
     */
    export abstract class GFXCommandBuffer extends GFXObject {
        /**
         * @en Type of the command buffer.
         * @zh 命令缓冲类型。
         */
        get type(): GFXCommandBufferType;
        /**
         * @en Type of the command buffer.
         * @zh 命令缓冲类型。
         */
        get queue(): GFXQueue;
        /**
         * @en Number of draw calls currently recorded.
         * @zh 绘制调用次数。
         */
        get numDrawCalls(): number;
        /**
         * @en Number of instances currently recorded.
         * @zh 绘制 Instance 数量。
         */
        get numInstances(): number;
        /**
         * @en Number of triangles currently recorded.
         * @zh 绘制三角形数量。
         */
        get numTris(): number;
        protected _device: GFXDevice;
        protected _queue: GFXQueue | null;
        protected _type: GFXCommandBufferType;
        protected _numDrawCalls: number;
        protected _numInstances: number;
        protected _numTris: number;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXCommandBufferInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Begin recording commands.
         * @zh 开始记录命令。
         * @param renderPass [Secondary Command Buffer Only] The render pass the subsequent commands will be executed in
         * @param subpass [Secondary Command Buffer Only] The subpass the subsequent commands will be executed in
         * @param frameBuffer [Secondary Command Buffer Only, Optional] The framebuffer to be used in the subpass
         */
        abstract begin(renderPass?: GFXRenderPass, subpass?: number, frameBuffer?: GFXFramebuffer): void;
        /**
         * @en End recording commands.
         * @zh 结束记录命令。
         */
        abstract end(): void;
        /**
         * @en Begin render pass.
         * @zh 开始 RenderPass。
         * @param framebuffer The frame buffer used.
         * @param renderArea The target render area.
         * @param clearFlag The clear flags.
         * @param clearColors The clearing colors.
         * @param clearDepth The clearing depth.
         * @param clearStencil The clearing stencil.
         */
        abstract beginRenderPass(renderPass: GFXRenderPass, framebuffer: GFXFramebuffer, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
        /**
         * @en End render pass.
         * @zh 结束 RenderPass。
         */
        abstract endRenderPass(): void;
        /**
         * @en Bind pipeline state.
         * @zh 绑定 GFX 管线状态。
         * @param pipelineState The pipeline state to be bound.
         */
        abstract bindPipelineState(pipelineState: GFXPipelineState): void;
        /**
         * @en Bind descriptor set.
         * @zh 绑定 GFX 描述符集。
         * @param descriptorSet The descriptor set to be bound.
         */
        abstract bindDescriptorSet(set: number, descriptorSets: GFXDescriptorSet, dynamicOffsets?: number[]): void;
        /**
         * @en Bind input assembler.
         * @zh 绑定GFX输入汇集器。
         * @param inputAssembler The input assembler to be bound.
         */
        abstract bindInputAssembler(inputAssembler: GFXInputAssembler): void;
        /**
         * @en Set viewport.
         * @zh 设置视口。
         * @param viewport The new viewport.
         */
        abstract setViewport(viewport: GFXViewport): void;
        /**
         * @en Set scissor range.
         * @zh 设置剪裁区域。
         * @param scissor The new scissor range.
         */
        abstract setScissor(scissor: GFXRect): void;
        /**
         * @en Set line width.
         * @zh 设置线宽。
         * @param lineWidth The new line width.
         */
        abstract setLineWidth(lineWidth: number): void;
        /**
         * @en Set depth bias.
         * @zh 设置深度偏移。
         * @param depthBiasConstantFactor The new depth bias factor.
         * @param depthBiasClamp The new depth bias clamp threshold.
         * @param depthBiasSlopeFactor  The new depth bias slope factor.
         */
        abstract setDepthBias(depthBiasConstantFactor: number, depthBiasClamp: number, depthBiasSlopeFactor: number): void;
        /**
         * @en Set blend constants.
         * @zh 设置混合因子。
         * @param blendConstants The new blend constants.
         */
        abstract setBlendConstants(blendConstants: number[]): void;
        /**
         * @en Set depth bound.
         * @zh 设置深度边界。
         * @param minDepthBounds The new minimum depth bound.
         * @param maxDepthBounds The new maximum depth bound.
         */
        abstract setDepthBound(minDepthBounds: number, maxDepthBounds: number): void;
        /**
         * @en Set stencil write mask.
         * @zh 设置模板写掩码。
         * @param face The effective triangle face.
         * @param writeMask The new stencil write mask.
         */
        abstract setStencilWriteMask(face: GFXStencilFace, writeMask: number): void;
        /**
         * @en Set stencil compare mask.
         * @zh 设置模板比较掩码。
         * @param face The effective triangle face.
         * @param reference The new stencil reference constant.
         * @param compareMask The new stencil read mask.
         */
        abstract setStencilCompareMask(face: GFXStencilFace, reference: number, compareMask: number): void;
        /**
         * @en Draw the specified primitives.
         * @zh 绘制。
         * @param inputAssembler The target input assembler.
         */
        abstract draw(inputAssembler: GFXInputAssembler): void;
        /**
         * @en Update buffer.
         * @zh 更新缓冲。
         * @param buffer The buffer to be updated.
         * @param data The source data.
         * @param offset Offset into the buffer.
         */
        abstract updateBuffer(buffer: GFXBuffer, data: ArrayBuffer, offset?: number): void;
        /**
         * @en Copy buffer to texture.
         * @zh 拷贝缓冲到纹理。
         * @param srcBuff The buffer to be copied.
         * @param dstTex The texture to copy to.
         * @param dstLayout The target texture layout.
         * @param regions The region descriptions.
         */
        abstract copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        /**
         * @en Execute specified command buffers.
         * @zh 执行一组命令缓冲。
         * @param cmdBuffs The command buffers to be executed.
         * @param count The number of command buffers to be executed.
         */
        abstract execute(cmdBuffs: GFXCommandBuffer[], count: number): void;
    }
}
declare module "cocos/core/gfx/device" {
    import { GFXDescriptorSet, IGFXDescriptorSetInfo } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer, IGFXBufferInfo, IGFXBufferViewInfo } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer, IGFXCommandBufferInfo } from "cocos/core/gfx/command-buffer";
    import { GFXBufferTextureCopy, GFXFilter, GFXFormat, GFXMemoryStatus, GFXRect } from "cocos/core/gfx/define";
    import { GFXFence, IGFXFenceInfo } from "cocos/core/gfx/fence";
    import { GFXFramebuffer, IGFXFramebufferInfo } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState, IGFXPipelineStateInfo } from "cocos/core/gfx/pipeline-state";
    import { GFXQueue, IGFXQueueInfo } from "cocos/core/gfx/queue";
    import { GFXRenderPass, IGFXRenderPassInfo } from "cocos/core/gfx/render-pass";
    import { GFXSampler, IGFXSamplerInfo } from "cocos/core/gfx/sampler";
    import { GFXShader, GFXShaderInfo } from "cocos/core/gfx/shader";
    import { GFXTexture, IGFXTextureInfo, IGFXTextureViewInfo } from "cocos/core/gfx/texture";
    import { IGFXDescriptorSetLayoutInfo, GFXDescriptorSetLayout, IGFXPipelineLayoutInfo, GFXPipelineLayout } from "exports/base";
    export enum GFXAPI {
        UNKNOWN = 0,
        GL = 1,
        GLES2 = 2,
        GLES3 = 3,
        METAL = 4,
        VULKAN = 5,
        DX12 = 6,
        WEBGL = 7,
        WEBGL2 = 8
    }
    export enum GFXFeature {
        COLOR_FLOAT = 0,
        COLOR_HALF_FLOAT = 1,
        TEXTURE_FLOAT = 2,
        TEXTURE_HALF_FLOAT = 3,
        TEXTURE_FLOAT_LINEAR = 4,
        TEXTURE_HALF_FLOAT_LINEAR = 5,
        FORMAT_R11G11B10F = 6,
        FORMAT_D16 = 7,
        FORMAT_D16S8 = 8,
        FORMAT_D24 = 9,
        FORMAT_D24S8 = 10,
        FORMAT_D32F = 11,
        FORMAT_D32FS8 = 12,
        FORMAT_ETC1 = 13,
        FORMAT_ETC2 = 14,
        FORMAT_DXT = 15,
        FORMAT_PVRTC = 16,
        FORMAT_ASTC = 17,
        FORMAT_RGB8 = 18,
        MSAA = 19,
        ELEMENT_INDEX_UINT = 20,
        INSTANCED_ARRAYS = 21,
        COUNT = 22
    }
    export class GFXBindingMappingInfo {
        bufferOffsets: number[];
        samplerOffsets: number[];
    }
    export interface IGFXDeviceInfo {
        canvasElm: HTMLElement;
        isAntialias?: boolean;
        isPremultipliedAlpha?: boolean;
        debug?: boolean;
        devicePixelRatio?: number;
        nativeWidth?: number;
        nativeHeight?: number;
        /**
         * For non-vulkan backends, to maintain compatibility and maximize
         * descriptor cache-locality, descriptor-set-based binding numbers need
         * to be mapped to backend-specific bindings based on maximum limit
         * of available descriptor slots in each set.
         *
         * Because the binding numbers are guaranteed to be consecutive for each
         * descriptor type inside each set, the mapping procedure can be reduced
         * to a simple shifting operation. This data structure specifies the
         * exact offsets for each descriptor type in each set.
         */
        bindingMappingInfo?: GFXBindingMappingInfo;
    }
    /**
     * @en GFX Device.
     * @zh GFX 设备。
     */
    export abstract class GFXDevice {
        /**
         * @en The HTML canvas element.
         * @zh HTML 画布。
         */
        get canvas(): HTMLCanvasElement;
        /**
         * @en The HTML canvas element for 2D rendering.
         * @zh 用于 2D 绘制的 HTML 画布。
         */
        get canvas2D(): HTMLCanvasElement;
        /**
         * @en Current rendering API.
         * @zh 当前 GFX 使用的渲染 API。
         */
        get gfxAPI(): GFXAPI;
        /**
         * @en GFX queue.
         * @zh GFX 队列。
         */
        get queue(): GFXQueue;
        /**
         * @en Device pixel ratio.
         * @zh DPR 设备像素比。
         */
        get devicePixelRatio(): number;
        /**
         * @en Device pixel width.
         * @zh 设备像素宽度。
         */
        get width(): number;
        /**
         * @en Device pixel height.
         * @zh 设备像素高度。
         */
        get height(): number;
        /**
         * @en Device native width.
         * @zh 设备原生的像素宽度。
         */
        get nativeWidth(): number;
        /**
         * @en Device native height.
         * @zh 设备原生的像素高度。
         */
        get nativeHeight(): number;
        /**
         * @en Renderer description.
         * @zh 渲染器描述。
         */
        get renderer(): string;
        /**
         * @en Vendor description.
         * @zh 厂商描述。
         */
        get vendor(): string;
        /**
         * @en Max vertex attributes supported.
         * @zh 最大顶点属性数量。
         */
        get maxVertexAttributes(): number;
        /**
         * @en Max vertex uniform vectors supported.
         * @zh 最大顶点Uniform向量数。
         */
        get maxVertexUniformVectors(): number;
        /**
         * @en Max fragment uniform vectors supported.
         * @zh 最大片段Uniform向量数。
         */
        get maxFragmentUniformVectors(): number;
        /**
         * @en Max texture units supported.
         * @zh 最大纹理单元数量。
         */
        get maxTextureUnits(): number;
        /**
         * @en Max vertex texture units supported.
         * @zh 最大顶点纹理单元数量。
         */
        get maxVertexTextureUnits(): number;
        /**
         * @en Max uniform buffer bindings supported.
         * @zh 最大 uniform 缓冲绑定数量。
         */
        get maxUniformBufferBindings(): number;
        /**
         * @en Max uniform block size supported.
         * @zh 最大 uniform 缓冲大小。
         */
        get maxUniformBlockSize(): number;
        /**
         * @en Max texture size supported.
         * @zh 最大贴图尺寸。
         */
        get maxTextureSize(): number;
        /**
         * @en Max cube map texture size supported.
         * @zh 最大立方贴图尺寸。
         */
        get maxCubeMapTextureSize(): number;
        /**
         * @en Uniform buffer offset alignment.
         * @zh Uniform 缓冲偏移量的对齐单位。
         */
        get uboOffsetAlignment(): number;
        /**
         * @en Device depth bits.
         * @zh 深度位数。
         */
        get depthBits(): number;
        /**
         * @en Device stencil bits.
         * @zh 模板位数。
         */
        get stencilBits(): number;
        /**
         * @en Device color format.
         * @zh 颜色格式。
         */
        get colorFormat(): GFXFormat;
        /**
         * @en Device depth stencil format.
         * @zh 深度模板格式。
         */
        get depthStencilFormat(): GFXFormat;
        /**
         * @en Device built-in macros.
         * @zh 系统宏定义。
         */
        get macros(): Map<string, string>;
        /**
         * @en Number of draw calls currently recorded.
         * @zh 绘制调用次数。
         */
        get numDrawCalls(): number;
        /**
         * @en Number of instances currently recorded.
         * @zh 绘制 Instance 数量。
         */
        get numInstances(): number;
        /**
         * @en Number of triangles currently recorded.
         * @zh 渲染三角形数量。
         */
        get numTris(): number;
        /**
         * @en Total memory size currently allocated.
         * @zh 内存状态。
         */
        get memoryStatus(): GFXMemoryStatus;
        /**
         * @en The minimum Z value in clip space for the device.
         * @zh 裁剪空间的最小 z 值。
         */
        get clipSpaceMinZ(): number;
        /**
         * @en The sign of the screen space Y axis, positive if origin at lower-left.
         * @zh 屏幕空间的 y 轴符号，原点在左下角时为正。
         */
        get screenSpaceSignY(): number;
        /**
         * @en The sign of the UV space Y axis, positive if origin at upper-left.
         * @zh UV 空间的 y 轴符号，原点在左上角时为正。
         */
        get UVSpaceSignY(): number;
        protected _canvas: HTMLCanvasElement | null;
        protected _canvas2D: HTMLCanvasElement | null;
        protected _gfxAPI: GFXAPI;
        protected _deviceName: string;
        protected _renderer: string;
        protected _vendor: string;
        protected _version: string;
        protected _features: boolean[];
        protected _queue: GFXQueue | null;
        protected _devicePixelRatio: number;
        protected _width: number;
        protected _height: number;
        protected _nativeWidth: number;
        protected _nativeHeight: number;
        protected _maxVertexAttributes: number;
        protected _maxVertexUniformVectors: number;
        protected _maxFragmentUniformVectors: number;
        protected _maxTextureUnits: number;
        protected _maxVertexTextureUnits: number;
        protected _maxUniformBufferBindings: number;
        protected _maxUniformBlockSize: number;
        protected _maxTextureSize: number;
        protected _maxCubeMapTextureSize: number;
        protected _uboOffsetAlignment: number;
        protected _depthBits: number;
        protected _stencilBits: number;
        protected _colorFmt: GFXFormat;
        protected _depthStencilFmt: GFXFormat;
        protected _shaderIdGen: number;
        protected _macros: Map<string, string>;
        protected _numDrawCalls: number;
        protected _numInstances: number;
        protected _numTris: number;
        protected _memoryStatus: GFXMemoryStatus;
        protected _clipSpaceMinZ: number;
        protected _screenSpaceSignY: number;
        protected _UVSpaceSignY: number;
        abstract initialize(info: IGFXDeviceInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Resize the device.
         * @zh 重置设备大小。
         * @param width The device width.
         * @param height The device height.
         */
        abstract resize(width: number, height: number): void;
        /**
         * @en Begin current frame.
         * @zh 开始当前帧。
         */
        abstract acquire(): void;
        /**
         * @en Present current frame.
         * @zh 呈现当前帧。
         */
        abstract present(): void;
        /**
         * @en Create command buffer.
         * @zh 创建命令缓冲。
         * @param info GFX command buffer description info.
         */
        abstract createCommandBuffer(info: IGFXCommandBufferInfo): GFXCommandBuffer;
        /**
         * @en Create buffer.
         * @zh 创建缓冲。
         * @param info GFX buffer description info.
         */
        abstract createBuffer(info: IGFXBufferInfo | IGFXBufferViewInfo): GFXBuffer;
        /**
         * @en Create texture.
         * @zh 创建纹理。
         * @param info GFX texture description info.
         */
        abstract createTexture(info: IGFXTextureInfo | IGFXTextureViewInfo): GFXTexture;
        /**
         * @en Create sampler.
         * @zh 创建采样器。
         * @param info GFX sampler description info.
         */
        abstract createSampler(info: IGFXSamplerInfo): GFXSampler;
        /**
         * @en Create descriptor sets.
         * @zh 创建描述符集组。
         * @param info GFX descriptor sets description info.
         */
        abstract createDescriptorSet(info: IGFXDescriptorSetInfo): GFXDescriptorSet;
        /**
         * @en Create shader.
         * @zh 创建着色器。
         * @param info GFX shader description info.
         */
        abstract createShader(info: GFXShaderInfo): GFXShader;
        /**
         * @en Create input assembler.
         * @zh 创建纹理。
         * @param info GFX input assembler description info.
         */
        abstract createInputAssembler(info: IGFXInputAssemblerInfo): GFXInputAssembler;
        /**
         * @en Create render pass.
         * @zh 创建渲染过程。
         * @param info GFX render pass description info.
         */
        abstract createRenderPass(info: IGFXRenderPassInfo): GFXRenderPass;
        /**
         * @en Create frame buffer.
         * @zh 创建帧缓冲。
         * @param info GFX frame buffer description info.
         */
        abstract createFramebuffer(info: IGFXFramebufferInfo): GFXFramebuffer;
        /**
         * @en Create descriptor set layout.
         * @zh 创建描述符集布局。
         * @param info GFX descriptor set layout description info.
         */
        abstract createDescriptorSetLayout(info: IGFXDescriptorSetLayoutInfo): GFXDescriptorSetLayout;
        /**
         * @en Create pipeline layout.
         * @zh 创建管线布局。
         * @param info GFX pipeline layout description info.
         */
        abstract createPipelineLayout(info: IGFXPipelineLayoutInfo): GFXPipelineLayout;
        /**
         * @en Create pipeline state.
         * @zh 创建管线状态。
         * @param info GFX pipeline state description info.
         */
        abstract createPipelineState(info: IGFXPipelineStateInfo): GFXPipelineState;
        /**
         * @en Create queue.
         * @zh 创建队列。
         * @param info GFX queue description info.
         */
        abstract createQueue(info: IGFXQueueInfo): GFXQueue;
        /**
         * @en Create fence.
         * @zh 创建同步信号。
         * @param info GFX fence description info.
         */
        abstract createFence(info: IGFXFenceInfo): GFXFence;
        /**
         * @en Copy buffers to texture.
         * @zh 拷贝缓冲到纹理。
         * @param buffers The buffers to be copied.
         * @param texture The texture to copy to.
         * @param regions The region descriptions.
         */
        abstract copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        /**
         * @en Copy texture images to texture.
         * @zh 拷贝图像到纹理。
         * @param texImages The texture to be copied.
         * @param texture The texture to copy to.
         * @param regions The region descriptions.
         */
        abstract copyTexImagesToTexture(texImages: TexImageSource[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        /**
         * @en Copy frame buffer to buffer.
         * @zh 拷贝帧缓冲到缓冲。
         * @param srcFramebuffer The frame buffer to be copied.
         * @param dstBuffer The buffer to copy to.
         * @param regions The region descriptions.
         */
        abstract copyFramebufferToBuffer(srcFramebuffer: GFXFramebuffer, dstBuffer: ArrayBuffer, regions: GFXBufferTextureCopy[]): void;
        /**
         * @en Blit frame buffers.
         * @zh 填充帧缓冲。
         * @param src The source frame buffer.
         * @param dst The destination frame buffer.
         * @param srcRect The source region.
         * @param dstRect The target region.
         * @param filter Filtering mode for the process.
         */
        abstract blitFramebuffer(src: GFXFramebuffer, dst: GFXFramebuffer, srcRect: GFXRect, dstRect: GFXRect, filter: GFXFilter): void;
        /**
         * @en Whether the device has specific feature.
         * @zh 是否具备特性。
         * @param feature The GFX feature to be queried.
         */
        hasFeature(feature: GFXFeature): boolean;
        /**
         * @en Generate shader ID.
         * @zh 生成 Shader ID。
         */
        genShaderId(): number;
        /**
         * @en Define a macro.
         * @zh 定义宏。
         * @param macro The macro name.
         * @param value The macro value.
         */
        defineMacro(macro: string, value?: string): void;
    }
}
declare module "cocos/core/gfx/buffer" {
    /**
     * @category gfx
     */
    import { GFXBufferFlags, GFXBufferUsage, GFXMemoryUsage, GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    export class GFXDrawInfo {
        vertexCount: number;
        firstVertex: number;
        indexCount: number;
        firstIndex: number;
        vertexOffset: number;
        instanceCount: number;
        firstInstance: number;
        constructor(vertexCount?: number, firstVertex?: number, indexCount?: number, firstIndex?: number, vertexOffset?: number, instanceCount?: number, firstInstance?: number);
    }
    export const GFX_DRAW_INFO_SIZE: number;
    export interface IGFXIndirectBuffer {
        drawInfos: GFXDrawInfo[];
    }
    export type GFXBufferSource = ArrayBuffer | IGFXIndirectBuffer;
    export interface IGFXBufferInfo {
        usage: GFXBufferUsage;
        memUsage: GFXMemoryUsage;
        size: number;
        /**
         * In bytes.
         */
        stride?: number;
        flags?: GFXBufferFlags;
    }
    export interface IGFXBufferViewInfo {
        buffer: GFXBuffer;
        offset: number;
        range: number;
    }
    /**
     * @en GFX buffer.
     * @zh GFX 缓冲。
     */
    export abstract class GFXBuffer extends GFXObject {
        /**
         * @en Usage type of the buffer.
         * @zh 缓冲使用方式。
         */
        get usage(): GFXBufferUsage;
        /**
         * @en Memory usage of the buffer.
         * @zh 缓冲的内存使用方式。
         */
        get memUsage(): GFXMemoryUsage;
        /**
         * @en Size of the buffer.
         * @zh 缓冲大小。
         */
        get size(): number;
        /**
         * @en Stride of the buffer.
         * @zh 缓冲步长。
         */
        get stride(): number;
        /**
         * @en Count of the buffer wrt. stride.
         * @zh 缓冲条目数量。
         */
        get count(): number;
        get flags(): GFXBufferFlags;
        /**
         * @en View of the back-up buffer, if specified.
         * @zh 备份缓冲视图。
         */
        get backupBuffer(): Uint8Array | null;
        protected _device: GFXDevice;
        protected _usage: GFXBufferUsage;
        protected _memUsage: GFXMemoryUsage;
        protected _size: number;
        protected _stride: number;
        protected _count: number;
        protected _flags: GFXBufferFlags;
        protected _bakcupBuffer: Uint8Array | null;
        protected _indirectBuffer: IGFXIndirectBuffer | null;
        protected _isBufferView: boolean;
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXBufferInfo | IGFXBufferViewInfo): boolean;
        abstract destroy(): void;
        /**
         * @en Resize the buffer.
         * @zh 重置缓冲大小。
         * @param size The new buffer size.
         */
        abstract resize(size: number): void;
        /**
         * @en Update the buffer data.
         * @zh 更新缓冲内容。
         * @param buffer The new buffer data.
         * @param offset Offset into the buffer.
         * @param size Size of the data to be updated.
         */
        abstract update(buffer: GFXBufferSource, offset?: number, size?: number): void;
    }
}
declare module "cocos/core/gfx/pipeline-layout" {
    /**
     * @category gfx
     */
    import { GFXObject } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { GFXDescriptorSetLayout } from "cocos/core/gfx/descriptor-set-layout";
    export interface IGFXPipelineLayoutInfo {
        setLayouts: GFXDescriptorSetLayout[];
    }
    /**
     * @en GFX pipeline layout.
     * @zh GFX 管线布局。
     */
    export abstract class GFXPipelineLayout extends GFXObject {
        get setLayouts(): GFXDescriptorSetLayout[];
        protected _device: GFXDevice;
        protected _setLayouts: GFXDescriptorSetLayout[];
        constructor(device: GFXDevice);
        abstract initialize(info: IGFXPipelineLayoutInfo): boolean;
        abstract destroy(): void;
    }
}
declare module "cocos/core/gfx/index" {
    export * from "cocos/core/gfx/descriptor-set";
    export * from "cocos/core/gfx/buffer";
    export * from "cocos/core/gfx/command-buffer";
    export * from "cocos/core/gfx/define";
    export * from "cocos/core/gfx/device";
    export * from "cocos/core/gfx/framebuffer";
    export * from "cocos/core/gfx/input-assembler";
    export * from "cocos/core/gfx/descriptor-set-layout";
    export * from "cocos/core/gfx/pipeline-layout";
    export * from "cocos/core/gfx/pipeline-state";
    export * from "cocos/core/gfx/fence";
    export * from "cocos/core/gfx/queue";
    export * from "cocos/core/gfx/render-pass";
    export * from "cocos/core/gfx/sampler";
    export * from "cocos/core/gfx/shader";
    export * from "cocos/core/gfx/texture";
}
declare module "cocos/core/geometry/spec" {
    /**
     * @category geometry
     */
    /**
     * @en
     * The raycast mode.
     * @zh
     * 射线检测模式。
     */
    export enum ERaycastMode {
        /**
         * @en
         * Detect and record all data.
         * @zh
         * 检测并记录所有的数据。
         */
        ALL = 0,
        /**
         * @en
         * Detect all, but record only the most recent data.
         * @zh
         * 检测所有，但只记录最近的数据。
         */
        CLOSEST = 1,
        /**
         * @en
         * Once the test is successful, the test is stopped and the data is recorded only once.
         * @zh
         * 一旦检测成功就停止检测，只会记录一次数据。
         */
        ANY = 2
    }
    /**
     * @en
     * The storage structure of the raycast results.
     * @zh
     * 射线检测结果的存储结构。
     */
    export interface IRaySubMeshResult {
        /**
         * @en
         * The distance between the hit point and the ray.
         * @zh
         * 击中点和射线的距离。
         */
        distance: number;
        /**
         * @en
         * The index of the triangle vertex 0。
         * @zh
         * 三角形顶点0的索引。
         */
        vertexIndex0: number;
        /**
         * @en
         * The index of the triangle vertex 1。
         * @zh
         * 三角形顶点1的索引
         */
        vertexIndex1: number;
        /**
         * @en
         * The index of the triangle vertex 2。
         * @zh
         * 三角形顶点2的索引
         */
        vertexIndex2: number;
    }
    /**
     * @en
     * The optional param structure of the `ray_subMesh`.
     * @zh
     * `ray_subMesh`的可选参数结构。
     */
    export interface IRaySubMeshOptions {
        /**
         * @en
         * The raycast mode，`ANY` by default.
         * @zh
         * 射线检测模式：[0, 1, 2]=>[`ALL`, `CLOSEST`, `ANY`]
         */
        mode: ERaycastMode;
        /**
         * @en
         * The maximum distance of the raycast, `Infinity` by default.
         * @zh
         * 射线检测的最大距离，默认为`Infinity`。
         */
        distance: number;
        /**
         * @en
         * An array used to store the results of a ray detection.
         * @zh
         * 用于存储射线检测结果的数组。
         */
        result?: IRaySubMeshResult[];
        /**
         * @en
         * Whether to detect the double-sided or not，`false` by default.
         * @zh
         * 是否检测双面，默认为`false`。
         */
        doubleSided?: boolean;
    }
    /**
     * @en
     * The optional param structure of the `ray_mesh`.
     * @zh
     * `ray_mesh`的可选参数结构。
     */
    export interface IRayMeshOptions extends IRaySubMeshOptions {
        /**
         * @en
         * The index of the sub mesh.
         * @zh
         * 子网格的索引。
         */
        subIndices?: number[];
    }
    /**
     * @en
     * The optional param structure of the `ray_model`.
     * @zh
     * `ray_model`的可选参数结构。
     */
    export interface IRayModelOptions extends IRayMeshOptions {
    }
}
declare module "cocos/core/geometry/intersect" {
    /**
     * 几何工具模块
     * @category geometry
     */
    import { Vec3 } from "cocos/core/math/index";
    import aabb from "cocos/core/geometry/aabb";
    import { capsule } from "cocos/core/geometry/capsule";
    import { frustum } from "cocos/core/geometry/frustum";
    import line from "cocos/core/geometry/line";
    import obb from "cocos/core/geometry/obb";
    import plane from "cocos/core/geometry/plane";
    import ray from "cocos/core/geometry/ray";
    import sphere from "cocos/core/geometry/sphere";
    import triangle from "cocos/core/geometry/triangle";
    import { RenderingSubMesh, Mesh } from "cocos/core/assets/mesh";
    import { IRaySubMeshOptions, IRayMeshOptions, IRayModelOptions } from "cocos/core/geometry/spec";
    import { scene } from "cocos/core/renderer/index";
    /**
     * @en
     * line-aabb intersect detect.
     * @zh
     * 线段与轴对齐包围盒的相交性检测
     * @param line 线段
     * @param aabb 轴对齐包围盒
     * @return {number} 0 或 非0
     */
    function line_aabb(line: line, aabb: aabb): number;
    /**
     * @en
     * line-obb intersect detect.
     * @zh
     * 线段与方向包围盒的相交性检测
     * @param line 线段
     * @param obb 方向包围盒
     * @return {number} 0 或 非0
     */
    function line_obb(line: line, obb: obb): number;
    /**
     * @en
     * line-sphere intersect detect.
     * @zh
     * 线段与球的相交性检测
     * @param line 线段
     * @param sphere 球
     * @return {number} 0 或 非0
     */
    function line_sphere(line: line, sphere: sphere): number;
    /**
     * @en
     * Algorithm of intersect detect for basic geometry.
     * @zh
     * 基础几何的相交性检测算法。
     */
    const intersect: {
        ray_sphere: (ray: ray, sphere: sphere) => number;
        ray_aabb: (ray: ray, aabb: aabb) => number;
        ray_obb: (ray: ray, obb: obb) => number;
        ray_plane: (ray: ray, plane: plane) => number;
        ray_triangle: (ray: ray, triangle: triangle, doubleSided?: boolean | undefined) => number;
        ray_capsule: (ray: ray, capsule: capsule) => number;
        ray_subMesh: (ray: ray, submesh: RenderingSubMesh, options?: IRaySubMeshOptions | undefined) => number;
        ray_mesh: (ray: ray, mesh: Mesh, options?: IRayMeshOptions | undefined) => number;
        ray_model: (r: ray, model: scene.Model, options?: IRayModelOptions | undefined) => number;
        line_sphere: typeof line_sphere;
        line_aabb: typeof line_aabb;
        line_obb: typeof line_obb;
        line_plane: (line: line, plane: plane) => number;
        line_triangle: (line: line, triangle: triangle, outPt?: Vec3 | undefined) => number;
        sphere_sphere: (sphere0: sphere, sphere1: sphere) => boolean;
        sphere_aabb: (sphere: sphere, aabb: aabb) => boolean;
        sphere_obb: (sphere: sphere, obb: obb) => boolean;
        sphere_plane: (sphere: sphere, plane: plane) => number;
        sphere_frustum: (sphere: sphere, frustum: frustum) => number;
        sphere_frustum_accurate: (sphere: sphere, frustum: frustum) => number;
        sphere_capsule: (sphere: sphere, capsule: capsule) => boolean;
        aabb_aabb: (aabb1: aabb, aabb2: aabb) => boolean;
        aabb_obb: (aabb: aabb, obb: obb) => number;
        aabb_plane: (aabb: aabb, plane: plane) => number;
        aabb_frustum: (aabb: aabb, frustum: frustum) => number;
        aabb_frustum_accurate: (aabb: aabb, frustum: frustum) => number;
        obb_obb: (obb1: obb, obb2: obb) => number;
        obb_plane: (obb: obb, plane: plane) => number;
        obb_frustum: (obb: obb, frustum: frustum) => number;
        obb_frustum_accurate: (obb: obb, frustum: frustum) => number;
        obb_point: (obb: obb, point: Vec3) => boolean;
        obb_capsule: (obb: obb, capsule: capsule) => boolean | 1 | 0;
        capsule_capsule: (capsuleA: capsule, capsuleB: capsule) => boolean;
        /**
         * @zh
         * g1 和 g2 的相交性检测，可填入基础几何中的形状。
         * @param g1 几何1
         * @param g2 几何2
         * @param outPt 可选，相交点。（注：仅部分形状的检测带有这个返回值）
         */
        resolve(g1: any, g2: any, outPt?: null): any;
    };
    export default intersect;
}
declare module "cocos/core/geometry/curve" {
    /**
     * @en
     * A key frame in the curve.
     * @zh
     * 曲线中的一个关键帧。
     */
    export class Keyframe {
        /**
         * @zh 当前帧时间。
         */
        time: number;
        /**
         * @zh 当前帧的值。
         */
        value: number;
        /**
         * @zh 左切线。
         */
        inTangent: number;
        /**
         * @zh 右切线。
         */
        outTangent: number;
    }
    export class OptimizedKey {
        index: number;
        time: number;
        endTime: number;
        coefficient: Float32Array;
        constructor();
        evaluate(T: number): number;
    }
    export function evalOptCurve(t: number, coefs: Float32Array | number[]): number;
    /**
     * @en
     * Describe a curve in which three times Hermite interpolation is used for each adjacent key frame.
     * @zh
     * 描述一条曲线，其中每个相邻关键帧采用三次hermite插值计算。
     */
    export class AnimationCurve {
        private static defaultKF;
        /**
         * @en
         * The key frame of the curve.
         * @zh
         * 曲线的关键帧。
         */
        keyFrames: Keyframe[] | null;
        /**
         * @en
         * Loop mode [[WrapMode]] when the sampling time exceeds the left end.
         * @zh
         * 当采样时间超出左端时采用的循环模式[[WrapMode]]。
         */
        preWrapMode: number;
        /**
         * @en
         * Cycle mode [[WrapMode]] when the sampling time exceeds the right end.
         * @zh
         * 当采样时间超出右端时采用的循环模式[[WrapMode]]。
         */
        postWrapMode: number;
        private cachedKey;
        /**
         * 构造函数。
         * @param keyFrames 关键帧。
         */
        constructor(keyFrames?: Keyframe[] | null);
        /**
         * @en
         * Add a keyframe.
         * @zh
         * 添加一个关键帧。
         * @param keyFrame 关键帧。
         */
        addKey(keyFrame: Keyframe): void;
        /**
         * @ignore
         * @param time
         */
        evaluate_slow(time: number): number;
        /**
         * @en
         * Calculate the curve interpolation at a given point in time.
         * @zh
         * 计算给定时间点的曲线插值。
         * @param time 时间。
         */
        evaluate(time: number): number;
        /**
         * @ignore
         * @param optKey
         * @param leftIndex
         * @param rightIndex
         */
        calcOptimizedKey(optKey: OptimizedKey, leftIndex: number, rightIndex: number): void;
        /**
         * @ignore
         * @param optKey
         * @param t
         */
        private findIndex;
    }
}
declare module "cocos/core/geometry/deprecated" { }
declare module "cocos/core/geometry/index" {
    /**
     * @category geometry
     */
    export { default as enums } from "cocos/core/geometry/enums";
    import * as distance from "cocos/core/geometry/distance";
    export { distance };
    export { default as intersect } from "cocos/core/geometry/intersect";
    export { default as line } from "cocos/core/geometry/line";
    export { default as plane } from "cocos/core/geometry/plane";
    export { default as ray } from "cocos/core/geometry/ray";
    export { default as triangle } from "cocos/core/geometry/triangle";
    export { default as sphere } from "cocos/core/geometry/sphere";
    export { default as aabb } from "cocos/core/geometry/aabb";
    export { default as obb } from "cocos/core/geometry/obb";
    export { capsule } from "cocos/core/geometry/capsule";
    export { frustum } from "cocos/core/geometry/frustum";
    export { Keyframe, AnimationCurve } from "cocos/core/geometry/curve";
    export * from "cocos/core/geometry/spec";
    import "cocos/core/geometry/deprecated";
}
declare module "cocos/core/assets/utils/mesh-utils" {
    import { Mesh } from "cocos/core/assets/mesh";
    export function postLoadMesh(mesh: Mesh, callback?: Function): void;
}
declare module "cocos/core/assets/mesh" {
    import { Mat4, Vec3 } from "cocos/core/math/index";
    import { aabb } from "cocos/core/geometry/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { GFXAttributeName, GFXPrimitiveMode } from "cocos/core/gfx/define";
    import { GFXDevice } from "cocos/core/gfx/device";
    import { IGFXAttribute, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { Asset } from "cocos/core/assets/asset";
    import { Skeleton } from "cocos/core/assets/skeleton";
    import { Morph, MorphRendering } from "cocos/core/assets/morph";
    /**
     * 允许存储索引的数组视图。
     */
    export type IBArray = Uint8Array | Uint16Array | Uint32Array;
    /**
     * 几何信息。
     */
    export interface IGeometricInfo {
        /**
         * 顶点位置。
         */
        positions: Float32Array;
        /**
         * 索引数据。
         */
        indices?: IBArray;
        /**
         * 是否将图元按双面对待。
         */
        doubleSided?: boolean;
        /**
         * 此几何体的轴对齐包围盒。
         */
        boundingBox: {
            max: Vec3;
            min: Vec3;
        };
    }
    export interface IFlatBuffer {
        stride: number;
        count: number;
        buffer: Uint8Array;
    }
    /**
     * 渲染子网格。
     */
    export class RenderingSubMesh implements IGFXInputAssemblerInfo {
        /**
         * 使用的所有顶点缓冲区。
         */
        vertexBuffers: GFXBuffer[];
        /**
         * 所有顶点属性。
         */
        attributes: IGFXAttribute[];
        /**
         * 图元类型。
         */
        primitiveMode: GFXPrimitiveMode;
        /**
         * 使用的索引缓冲区，若未使用则无需指定。
         */
        indexBuffer?: GFXBuffer;
        /**
         * 间接绘制缓冲区。
         */
        indirectBuffer?: GFXBuffer;
        /**
         * （用于射线检测的）几何信息。
         */
        get geometricInfo(): IGeometricInfo;
        /**
         * 扁平化的顶点缓冲区。
         */
        get flatBuffers(): IFlatBuffer[];
        /**
         * 骨骼索引按映射表处理后的顶点缓冲。
         */
        get jointMappedBuffers(): GFXBuffer[];
        mesh?: Mesh;
        subMeshIdx?: number;
        private _flatBuffers?;
        private _jointMappedBuffers?;
        private _jointMappedBufferIndices?;
        private _vertexIdChannel?;
        private _geometricInfo?;
        constructor(vertexBuffers: GFXBuffer[], attributes: IGFXAttribute[], primitiveMode: GFXPrimitiveMode);
        destroy(): void;
        /**
         * Adds a vertex attribute input called 'a_vertexId' into this sub-mesh.
         * This is useful if you want to simulate `gl_VertexId` in WebGL context prior to 2.0.
         * Once you call this function, the vertex attribute is permanently added.
         * Subsequent calls to this function take no effect.
         * @param device Device used to create related rendering resources.
         */
        enableVertexIdChannel(device: GFXDevice): void;
        private _allocVertexIdBuffer;
    }
    export namespace Mesh {
        interface IBufferView {
            offset: number;
            length: number;
            count: number;
            stride: number;
        }
        /**
         * @zh
         * 顶点块。顶点块描述了一组**交错排列**（interleaved）的顶点属性并存储了顶点属性的实际数据。<br>
         * 交错排列是指在实际数据的缓冲区中，每个顶点的所有属性总是依次排列，并总是出现在下一个顶点的所有属性之前。
         */
        interface IVertexBundle {
            /**
             * 所有顶点属性的实际数据块。
             * 你必须使用 DataView 来读取数据。
             * 因为不能保证所有属性的起始偏移都按 TypedArray 要求的字节对齐。
             */
            view: IBufferView;
            /**
             * 包含的所有顶点属性。
             */
            attributes: IGFXAttribute[];
        }
        /**
         * 子网格。子网格由一系列相同类型的图元组成（例如点、线、面等）。
         */
        interface ISubMesh {
            /**
             * 此子网格引用的顶点块，索引至网格的顶点块数组。
             */
            vertexBundelIndices: number[];
            /**
             * 此子网格的图元类型。
             */
            primitiveMode: GFXPrimitiveMode;
            /**
             * 此子网格使用的索引数据。
             */
            indexView?: IBufferView;
            /**
             * 此子网格使用的关节索引映射表在 IStruct.jointMaps 中的索引。
             * 如未定义或指向的映射表不存在，则默认 VB 内所有关节索引数据直接对应骨骼资源数据。
             */
            jointMapIndex?: number;
        }
        /**
         * 描述了网格的结构。
         */
        interface IStruct {
            /**
             * 此网格所有的顶点块。
             */
            vertexBundles: IVertexBundle[];
            /**
             * 此网格的所有子网格。
             */
            primitives: ISubMesh[];
            /**
             * （各分量都）小于等于此网格任何顶点位置的最大位置。
             */
            minPosition?: Vec3;
            /**
             * （各分量都）大于等于此网格任何顶点位置的最小位置。
             */
            maxPosition?: Vec3;
            /**
             * 此网格使用的关节索引映射关系列表，数组长度应为子模型中实际使用到的所有关节，
             * 每个元素都对应一个原骨骼资源里的索引，按子模型 VB 内的实际索引排列。
             */
            jointMaps?: number[][];
            morph?: Morph;
        }
        interface ICreateInfo {
            /**
             * 网格结构。
             */
            struct: Mesh.IStruct;
            /**
             * 网格二进制数据。
             */
            data: Uint8Array;
        }
    }
    /**
     * 网格资源。
     */
    export class Mesh extends Asset {
        get _nativeAsset(): ArrayBuffer;
        set _nativeAsset(value: ArrayBuffer);
        /**
         * 此网格的子网格数量。
         * @deprecated 请使用 `this.renderingMesh.subMeshCount`。
         */
        get subMeshCount(): number;
        /**
         * （各分量都）小于等于此网格任何顶点位置的最大位置。
         * @deprecated 请使用 `this.struct.minPosition`。
         */
        get minPosition(): Vec3 | undefined;
        /**
         * （各分量都）大于等于此网格任何顶点位置的最大位置。
         * @deprecated 请使用 `this.struct.maxPosition`。
         */
        get maxPosition(): Vec3 | undefined;
        /**
         * 此网格的结构。
         */
        get struct(): Mesh.IStruct;
        /**
         * 此网格的数据。
         */
        get data(): Uint8Array;
        /**
         * 此网格的哈希值。
         */
        get hash(): number;
        get jointBufferIndices(): number[];
        private _struct;
        private _dataLength;
        private _hash;
        private _data;
        private _initialized;
        private _renderingSubMeshes;
        private _boneSpaceBounds;
        private _jointBufferIndices;
        constructor();
        initialize(): void;
        /**
         * 销毁此网格，并释放它占有的所有 GPU 资源。
         */
        destroy(): boolean;
        /**
         * 释放此网格占有的所有 GPU 资源。
         */
        destroyRenderingMesh(): void;
        /**
         * 重置此网格的结构和数据。
         * @param struct 新的结构。
         * @param data 新的数据。
         * @deprecated 将在 V1.0.0 移除，请转用 `this.reset()`。
         */
        assign(struct: Mesh.IStruct, data: Uint8Array): void;
        /**
         * 重置此网格。
         * @param info 网格重置选项。
         */
        reset(info: Mesh.ICreateInfo): void;
        /**
         * 此网格创建的渲染网格。
         */
        get renderingSubMeshes(): RenderingSubMesh[];
        getBoneSpaceBounds(skeleton: Skeleton): (aabb | null)[];
        /**
         * 合并指定的网格到此网格中。
         * @param mesh 合并的网格。
         * @param worldMatrix 合并的网格的世界变换矩阵
         * @param [validate=false] 是否进行验证。
         * @returns 是否验证成功。若验证选项为 `true` 且验证未通过则返回 `false`，否则返回 `true`。
         */
        merge(mesh: Mesh, worldMatrix?: Mat4, validate?: boolean): boolean;
        /**
         * 验证指定网格是否可以合并至当前网格。
         *
         * 当满足以下条件之一时，指定网格可以合并至当前网格：
         *  - 当前网格无数据而待合并网格有数据；
         *  - 它们的顶点块数目相同且对应顶点块的布局一致，并且它们的子网格数目相同且对应子网格的布局一致。
         *
         * 两个顶点块布局一致当且仅当：
         *  - 它们具有相同数量的顶点属性且对应的顶点属性具有相同的属性格式。
         *
         * 两个子网格布局一致，当且仅当：
         *  - 它们具有相同的图元类型并且引用相同数量、相同索引的顶点块；并且，
         *  - 要么都需要索引绘制，要么都不需要索引绘制。
         * @param mesh 指定的网格。
         */
        validateMergingMesh(mesh: Mesh): boolean;
        /**
         * 读取子网格的指定属性。
         * @param primitiveIndex 子网格索引。
         * @param attributeName 属性名称。
         * @returns 不存在指定的子网格、子网格不存在指定的属性或属性无法读取时返回 `null`，
         * 否则，创建足够大的缓冲区包含指定属性的所有数据，并为该缓冲区创建与属性类型对应的数组视图。
         */
        readAttribute(primitiveIndex: number, attributeName: GFXAttributeName): Storage | null;
        /**
         * 读取子网格的指定属性到目标缓冲区中。
         * @param primitiveIndex 子网格索引。
         * @param attributeName 属性名称。
         * @param buffer 目标缓冲区。
         * @param stride 相邻属性在目标缓冲区的字节间隔。
         * @param offset 首个属性在目标缓冲区中的偏移。
         * @returns 不存在指定的子网格、子网格不存在指定的属性或属性无法读取时返回 `false`，否则返回 `true`。
         */
        copyAttribute(primitiveIndex: number, attributeName: GFXAttributeName, buffer: ArrayBuffer, stride: number, offset: number): boolean;
        /**
         * 读取子网格的索引数据。
         * @param primitiveIndex 子网格索引。
         * @returns 不存在指定的子网格或子网格不存在索引数据时返回 `null`，
         * 否则，创建足够大的缓冲区包含所有索引数据，并为该缓冲区创建与索引类型对应的数组视图。
         */
        readIndices(primitiveIndex: number): Uint8Array | Uint16Array | Uint32Array | null;
        /**
         * 读取子网格的索引数据到目标数组中。
         * @param primitiveIndex 子网格索引。
         * @param outputArray 目标数组。
         * @returns 不存在指定的子网格或子网格不存在索引数据时返回 `false`，否则返回 `true`。
         */
        copyIndices(primitiveIndex: number, outputArray: number[] | ArrayBufferView): boolean;
        private _accessAttribute;
        private _createVertexBuffers;
        morphRendering: MorphRendering | null;
    }
}
declare module "cocos/core/renderer/scene/render-scene" {
    import { ray } from "cocos/core/geometry/index";
    import { Root } from "cocos/core/root";
    import { Node } from "cocos/core/scene-graph/index";
    import { Camera } from "cocos/core/renderer/scene/camera";
    import { DirectionalLight } from "cocos/core/renderer/scene/directional-light";
    import { Model } from "cocos/core/renderer/scene/model";
    import { SphereLight } from "cocos/core/renderer/scene/sphere-light";
    import { SpotLight } from "cocos/core/renderer/scene/spot-light";
    export interface IRenderSceneInfo {
        name: string;
    }
    export interface ISceneNodeInfo {
        name: string;
        isStatic?: boolean;
    }
    export interface IRaycastResult {
        node: Node;
        distance: number;
    }
    export class RenderScene {
        get root(): Root;
        get name(): string;
        get cameras(): Camera[];
        get mainLight(): DirectionalLight | null;
        get sphereLights(): SphereLight[];
        get spotLights(): SpotLight[];
        get models(): Model[];
        /**
         * @zh
         * 获取 raycastAllCanvas 后的检测结果
         */
        get rayResultCanvas(): IRaycastResult[];
        /**
         * @zh
         * 获取 raycastAllModels 后的检测结果
         */
        get rayResultModels(): IRaycastResult[];
        /**
         * @zh
         * 获取 raycastAll 后的检测结果
         */
        get rayResultAll(): IRaycastResult[];
        /**
         * @zh
         * 获取 raycastSingleModel 后的检测结果
         */
        get rayResultSingleModel(): IRaycastResult[];
        static registerCreateFunc(root: Root): void;
        private _root;
        private _name;
        private _cameras;
        private _models;
        private _directionalLights;
        private _sphereLights;
        private _spotLights;
        private _mainLight;
        private _modelId;
        constructor(root: Root);
        initialize(info: IRenderSceneInfo): boolean;
        update(stamp: number): void;
        destroy(): void;
        addCamera(cam: Camera): void;
        removeCamera(camera: Camera): void;
        removeCameras(): void;
        setMainLight(dl: DirectionalLight): void;
        unsetMainLight(dl: DirectionalLight): void;
        addDirectionalLight(dl: DirectionalLight): void;
        removeDirectionalLight(dl: DirectionalLight): void;
        addSphereLight(pl: SphereLight): void;
        removeSphereLight(pl: SphereLight): void;
        addSpotLight(sl: SpotLight): void;
        removeSpotLight(sl: SpotLight): void;
        removeSphereLights(): void;
        removeSpotLights(): void;
        addModel(m: Model): void;
        removeModel(model: Model): void;
        removeModels(): void;
        onGlobalPipelineStateChanged(): void;
        generateModelId(): number;
        /**
         * @en
         * Cast a ray into the scene, record all the intersected models and ui2d nodes in the result array
         * @param worldRay the testing ray
         * @param mask the layer mask to filter the models
         * @param distance the max distance , Infinity by default
         * @returns boolean , ray is hit or not
         * @note getter of this.rayResultAll can get recently result
         * @zh
         * 传入一条射线检测场景中所有的 3D 模型和 UI2D Node
         * @param worldRay 世界射线
         * @param mask mask 用于标记所有要检测的层，默认为 Default | UI2D
         * @param distance 射线检测的最大距离, 默认为 Infinity
         * @returns boolean , 射线是否有击中
         * @note 通过 this.rayResultAll 可以获取到最近的结果
         */
        raycastAll(worldRay: ray, mask?: number, distance?: number): boolean;
        /**
         * @en
         * Cast a ray into the scene, record all the intersected models in the result array
         * @param worldRay the testing ray
         * @param mask the layer mask to filter the models
         * @param distance the max distance , Infinity by default
         * @returns boolean , ray is hit or not
         * @note getter of this.rayResultModels can get recently result
         * @zh
         * 传入一条射线检测场景中所有的 3D 模型。
         * @param worldRay 世界射线
         * @param mask 用于标记所有要检测的层，默认为 Default
         * @param distance 射线检测的最大距离, 默认为 Infinity
         * @returns boolean , 射线是否有击中
         * @note 通过 this.rayResultModels 可以获取到最近的结果
         */
        raycastAllModels(worldRay: ray, mask?: number, distance?: number): boolean;
        /**
         * @en
         * Before you raycast the model, make sure the model is not null
         * @param worldRay the testing ray
         * @param model the testing model
         * @param mask the layer mask to filter the models
         * @param distance the max distance , Infinity by default
         * @returns boolean , ray is hit or not
         * @zh
         * 传入一条射线和一个 3D 模型进行射线检测。
         * @param worldRay 世界射线
         * @param model 进行检测的模型
         * @param mask 用于标记所有要检测的层，默认为 Default
         * @param distance 射线检测的最大距离, 默认为 Infinity
         * @returns boolean , 射线是否有击中
         */
        raycastSingleModel(worldRay: ray, model: Model, mask?: number, distance?: number): boolean;
        /**
         * @en
         * Cast a ray into the scene, detect all canvas and its children
         * @param worldRay the testing ray
         * @param mask the layer mask to filter all ui2d aabb
         * @param distance the max distance , Infinity by default
         * @returns boolean , ray is hit or not
         * @note getter of this.rayResultCanvas can get recently result
         * @zh
         * 传入一条射线检测场景中所有的 Canvas 以及 Canvas 下的 Node
         * @param worldRay 世界射线
         * @param mask 用于标记所有要检测的层，默认为 UI_2D
         * @param distance 射线检测的最大距离, 默认为 Infinity
         * @returns boolean , 射线是否有击中
         * @note 通过 this.rayResultCanvas 可以获取到最近的结果
         */
        raycastAllCanvas(worldRay: ray, mask?: number, distance?: number): boolean;
        private _raycastUI2DNode;
        private _raycastUI2DNodeRecursiveChildren;
    }
}
declare module "cocos/core/components/component" {
    import { CCObject } from "cocos/core/data/object";
    import { RenderScene } from "cocos/core/renderer/scene/render-scene";
    import { Rect } from "cocos/core/math/index";
    import { Node } from "cocos/core/scene-graph/index";
    /**
     * @en
     * Base class for everything attached to Node(Entity).<br/>
     * <br/>
     * NOTE: Not allowed to use construction parameters for Component's subclasses,
     *       because Component is created by the engine.
     * @zh
     * 所有附加到节点的基类。<br/>
     * <br/>
     * 注意：不允许使用组件的子类构造参数，因为组件是由引擎创建的。
     *
     * @class Component
     * @extends Object
     */
    class Component extends CCObject {
        get name(): string;
        set name(value: string);
        /**
         * @en The uuid for editor.
         * @zh 组件的 uuid，用于编辑器。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.uuid);
         * ```
         */
        get uuid(): string;
        get __scriptAsset(): null;
        /**
         * @en indicates whether this component is enabled or not.
         * @zh 表示该组件自身是否启用。
         * @default true
         * @example
         * ```ts
         * import { log } from 'cc';
         * comp.enabled = true;
         * log(comp.enabled);
         * ```
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        /**
         * @en indicates whether this component is enabled and its node is also active in the hierarchy.
         * @zh 表示该组件是否被启用并且所在的节点也处于激活状态。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.enabledInHierarchy);
         * ```
         */
        get enabledInHierarchy(): boolean;
        /**
         * @en Returns a value which used to indicate the onLoad get called or not.
         * @zh 返回一个值用来判断 onLoad 是否被调用过，不等于 0 时调用过，等于 0 时未调用。
         * @readOnly
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(this._isOnLoadCalled > 0);
         * ```
         */
        get _isOnLoadCalled(): number;
        static system: null;
        /**
         * @en The node this component is attached to. A component is always attached to a node.
         * @zh 该组件被附加到的节点。组件总会附加到一个节点。
         * @example
         * ```ts
         * import { log } from 'cc';
         * log(comp.node);
         * ```
         */
        node: Node;
        /**
         * @private
         */
        _enabled: boolean;
        _sceneGetter: null | (() => RenderScene);
        /**
         * For internal usage.
         */
        _id: string;
        _getRenderScene(): RenderScene;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprite = node.addComponent(Sprite);
         * ```
         */
        addComponent<T extends Component>(classConstructor: Constructor<T>): T | null;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @example
         * ```ts
         * const test = node.addComponent("Test");
         * ```
         */
        addComponent(className: string): Component | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.<br/>
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。<br/>
         * 传入参数也可以是脚本的名称。
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * // get sprite component.
         * var sprite = node.getComponent(Sprite);
         * ```
         */
        getComponent<T extends Component>(classConstructor: Constructor<T>): T | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.<br/>
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。<br/>
         * 传入参数也可以是脚本的名称。
         * @example
         * ```ts
         * // get custom test calss.
         * var test = node.getComponent("Test");
         * ```
         */
        getComponent(className: string): Component | null;
        /**
         * @en Returns all components of supplied type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprites = node.getComponents(Sprite);
         * ```
         */
        getComponents<T extends Component>(classConstructor: Constructor<T>): T[];
        /**
         * @en Returns all components of supplied type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @example
         * ```ts
         * const tests = node.getComponents("Test");
         * ```
         */
        getComponents(className: string): Component[];
        /**
         * @en Returns the component of supplied type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprite = node.getComponentInChildren(Sprite);
         * ```
         */
        getComponentInChildren<T extends Component>(classConstructor: Constructor<T>): T | null;
        /**
         * @en Returns the component of supplied type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @example
         * ```ts
         * var Test = node.getComponentInChildren("Test");
         * ```
         */
        getComponentInChildren(className: string): Component | null;
        /**
         * @en Returns all components of supplied type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件。
         * @example
         * ```ts
         * import { Sprite } from 'cc';
         * const sprites = node.getComponentsInChildren(Sprite);
         * ```
         */
        getComponentsInChildren<T extends Component>(classConstructor: Constructor<T>): T[];
        /**
         * @en Returns all components of supplied type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件。
         * @example
         * ```ts
         * const tests = node.getComponentsInChildren("Test");
         * ```
         */
        getComponentsInChildren(className: string): Component[];
        destroy(): boolean;
        _onPreDestroy(): void;
        _instantiate(cloned: any): any;
        /**
         * @en
         * Schedules a custom selector.<br/>
         * If the selector is already scheduled, then the interval parameter will be updated without scheduling it again.
         * @zh
         * 调度一个自定义的回调函数。<br/>
         * 如果回调函数已调度，那么将不会重复调度它，只会更新时间间隔参数。
         * @method schedule
         * @param {function} callback 回调函数。
         * @param {Number} interval  时间间隔，0 表示每帧都重复。
         * @param {Number} repeat    将被重复执行（repeat+ 1）次，您可以使用 cc.macro.REPEAT_FOREVER 进行无限次循环。
         * @param {Number} delay     第一次执行前等待的时间（延时执行）。
         * @example
         * ```ts
         * import { log } from 'cc';
         * this.schedule((dt) => void log(`time: ${dt}`), 1);
         * ```
         */
        schedule(callback: any, interval?: number, repeat?: number, delay?: number): void;
        /**
         * @en Schedules a callback function that runs only once, with a delay of 0 or larger.
         * @zh 调度一个只运行一次的回调函数，可以指定 0 让回调函数在下一帧立即执行或者在一定的延时之后执行。
         * @method scheduleOnce
         * @see [[schedule]]
         * @param {function} callback  回调函数。
         * @param {Number} delay  第一次执行前等待的时间（延时执行）。
         * @example
         * ```ts
         * import { log } from 'cc';
         * this.scheduleOnce((dt) => void log(`time: ${dt}`), 2);
         * ```
         */
        scheduleOnce(callback: any, delay?: number): void;
        /**
         * @en Un-schedules a custom callback function.
         * @zh 取消调度一个自定义的回调函数。
         * @param {function} callback_fn  回调函数。
         * @example
         * ```ts
         * this.unschedule(_callback);
         * ```
         */
        unschedule(callback_fn: any): void;
        /**
         * @en
         * unschedule all scheduled callback functions: custom callback functions, and the 'update' callback function.<br/>
         * Actions are not affected by this method.
         * @zh 取消调度所有已调度的回调函数：定制的回调函数以及 'update' 回调函数。动作不受此方法影响。
         * @method unscheduleAllCallbacks
         * @example
         * ```ts
         * this.unscheduleAllCallbacks();
         * ```
         */
        unscheduleAllCallbacks(): void;
        /**
         * @en Update is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 update。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        protected update?(dt: number): void;
        /**
         * @en LateUpdate is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 LateUpdate。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        protected lateUpdate?(dt: number): void;
        /**
         * @en `__preload` is called before every onLoad.<br/>
         * It is used to initialize the builtin components internally,<br/>
         * to avoid checking whether onLoad is called before every public method calls.<br/>
         * This method should be removed if script priority is supported.
         * @zh `__preload` 在每次onLoad之前调用。<br/>
         * 它用于在内部初始化内置组件，<br/>
         * 以避免在每次公有方法调用之前检查是否调用了onLoad。<br/>
         * 如果支持脚本优先级，则应删除此方法。
         * @private
         */
        protected __preload?(): void;
        /**
         * @en
         * When attaching to an active node or its node first activated.<br/>
         * onLoad is always called before any start functions, this allows you to order initialization of scripts.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 当附加到一个激活的节点上或者其节点第一次激活时候调用。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onLoad?(): void;
        /**
         * @en
         * Called before all scripts' update if the Component is enabled the first time.<br/>
         * Usually used to initialize some logic which need to be called after all components' `onload` methods called.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 如果该组件第一次启用，则在所有组件的 update 之前调用。通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected start?(): void;
        /**
         * @en Called when this component becomes enabled and its node is active.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被启用，并且它的节点也激活时。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onEnable?(): void;
        /**
         * @en Called when this component becomes disabled or its node becomes inactive.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被禁用或节点变为无效时调用。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onDisable?(): void;
        /**
         * @en Called when this component will be destroyed.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被销毁时调用<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        protected onDestroy?(): void;
        onFocusInEditor?(): void;
        onLostFocusInEditor?(): void;
        /**
         * @en Called to initialize the component or node’s properties when adding the component the first time or when the Reset command is used.
         * This function is only called in editor.<br/>
         * @zh 用来初始化组件或节点的一些属性，当该组件被第一次添加到节点上或用户点击了它的 Reset 菜单时调用。这个回调只会在编辑器下调用。
         */
        resetInEditor?(): void;
        /**
         * @en
         * If the component's bounding box is different from the node's, you can implement this method to supply
         * a custom axis aligned bounding box (AABB), so the editor's scene view can perform hit test properly.
         * @zh
         * 如果组件的包围盒与节点不同，您可以实现该方法以提供自定义的轴向对齐的包围盒（AABB），
         * 以便编辑器的场景视图可以正确地执行点选测试。
         * @param out_rect - 提供包围盒的 Rect
         */
        protected _getLocalBounds?(out_rect: Rect): void;
        /**
         * @en
         * onRestore is called after the user clicks the Reset item in the Inspector's context menu or performs
         * an undo operation on this component.<br/>
         * <br/>
         * If the component contains the "internal state", short for "temporary member variables which not included<br/>
         * in its CCClass properties", then you may need to implement this function.<br/>
         * <br/>
         * The editor will call the getset accessors of your component to record/restore the component's state<br/>
         * for undo/redo operation. However, in extreme cases, it may not works well. Then you should implement<br/>
         * this function to manually synchronize your component's "internal states" with its public properties.<br/>
         * Once you implement this function, all the getset accessors of your component will not be called when<br/>
         * the user performs an undo/redo operation. Which means that only the properties with default value<br/>
         * will be recorded or restored by editor.<br/>
         * <br/>
         * Similarly, the editor may failed to reset your component correctly in extreme cases. Then if you need<br/>
         * to support the reset menu, you should manually synchronize your component's "internal states" with its<br/>
         * properties in this function. Once you implement this function, all the getset accessors of your component<br/>
         * will not be called during reset operation. Which means that only the properties with default value<br/>
         * will be reset by editor.
         *
         * This function is only called in editor mode.
         * @zh
         * onRestore 是用户在检查器菜单点击 Reset 时，对此组件执行撤消操作后调用的。<br/>
         * <br/>
         * 如果组件包含了“内部状态”（不在 CCClass 属性中定义的临时成员变量），那么你可能需要实现该方法。<br/>
         * <br/>
         * 编辑器执行撤销/重做操作时，将调用组件的 get set 来录制和还原组件的状态。
         * 然而，在极端的情况下，它可能无法良好运作。<br/>
         * 那么你就应该实现这个方法，手动根据组件的属性同步“内部状态”。
         * 一旦你实现这个方法，当用户撤销或重做时，组件的所有 get set 都不会再被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器记录和还原。<br/>
         * <br/>
         * 同样的，编辑可能无法在极端情况下正确地重置您的组件。<br/>
         * 于是如果你需要支持组件重置菜单，你需要在该方法中手工同步组件属性到“内部状态”。<br/>
         * 一旦你实现这个方法，组件的所有 get set 都不会在重置操作时被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器重置。
         * <br/>
         * 此方法仅在编辑器下会被调用。
         */
        protected onRestore?(): void;
    }
    export { Component };
}
declare module "cocos/core/scene-graph/base-node-dev" {
    export function baseNodePolyfill(BaseNode: any): void;
}
declare module "cocos/core/scene-graph/base-node" {
    /**
     * @category scene-graph
     */
    import { Component } from "cocos/core/components/component";
    import { CCObject } from "cocos/core/data/object";
    import { Event } from "cocos/core/event/index";
    import { SystemEventType } from "cocos/core/platform/event-manager/event-enum";
    import { ISchedulable } from "cocos/core/scheduler";
    import IdGenerator from "cocos/core/utils/id-generator";
    import { NodeEventProcessor } from "cocos/core/scene-graph/node-event-processor";
    import { Node } from "cocos/core/scene-graph/node";
    import { Scene } from "cocos/core/scene-graph/scene";
    type Constructor<T = {}> = new (...args: any[]) => T;
    export const TRANSFORM_ON: number;
    /**
     * @en The base class for [[Node]], it:
     * - maintains scene hierarchy and life cycle logic
     * - provides EventTarget ability
     * - emits events if some properties changed, ref: [[SystemEventType]]
     * - manages components
     * @zh [[Node]] 的基类，他会负责：
     * - 维护场景树以及节点生命周期管理
     * - 提供 EventTarget 的事件管理和注册能力
     * - 派发节点状态相关的事件，参考：[[SystemEventType]]
     * - 管理组件
     */
    export class BaseNode extends CCObject implements ISchedulable {
        /**
         * @en Gets all components attached to this node.
         * @zh 获取附加到此节点的所有组件。
         */
        get components(): ReadonlyArray<Component>;
        /**
         * @en If true, the node is an persist node which won't be destroyed during scene transition.
         * If false, the node will be destroyed automatically when loading a new scene. Default is false.
         * @zh 如果为true，则该节点是一个常驻节点，不会在场景转换期间被销毁。
         * 如果为false，节点将在加载新场景时自动销毁。默认为 false。
         * @default false
         * @protected
         */
        get _persistNode(): boolean;
        set _persistNode(value: boolean);
        /**
         * @en Name of node.
         * @zh 该节点名称。
         */
        get name(): string;
        set name(value: string);
        /**
         * @en The uuid for editor, will be stripped after building project.
         * @zh 主要用于编辑器的 uuid，在编辑器下可用于持久化存储，在项目构建之后将变成自增的 id。
         * @readOnly
         */
        get uuid(): string;
        /**
         * @en All children nodes.
         * @zh 节点的所有子节点。
         * @readOnly
         */
        get children(): this[];
        /**
         * @en
         * The local active state of this node.
         * Note that a Node may be inactive because a parent is not active, even if this returns true.
         * Use [[activeInHierarchy]]
         * if you want to check if the Node is actually treated as active in the scene.
         * @zh
         * 当前节点的自身激活状态。
         * 值得注意的是，一个节点的父节点如果不被激活，那么即使它自身设为激活，它仍然无法激活。
         * 如果你想检查节点在场景中实际的激活状态可以使用 [[activeInHierarchy]]
         * @default true
         */
        get active(): boolean;
        set active(isActive: boolean);
        /**
         * @en Indicates whether this node is active in the scene.
         * @zh 表示此节点是否在场景中激活。
         */
        get activeInHierarchy(): boolean;
        /**
         * @en The parent node
         * @zh 父节点
         */
        get parent(): this | null;
        set parent(value: this | null);
        /**
         * @en Which scene this node belongs to.
         * @zh 此节点属于哪个场景。
         * @readonly
         */
        get scene(): any;
        /**
         * @en The event processor of the current node, it provides EventTarget ability.
         * @zh 当前节点的事件处理器，提供 EventTarget 能力。
         * @readonly
         */
        get eventProcessor(): NodeEventProcessor;
        static _setScene(node: BaseNode): void;
        protected static idGenerator: IdGenerator;
        protected static _stacks: Array<Array<(BaseNode | null)>>;
        protected static _stackId: number;
        protected static _findComponent(node: BaseNode, constructor: Function): Component | null;
        protected static _findComponents(node: BaseNode, constructor: Function, components: Component[]): void;
        protected static _findChildComponent(children: BaseNode[], constructor: any): any;
        protected static _findChildComponents(children: BaseNode[], constructor: any, components: any): void;
        protected _parent: this | null;
        protected _children: this[];
        protected _active: boolean;
        protected _components: Component[];
        protected _prefab: any;
        protected _scene: any;
        protected _activeInHierarchy: boolean;
        protected _id: string;
        protected _name: string;
        protected _eventProcessor: NodeEventProcessor;
        protected _eventMask: number;
        protected _siblingIndex: number;
        protected _registerIfAttached: ((this: BaseNode, register: any) => void) | undefined;
        constructor(name?: string);
        /**
         * @en
         * Properties configuration function.
         * All properties in attrs will be set to the node,
         * when the setter of the node is available,
         * the property will be set via setter function.
         * @zh 属性配置函数。在 attrs 的所有属性将被设置为节点属性。
         * @param attrs - Properties to be set to node
         * @example
         * ```
         * var attrs = { name: 'New Name', active: false };
         * node.attr(attrs);
         * ```
         */
        attr(attrs: Object): void;
        /**
         * @en Get parent of the node.
         * @zh 获取该节点的父节点。
         */
        getParent(): this | null;
        /**
         * @en Set parent of the node.
         * @zh 设置该节点的父节点。
         */
        setParent(value: this | Scene | null, keepWorldTransform?: boolean): void;
        /**
         * @en Returns a child with the same uuid.
         * @zh 通过 uuid 获取节点的子节点。
         * @param uuid - The uuid to find the child node.
         * @return a Node whose uuid equals to the input parameter
         */
        getChildByUuid(uuid: string): this | null;
        /**
         * @en Returns a child with the same name.
         * @zh 通过名称获取节点的子节点。
         * @param name - A name to find the child node.
         * @return a CCNode object whose name equals to the input parameter
         * @example
         * ```
         * var child = node.getChildByName("Test Node");
         * ```
         */
        getChildByName(name: string): this | null;
        /**
         * @en Returns a child with the given path.
         * @zh 通过路径获取节点的子节点。
         * @param path - A path to find the child node.
         * @return a Node object whose path equals to the input parameter
         * @example
         * ```
         * var child = node.getChildByPath("subNode/Test Node");
         * ```
         */
        getChildByPath(path: string): this | null;
        /**
         * @en Add a child to the current node, it will be pushed to the end of [[children]] array.
         * @zh 添加一个子节点，它会被添加到 [[children]] 数组的末尾。
         * @param child - the child node to be added
         */
        addChild(child: this | Node): void;
        /**
         * @en Inserts a child to the node at a specified index.
         * @zh 插入子节点到指定位置
         * @param child - the child node to be inserted
         * @param siblingIndex - the sibling index to place the child in
         * @example
         * ```
         * node.insertChild(child, 2);
         * ```
         */
        insertChild(child: this | Node, siblingIndex: number): void;
        /**
         * @en Get the sibling index of the current node in its parent's children array.
         * @zh 获取当前节点在父节点的 children 数组中的位置。
         */
        getSiblingIndex(): number;
        /**
         * @en Set the sibling index of the current node in its parent's children array.
         * @zh 设置当前节点在父节点的 children 数组中的位置。
         */
        setSiblingIndex(index: number): void;
        /**
         * @en Walk though the sub children tree of the current node.
         * Each node, including the current node, in the sub tree will be visited two times,
         * before all children and after all children.
         * This function call is not recursive, it's based on stack.
         * Please don't walk any other node inside the walk process.
         * @zh 遍历该节点的子树里的所有节点并按规则执行回调函数。
         * 对子树中的所有节点，包含当前节点，会执行两次回调，preFunc 会在访问它的子节点之前调用，postFunc 会在访问所有子节点之后调用。
         * 这个函数的实现不是基于递归的，而是基于栈展开递归的方式。
         * 请不要在 walk 过程中对任何其他的节点嵌套执行 walk。
         * @param preFunc The callback to process node when reach the node for the first time
         * @param postFunc The callback to process node when re-visit the node after walked all children in its sub tree
         * @example
         * ```
         * node.walk(function (target) {
         *     console.log('Walked through node ' + target.name + ' for the first time');
         * }, function (target) {
         *     console.log('Walked through node ' + target.name + ' after walked all children in its sub tree');
         * });
         * ```
         */
        walk(preFunc: (target: this) => void, postFunc?: (target: this) => void): void;
        /**
         * @en
         * Remove itself from its parent node.
         * If the node have no parent, then nothing happens.
         * @zh
         * 从父节点中删除该节点。
         * 如果这个节点是一个孤立节点，那么什么都不会发生。
         */
        removeFromParent(): void;
        /**
         * @en Removes a child from the container.
         * @zh 移除节点中指定的子节点。
         * @param child - The child node which will be removed.
         */
        removeChild(child: this | Node): void;
        /**
         * @en Removes all children from the container.
         * @zh 移除节点所有的子节点。
         */
        removeAllChildren(): void;
        /**
         * @en Is this node a child of the given node?
         * @zh 是否是指定节点的子节点？
         * @return True if this node is a child, deep child or identical to the given node.
         */
        isChildOf(parent: this | Scene | null): boolean;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
         * 传入参数也可以是脚本的名称。
         * @param classConstructor The class of the target component
         * @example
         * ```
         * // get sprite component.
         * var sprite = node.getComponent(Sprite);
         * ```
         */
        getComponent<T extends Component>(classConstructor: Constructor<T>): T | null;
        /**
         * @en
         * Returns the component of supplied type if the node has one attached, null if it doesn't.
         * You can also get component in the node by passing in the name of the script.
         * @zh
         * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
         * 传入参数也可以是脚本的名称。
         * @param className The class name of the target component
         * @example
         * ```
         * // get custom test class.
         * var test = node.getComponent("Test");
         * ```
         */
        getComponent(className: string): Component | null;
        /**
         * @en Returns all components of given type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param classConstructor The class of the target component
         */
        getComponents<T extends Component>(classConstructor: Constructor<T>): T[];
        /**
         * @en Returns all components of given type in the node.
         * @zh 返回节点上指定类型的所有组件。
         * @param className The class name of the target component
         */
        getComponents(className: string): Component[];
        /**
         * @en Returns the component of given type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param classConstructor The class of the target component
         * @example
         * ```
         * var sprite = node.getComponentInChildren(Sprite);
         * ```
         */
        getComponentInChildren<T extends Component>(classConstructor: Constructor<T>): T | null;
        /**
         * @en Returns the component of given type in any of its children using depth first search.
         * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
         * @param className The class name of the target component
         * @example
         * ```
         * var Test = node.getComponentInChildren("Test");
         * ```
         */
        getComponentInChildren(className: string): Component | null;
        /**
         * @en Returns all components of given type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件
         * @param classConstructor The class of the target component
         * @example
         * ```
         * var sprites = node.getComponentsInChildren(Sprite);
         * ```
         */
        getComponentsInChildren<T extends Component>(classConstructor: Constructor<T>): T[];
        /**
         * @en Returns all components of given type in self or any of its children.
         * @zh 递归查找自身或所有子节点中指定类型的组件
         * @param className The class name of the target component
         * @example
         * ```
         * var tests = node.getComponentsInChildren("Test");
         * ```
         */
        getComponentsInChildren(className: string): Component[];
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param classConstructor The class of the component to add
         * @throws `TypeError` if the `classConstructor` does not specify a cc-class constructor extending the `Component`.
         * @example
         * ```
         * var sprite = node.addComponent(Sprite);
         * ```
         */
        addComponent<T extends Component>(classConstructor: Constructor<T>): T;
        /**
         * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
         * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
         * @param className The class name of the component to add
         * @throws `TypeError` if the `className` does not specify a cc-class constructor extending the `Component`.
         * @example
         * ```
         * var test = node.addComponent("Test");
         * ```
         */
        addComponent(className: string): Component;
        /**
         * @en
         * Removes a component identified by the given name or removes the component object given.
         * You can also use component.destroy() if you already have the reference.
         * @zh
         * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
         * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
         * @param classConstructor The class of the component to remove
         * @deprecated please destroy the component to remove it.
         * @example
         * ```
         * node.removeComponent(Sprite);
         * ```
         */
        removeComponent<T extends Component>(classConstructor: Constructor<T>): void;
        /**
         * @en
         * Removes a component identified by the given name or removes the component object given.
         * You can also use component.destroy() if you already have the reference.
         * @zh
         * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
         * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
         * @param classNameOrInstance The class name of the component to remove or the component instance to be removed
         * @deprecated please destroy the component to remove it.
         * @example
         * ```
         * import { Sprite } from 'cc';
         * const sprite = node.getComponent(Sprite);
         * if (sprite) {
         *     node.removeComponent(sprite);
         * }
         * node.removeComponent('Sprite');
         * ```
         */
        removeComponent(classNameOrInstance: string | Component): void;
        /**
         * @en
         * Register a callback of a specific event type on Node.
         * Use this method to register touch or mouse event permit propagation based on scene graph,
         * These kinds of event are triggered with dispatchEvent, the dispatch process has three steps:
         * 1. Capturing phase: dispatch in capture targets (`_getCapturingTargets`), e.g. parents in node tree, from root to the real target
         * 2. At target phase: dispatch to the listeners of the real target
         * 3. Bubbling phase: dispatch in bubble targets (`_getBubblingTargets`), e.g. parents in node tree, from the real target to root
         * In any moment of the dispatching process, it can be stopped via `event.stopPropagation()` or `event.stopPropagationImmidiate()`.
         * It's the recommended way to register touch/mouse event for Node,
         * please do not use `eventManager` directly for Node.
         * You can also register custom event and use `emit` to trigger custom event on Node.
         * For such events, there won't be capturing and bubbling phase, your event will be dispatched directly to its listeners registered on the same node.
         * You can also pass event callback parameters with `emit` by passing parameters after `type`.
         * @zh
         * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。
         * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：
         * 1. 捕获阶段：派发事件给捕获目标（通过 `_getCapturingTargets` 获取），比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。
         * 2. 目标阶段：派发给目标节点的监听器。
         * 3. 冒泡阶段：派发事件给冒泡目标（通过 `_getBubblingTargets` 获取），比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。
         * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。
         * 推荐使用这种方式来监听节点上的触摸或鼠标事件，请不要在节点上直接使用 `eventManager`。
         * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器
         * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表
         * @param type - A string representing the event type to listen for.<br>See {{#crossLink "Node/EventTyupe/POSITION_CHANGED"}}Node Events{{/crossLink}} for all builtin events.
         * @param callback - The callback that will be invoked when the event is dispatched. The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
         * @return - Just returns the incoming callback so you can save the anonymous function easier.
         * @example
         * ```ts
         * this.node.on(SystemEventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
         * node.on(SystemEventType.TOUCH_START, callback, this);
         * node.on(SystemEventType.TOUCH_MOVE, callback, this);
         * node.on(SystemEventType.TOUCH_END, callback, this);
         * ```
         */
        on(type: string | SystemEventType, callback: Function, target?: Object, useCapture?: any): void;
        /**
         * @en
         * Removes the callback previously registered with the same type, callback, target and or useCapture.
         * This method is merely an alias to removeEventListener.
         * @zh 删除之前与同类型，回调，目标或 useCapture 注册的回调。
         * @param type - A string representing the event type being removed.
         * @param callback - The callback to remove.
         * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
         * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
         * @example
         * ```ts
         * this.node.off(SystemEventType.TOUCH_START, this.memberFunction, this);
         * node.off(SystemEventType.TOUCH_START, callback, this.node);
         * ```
         */
        off(type: string, callback?: Function, target?: Object, useCapture?: any): void;
        /**
         * @en
         * Register an callback of a specific event type on the Node,
         * the callback will remove itself after the first time it is triggered.
         * @zh
         * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param type - A string representing the event type to listen for.
         * @param callback - The callback that will be invoked when the event is dispatched.
         *                              The callback is ignored if it is a duplicate (the callbacks are unique).
         * @param target - The target (this object) to invoke the callback, can be null
         */
        once(type: string, callback: Function, target?: Object, useCapture?: any): void;
        /**
         * @en
         * Trigger an event directly with the event name and necessary arguments.
         * @zh
         * 通过事件名发送自定义事件
         * @param type - event type
         * @param arg1 - First argument in callback
         * @param arg2 - Second argument in callback
         * @param arg3 - Third argument in callback
         * @param arg4 - Fourth argument in callback
         * @param arg5 - Fifth argument in callback
         * @example
         * ```ts
         * eventTarget.emit('fire', event);
         * eventTarget.emit('fire', message, emitter);
         * ```
         */
        emit(type: string, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        /**
         * @en
         * Dispatches an event into the event flow.
         * The event target is the EventTarget object upon which the dispatchEvent() method is called.
         * @zh 分发事件到事件流中。
         * @param event - The Event object that is dispatched into the event flow
         */
        dispatchEvent(event: Event): void;
        /**
         * @en Checks whether the EventTarget object has any callback registered for a specific type of event.
         * @zh 检查事件目标对象是否有为特定类型的事件注册的回调。
         * @param type - The type of event.
         * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
         * @param target - The callback callee of the event listener
         * @return True if a callback of the specified type is registered; false otherwise.
         */
        hasEventListener(type: string, callback?: Function, target?: Object): boolean;
        /**
         * @en Removes all callbacks previously registered with the same target.
         * @zh 移除目标上的所有注册事件。
         * @param target - The target to be searched for all related callbacks
         */
        targetOff(target: string | Object): void;
        destroy(): boolean;
        /**
         * @en
         * Destroy all children from the node, and release all their own references to other objects.
         * Actual destruct operation will delayed until before rendering.
         * @zh
         * 销毁所有子节点，并释放所有它们对其它对象的引用。
         * 实际销毁操作会延迟到当前帧渲染前执行。
         */
        destroyAllChildren(): void;
        _removeComponent(component: Component): void;
        _updateSiblingIndex(): void;
        protected _onSetParent(oldParent: this | null, keepWorldTransform?: boolean): void;
        protected _onPostActivated(active: boolean): void;
        protected _onBatchRestored(): void;
        protected _onBatchCreated(): void;
        protected _onPreDestroy(): void;
        protected _onHierarchyChanged(oldParent: this | null): void;
        protected _instantiate(cloned: any): any;
        protected _onHierarchyChangedBase(oldParent: this | null): void;
        protected _onPreDestroyBase(): boolean;
        protected _disableChildComps(): void;
        protected _onSiblingIndexChanged?(siblingIndex: number): void;
        /**
         * Ensures that this node has already had the specified component(s). If not, this method throws.
         * @param constructor Constructor of the component.
         * @throws If one or more component of same type have been existed in this node.
         */
        protected _checkMultipleComp?(constructor: Function): void;
    }
}
declare module "cocos/core/scene-graph/node-event-processor" {
    /**
     * @hidden
     */
    import Event from "cocos/core/event/event";
    import { EventListener } from "cocos/core/platform/event-manager/event-listener";
    import { BaseNode } from "cocos/core/scene-graph/base-node";
    import { CallbacksInvoker } from "cocos/core/event/callbacks-invoker";
    /**
     * @zh
     * 节点事件类。
     */
    export class NodeEventProcessor {
        get node(): BaseNode;
        /**
         * @zh
         * 节点冒泡事件监听器
         */
        bubblingTargets: CallbacksInvoker | null;
        /**
         * @zh
         * 节点捕获事件监听器
         */
        capturingTargets: CallbacksInvoker | null;
        /**
         * @zh
         * 触摸监听器
         */
        touchListener: EventListener | null;
        /**
         * @zh
         * 鼠标监听器
         */
        mouseListener: EventListener | null;
        private _node;
        constructor(node: BaseNode);
        reattach(): void;
        destroy(): void;
        /**
         * @zh
         * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。<br/>
         * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：<br/>
         * 1. 捕获阶段：派发事件给捕获目标（通过 `getCapturingTargets` 获取），比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。<br/>
         * 2. 目标阶段：派发给目标节点的监听器。<br/>
         * 3. 冒泡阶段：派发事件给冒泡目标（通过 `getBubblingTargets` 获取），比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。<br/>
         * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。<br/>
         * 推荐使用这种方式来监听节点上的触摸或鼠标事件，请不要在节点上直接使用 `eventManager`。<br/>
         * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器。<br/>
         * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表。<br/>
         *
         * @param type - 一个监听事件类型的字符串。参见：[[EventType]]
         * @param callback - 事件分派时将被调用的回调函数。如果该回调存在则不会重复添加。
         * @param callback.event - 事件派发的时候回调的第一个参数。
         * @param callback.arg2 - 第二个参数。
         * @param callback.arg3 - 第三个参数。
         * @param callback.arg4 - 第四个参数。
         * @param callback.arg5 - 第五个参数。
         * @param target - 调用回调的目标。可以为空。
         * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
         * @return - 返回监听回调函数自身。
         *
         * @example
         * ```ts
         * import { Node } from 'cc';
         * this.node.on(Node.EventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
         * this.node.on(Node.EventType.TOUCH_START, callback, this);
         * this.node.on(Node.EventType.ANCHOR_CHANGED, callback);
         * ```
         */
        on(type: string, callback: Function, target?: Object, useCapture?: Object): Function | undefined;
        /**
         * @zh
         * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
         *
         * @param type - 一个监听事件类型的字符串。参见：[[EventType]]。
         * @param callback - 事件分派时将被调用的回调函数。如果该回调存在则不会重复添加。
         * @param callback.event - 事件派发的时候回调的第一个参数。
         * @param callback.arg2 - 第二个参数。
         * @param callback.arg3 - 第三个参数。
         * @param callback.arg4 - 第四个参数。
         * @param callback.arg5 - 第五个参数。
         * @param target - 调用回调的目标。可以为空。
         * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
         *
         * @example
         * ```ts
         * import { Node } from 'cc';
         * node.once(Node.EventType.ANCHOR_CHANGED, callback);
         * ```
         */
        once(type: string, callback: Function, target?: Object, useCapture?: Object): void;
        /**
         * @zh
         * 删除之前与同类型，回调，目标或 useCapture 注册的回调。
         *
         * @param type - 一个监听事件类型的字符串。参见：[[EventType]]。
         * @param callback - 移除指定注册回调。如果没有给，则删除全部同事件类型的监听。
         * @param target - 调用回调的目标。配合 callback 一起使用。
         * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
         *
         * @example
         * ```ts
         * import { Node } from 'cc';
         * this.node.off(Node.EventType.TOUCH_START, this.memberFunction, this);
         * node.off(Node.EventType.TOUCH_START, callback, this.node);
         * node.off(Node.EventType.ANCHOR_CHANGED, callback, this);
         * ```
         */
        off(type: string, callback?: Function, target?: Object, useCapture?: Object): void;
        /**
         * @zh
         * 通过事件名发送自定义事件
         *
         * @param type - 一个监听事件类型的字符串。
         * @param arg0 - 回调第一个参数。
         * @param arg1 - 回调第二个参数。
         * @param arg2 - 回调第三个参数。
         * @param arg3 - 回调第四个参数。
         * @param arg4 - 回调第五个参数。
         * @example
         * ```ts
         * eventTarget.emit('fire', event);
         * eventTarget.emit('fire', message, emitter);
         * ```
         */
        emit(type: string, arg0?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void;
        /**
         * @zh
         * 分发事件到事件流中。
         *
         * @param event - 分派到事件流中的事件对象。
         */
        dispatchEvent(event: Event): void;
        /**
         * @zh
         * 是否监听过某事件。
         *
         * @param type - 一个监听事件类型的字符串。
         * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
         * @param target - The callback callee of the event listener
         * @return - 返回是否当前节点已监听该事件类型。
         */
        hasEventListener(type: string, callback?: Function, target?: Object): boolean;
        /**
         * @zh
         * 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
         *
         * @param target - 要删除的事件键或要删除的目标。
         */
        targetOff(target: string | Object): void;
        /**
         * @zh
         * 获得所提供的事件类型在目标捕获阶段监听的所有目标。
         * 捕获阶段包括从根节点到目标节点的过程。
         * 结果保存在数组参数中，并且必须从子节点排序到父节点。
         *
         * @param type - 一个监听事件类型的字符串。
         * @param array - 接收目标的数组。
         */
        getCapturingTargets(type: string, targets: BaseNode[]): void;
        /**
         * @zh
         * 获得所提供的事件类型在目标冒泡阶段监听的所有目标。
         * 冒泡阶段目标节点到根节点的过程。
         * 结果保存在数组参数中，并且必须从子节点排序到父节点。
         *
         * @param type - 一个监听事件类型的字符串。
         * @param array - 接收目标的数组。
         */
        getBubblingTargets(type: string, targets: BaseNode[]): void;
        private _checknSetupSysEvent;
        private _onDispatch;
        private _offDispatch;
    }
}
declare module "cocos/core/scene-graph/private-node" {
    import { Node } from "cocos/core/scene-graph/node";
    /**
     * @en
     * Class of private entities in Cocos Creator 3d scenes.<br/>
     * The PrivateNode is hidden in editor, and completely transparent to users.<br/>
     * It's normally used as Node's private content created by components in parent node.<br/>
     * So in theory private nodes are not children, they are part of the parent node.<br/>
     * Private node have two important characteristics:<br/>
     * 1. It has the minimum z index and cannot be modified, because they can't be displayed over real children.<br/>
     * 2. The positioning of private nodes is also special, they will consider the left bottom corner of the parent node's bounding box as the origin of local coordinates.<br/>
     *    In this way, they can be easily kept inside the bounding box.<br/>
     * Currently, it's used by RichText component and TileMap component.
     * @zh
     * Cocos Creator 3d 场景中的私有节点类。<br/>
     * 私有节点在编辑器中不可见，对用户透明。<br/>
     * 通常私有节点是被一些特殊的组件创建出来作为父节点的一部分而存在的，理论上来说，它们不是子节点，而是父节点的组成部分。<br/>
     * 私有节点有两个非常重要的特性：<br/>
     * 1. 它有着最小的渲染排序的 Z 轴深度，并且无法被更改，因为它们不能被显示在其他正常子节点之上。<br/>
     * 2. 它的定位也是特殊的，对于私有节点来说，父节点包围盒的左下角是它的局部坐标系原点，这个原点相当于父节点的位置减去它锚点的偏移。这样私有节点可以比较容易被控制在包围盒之中。<br/>
     * 目前在引擎中，RichText 和 TileMap 都有可能生成私有节点。
     */
    export class PrivateNode extends Node {
        constructor(name: string);
    }
}
declare module "cocos/core/scene-graph/deprecated" { }
declare module "cocos/core/scene-graph/index" {
    /**
     * @category scene-graph
     */
    import "cocos/core/scene-graph/node-event-processor";
    export { BaseNode } from "cocos/core/scene-graph/base-node";
    export { Node } from "cocos/core/scene-graph/node";
    export { Scene } from "cocos/core/scene-graph/scene";
    export { Layers } from "cocos/core/scene-graph/layers";
    export { find } from "cocos/core/scene-graph/find";
    export { PrivateNode } from "cocos/core/scene-graph/private-node";
    export { default as NodeActivator } from "cocos/core/scene-graph/node-activator";
    import "cocos/core/scene-graph/deprecated";
}
declare module "cocos/core/assets/asset" {
    import { RawAsset } from "cocos/core/assets/raw-asset";
    import { Node } from "cocos/core/scene-graph/index";
    const Asset_base: new (...args: any[]) => RawAsset & import("cocos/core/event/eventify").IEventified;
    /**
     * @en
     * Base class for handling assets used in Creator.<br/>
     *
     * You may want to override:<br/>
     * - createNode<br/>
     * - getset functions of _nativeAsset<br/>
     * - `Object._serialize`<br/>
     * - `Object._deserialize`<br/>
     * @zh
     * Creator 中的资源基类。<br/>
     *
     * 您可能需要重写：<br/>
     * - createNode <br/>
     * - _nativeAsset 的 getset 方法<br/>
     * - `Object._serialize`<br/>
     * - `Object._deserialize`<br/>
     *
     * @class Asset
     * @extends RawAsset
     */
    export class Asset extends Asset_base {
        /**
         * @en Indicates whether its dependent raw assets can support deferred load if the owner scene (or prefab) is marked as `asyncLoadAssets`.
         * @zh 当场景或 Prefab 被标记为 `asyncLoadAssets`，禁止延迟加载该资源所依赖的其它 RawAsset。
         * @default false
         */
        static preventDeferredLoadDependents: boolean;
        /**
         * @en Indicates whether its native object should be preloaded from native url.
         * @zh 禁止预加载原生对象。
         * @default false
         */
        static preventPreloadNativeObject: boolean;
        /**
         * 应 AssetDB 要求提供这个方法。
         * @method deserialize
         * @param {String} data
         * @return {Asset}
         */
        static deserialize(data: any): any;
        /**
         * @en
         * Whether the asset is loaded or not
         * @zh
         * 该资源是否已经成功加载。
         */
        loaded: boolean;
        /**
         * @en
         * Serializable url for native asset. For internal usage.
         * @zh
         * 用于本机资产的可序列化URL。供内部使用。
         * @default ""
         */
        _native: string;
        private _file;
        /**
         * @en
         * Returns the url of this asset's native object, if none it will returns an empty string.
         * @zh
         * 返回该资源对应的目标平台资源的 URL，如果没有将返回一个空字符串。
         * @readOnly
         */
        get nativeUrl(): string;
        /**
         * @en
         * The underlying native asset of this asset if one is available.<br>
         * This property can be used to access additional details or functionality releated to the asset.<br>
         * This property will be initialized by the loader if `_native` is available.
         * @zh
         * 此资源的基础资源（如果有）。 此属性可用于访问与资源相关的其他详细信息或功能。<br>
         * 如果`_native`可用，则此属性将由加载器初始化。
         * @default null
         * @private
         */
        get _nativeAsset(): any;
        set _nativeAsset(obj: any);
        /**
         * @en
         * Returns the string representation of the object.<br>
         * The `Asset` object overrides the `toString()` method of the `Object` object.<br>
         * JavaScript calls the toString() method automatically<br>
         * when an asset is to be represented as a text value or when a texture is referred to in a string concatenation.<br>
         * <br>
         * For assets of the native type, it will return `this.nativeUrl`.<br>
         * Otherwise, an empty string is returned.<br>
         * This method may be overwritten by subclasses.
         * @zh
         * 返回对象的字符串表示形式。<br>
         * `Asset` 对象将会重写 `Object` 对象的 `toString()` 方法。<br>
         * 当资源要表示为文本值时或在字符串连接时引用时，<br>
         * JavaScript 会自动调用 toString() 方法。<br>
         * <br>
         * 对于原始类型的资源，它将返回`this.nativeUrl`。<br>
         * 否则，返回空字符串。<br>
         * 子类可能会覆盖此方法。
         * @method toString
         * @return {String}
         */
        toString(): string;
        /**
         * 应 AssetDB 要求提供这个方法。
         * 返回一个序列化后的对象
         *
         * @method serialize
         * @return {String}
         * @private
         */
        serialize(): void;
        /**
         * @en
         * Set native file name for this asset.
         * @zh
         * 为此资源设置原始文件名。
         * @seealso nativeUrl
         *
         * @param filename
         * @param inLibrary
         * @private
         */
        _setRawAsset(filename: string, inLibrary?: boolean): void;
        /**
         * @en
         * Create a new node using this asset in the scene.<br/>
         * If this type of asset dont have its corresponding node type, this method should be null.
         * @zh
         * 使用该资源在场景中创建一个新节点。<br/>
         * 如果这类资源没有相应的节点类型，该方法应该是空的。
         */
        createNode?(callback: CreateNodeCallback): void;
    }
    /**
     * @param error - null or the error info
     * @param node - the created node or null
     */
    type CreateNodeCallback = (error: Error | null, node: Node) => void;
}
declare module "cocos/audio/assets/player" {
    /**
     * @category component/audio
     */
    export const PlayingState: {
        INITIALIZING: number;
        PLAYING: number;
        STOPPED: number;
    };
    export interface IAudioInfo {
        clip: any;
        duration: number;
        eventTarget: any;
    }
    export abstract class AudioPlayer {
        protected _state: number;
        protected _duration: number;
        protected _eventTarget: any;
        protected _onHide: Function;
        protected _onShow: Function;
        protected _interrupted: boolean;
        protected _blocking: boolean;
        constructor(info: IAudioInfo);
        abstract play(): void;
        abstract pause(): void;
        abstract stop(): void;
        abstract playOneShot(volume: number): void;
        abstract setCurrentTime(val: number): void;
        abstract getCurrentTime(): number;
        abstract setVolume(val: number, immediate: boolean): void;
        abstract getVolume(): number;
        abstract setLoop(val: boolean): void;
        abstract getLoop(): boolean;
        getState(): number;
        getDuration(): number;
        destroy(): void;
    }
}
declare module "cocos/audio/assets/player-dom" {
    import { AudioPlayer, IAudioInfo } from "cocos/audio/assets/player";
    export class AudioPlayerDOM extends AudioPlayer {
        protected _volume: number;
        protected _loop: boolean;
        protected _oneShotOngoing: boolean;
        protected _audio: HTMLAudioElement;
        protected _cbRegistered: boolean;
        private _remove_cb;
        private _post_play;
        private _on_gesture;
        private _post_gesture;
        constructor(info: IAudioInfo);
        play(): void;
        pause(): void;
        stop(): void;
        playOneShot(volume?: number): void;
        setCurrentTime(val: number): void;
        getCurrentTime(): number;
        setVolume(val: number, immediate: boolean): void;
        getVolume(): number;
        setLoop(val: boolean): void;
        getLoop(): boolean;
        destroy(): void;
    }
}
declare module "cocos/audio/assets/player-web" {
    import { AudioPlayer, IAudioInfo } from "cocos/audio/assets/player";
    export class AudioPlayerWeb extends AudioPlayer {
        protected _startTime: number;
        protected _offset: number;
        protected _volume: number;
        protected _loop: boolean;
        protected _currentTimer: number;
        protected _audio: AudioBuffer;
        private _context;
        private _sourceNode;
        private _gainNode;
        private _startInvoked;
        private _onEndedCB;
        private _onGestureCB;
        private _onGestureProceedCB;
        constructor(info: IAudioInfo);
        play(): void;
        pause(): void;
        stop(): void;
        playOneShot(volume?: number): void;
        setCurrentTime(val: number): void;
        getCurrentTime(): number;
        setVolume(val: number, immediate: boolean): void;
        getVolume(): number;
        setLoop(val: boolean): void;
        getLoop(): boolean;
        destroy(): void;
        private _doPlay;
        private _doStop;
        private _playAndEmit;
        private _onEnded;
        private _onGestureProceed;
        private _onGesture;
    }
}
declare module "cocos/audio/assets/clip" {
    /**
     * @category component/audio
     */
    import { Asset } from "cocos/core/assets/asset";
    import { AudioPlayer } from "cocos/audio/assets/player";
    export const AudioType: {
        WEB_AUDIO: number;
        DOM_AUDIO: number;
        JSB_AUDIO: number;
        UNKNOWN_AUDIO: number;
    };
    /**
     * @en
     * The audio clip asset. <br>
     * 'started' event is emitted once the audio began to play. <br>
     * 'ended' event is emitted once the audio stopped. <br>
     * Low-level platform-specific details are handled independently inside each clip.
     * @zh
     * 音频片段资源。<br>
     * 每当音频片段实际开始播放时，会发出 'started' 事件；<br>
     * 每当音频片段自然结束播放时，会发出 'ended' 事件。<br>
     * 每个片段独立处理自己依赖的平台相关的底层细节。
     */
    export class AudioClip extends Asset {
        static PlayingState: {
            INITIALIZING: number;
            PLAYING: number;
            STOPPED: number;
        };
        static AudioType: {
            WEB_AUDIO: number;
            DOM_AUDIO: number;
            JSB_AUDIO: number;
            UNKNOWN_AUDIO: number;
        };
        static preventDeferredLoadDependents: boolean;
        protected _duration: number;
        protected _loadMode: number;
        protected _audio: any;
        protected _player: AudioPlayer | null;
        constructor();
        destroy(): boolean;
        set _nativeAsset(clip: any);
        get _nativeAsset(): any;
        get loadMode(): number;
        get state(): number;
        play(): void;
        pause(): void;
        stop(): void;
        playOneShot(volume: number): void;
        setCurrentTime(val: number): void;
        getCurrentTime(): number;
        getDuration(): number;
        setVolume(val: number, immediate?: boolean): void;
        getVolume(): number;
        setLoop(val: boolean): void;
        getLoop(): boolean;
        private _getPlayer;
    }
}
declare module "cocos/audio/audio-source" {
    /**
     * @category component/audio
     */
    import { Component } from "cocos/core/components/component";
    import { AudioClip } from "cocos/audio/assets/clip";
    /**
     * @en
     * A representation of a single audio source, <br>
     * contains basic functionalities like play, pause and stop.
     * @zh
     * 音频组件，代表单个音源，提供播放、暂停、停止等基本功能。
     */
    export class AudioSource extends Component {
        protected _clip: AudioClip | null;
        protected _loop: boolean;
        protected _playOnAwake: boolean;
        protected _volume: number;
        private _cachedCurrentTime;
        /**
         * @en
         * The default AudioClip to be played for this audio source.
         * @zh
         * 设定要播放的音频。
         */
        set clip(val: AudioClip | null);
        get clip(): AudioClip | null;
        /**
         * @en
         * Is looping enabled for this audio source?
         * @zh
         * 是否循环播放音频？
         */
        set loop(val: boolean);
        get loop(): boolean;
        /**
         * @en
         * Is the autoplay enabled? <br>
         * Note that for most platform autoplay will only start <br>
         * after a user gesture is received, according to the latest autoplay policy: <br>
         * https://www.chromium.org/audio-video/autoplay
         * @zh
         * 是否启用自动播放。 <br>
         * 请注意，根据最新的自动播放策略，现在对大多数平台，自动播放只会在第一次收到用户输入后生效。 <br>
         * 参考：https://www.chromium.org/audio-video/autoplay
         */
        set playOnAwake(val: boolean);
        get playOnAwake(): boolean;
        /**
         * @en
         * The volume of this audio source (0.0 to 1.0).<br>
         * Note: Volume control may be ineffective on some platforms.
         * @zh
         * 音频的音量（大小范围为 0.0 到 1.0）。<br>
         * 请注意，在某些平台上，音量控制可能不起效。<br>
         */
        set volume(val: number);
        get volume(): number;
        onLoad(): void;
        onDisable(): void;
        onDestroy(): void;
        /**
         * @en
         * Play the clip.<br>
         * Restart if already playing.<br>
         * Resume if paused.
         * @zh
         * 开始播放。<br>
         * 如果音频处于正在播放状态，将会重新开始播放音频。<br>
         * 如果音频处于暂停状态，则会继续播放音频。
         */
        play(): void;
        /**
         * @en
         * Pause the clip.
         * @zh
         * 暂停播放。
         */
        pause(): void;
        /**
         * @en
         * Stop the clip.
         * @zh
         * 停止播放。
         */
        stop(): void;
        /**
         * @en
         * Plays an AudioClip, and scales volume by volumeScale.<br>
         * Note: for multiple playback on the same clip, the actual behavior is platform-specific.<br>
         * Re-start style fallback will be used if the underlying platform doesn't support it.
         * @zh
         * 以指定音量播放一个音频一次。<br>
         * 注意，对同一个音频片段，不同平台多重播放效果存在差异。<br>
         * 对不支持的平台，如前一次尚未播完，则会立即重新播放。
         * @param clip The audio clip to be played.
         * @param volumeScale volume scaling factor wrt. current value.
         */
        playOneShot(clip: AudioClip, volumeScale?: number): void;
        protected _syncStates(): void;
        /**
         * @en
         * Set current playback time, in seconds.
         * @zh
         * 以秒为单位设置当前播放时间。
         * @param num playback time to jump to.
         */
        set currentTime(num: number);
        /**
         * @en
         * Get the current playback time, in seconds.
         * @zh
         * 以秒为单位获取当前播放时间。
         */
        get currentTime(): number;
        /**
         * @en
         * Get the audio duration, in seconds.
         * @zh
         * 获取以秒为单位的音频总时长。
         */
        get duration(): number;
        /**
         * @en
         * Get current audio state.
         * @zh
         * 获取当前音频状态。
         */
        get state(): number;
        /**
         * @en
         * Is the audio currently playing?
         * @zh
         * 当前音频是否正在播放？
         */
        get playing(): boolean;
    }
}
declare module "cocos/audio/index" {
    export { AudioClip } from "cocos/audio/assets/clip";
    import "cocos/audio/audio-downloader";
    import { AudioSource } from "cocos/audio/audio-source";
    export { AudioSource };
    export { AudioSource as AudioSourceComponent };
}
declare module "exports/audio" {
    /**
     * @hidden
     */
    export * from "cocos/audio/index";
}
declare module "cocos/core/gfx/webgl/webgl-command-allocator" {
    import { CachedArray } from "cocos/core/memop/cached-array";
    import { WebGLCmdBeginRenderPass, WebGLCmdBindStates, WebGLCmdCopyBufferToTexture, WebGLCmdDraw, WebGLCmdObject, WebGLCmdPackage, WebGLCmdUpdateBuffer } from "cocos/core/gfx/webgl/webgl-commands";
    export class WebGLCommandPool<T extends WebGLCmdObject> {
        private _frees;
        private _freeIdx;
        private _freeCmds;
        constructor(clazz: new () => T, count: number);
        alloc(clazz: new () => T): T;
        free(cmd: T): void;
        freeCmds(cmds: CachedArray<T>): void;
        release(): void;
    }
    export class WebGLCommandAllocator {
        beginRenderPassCmdPool: WebGLCommandPool<WebGLCmdBeginRenderPass>;
        bindStatesCmdPool: WebGLCommandPool<WebGLCmdBindStates>;
        drawCmdPool: WebGLCommandPool<WebGLCmdDraw>;
        updateBufferCmdPool: WebGLCommandPool<WebGLCmdUpdateBuffer>;
        copyBufferToTextureCmdPool: WebGLCommandPool<WebGLCmdCopyBufferToTexture>;
        constructor();
        clearCmds(cmdPackage: WebGLCmdPackage): void;
        releaseCmds(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-gpu-objects" {
    import { GFXDrawInfo } from "cocos/core/gfx/buffer";
    import { GFXDescriptorType, GFXBufferUsage, GFXFormat, GFXMemoryUsage, GFXSampleCount, GFXShaderStageFlagBit, GFXTextureFlags, GFXTextureType, GFXTextureUsage, GFXType, GFXDynamicStateFlagBit } from "cocos/core/gfx/define";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    import { GFXColorAttachment, GFXDepthStencilAttachment } from "cocos/core/gfx/render-pass";
    import { GFXUniformBlock, GFXUniformSampler } from "cocos/core/gfx/shader";
    import { IGFXDescriptorSetLayoutBinding } from "cocos/core/gfx/descriptor-set-layout";
    export interface IWebGLGPUUniformInfo {
        name: string;
        type: GFXType;
        count: number;
        offset: number;
        view: Float32Array | Int32Array;
        isDirty: boolean;
    }
    export interface IWebGLGPUBufferView {
        gpuBuffer: IWebGLGPUBuffer;
        offset: number;
        range: number;
    }
    export interface IWebGLGPUBuffer {
        usage: GFXBufferUsage;
        memUsage: GFXMemoryUsage;
        size: number;
        stride: number;
        glTarget: GLenum;
        glBuffer: WebGLBuffer | null;
        buffer: ArrayBufferView | null;
        vf32: Float32Array | null;
        indirects: GFXDrawInfo[];
    }
    export interface IWebGLGPUTexture {
        type: GFXTextureType;
        format: GFXFormat;
        usage: GFXTextureUsage;
        width: number;
        height: number;
        depth: number;
        size: number;
        arrayLayer: number;
        mipLevel: number;
        samples: GFXSampleCount;
        flags: GFXTextureFlags;
        isPowerOf2: boolean;
        glTarget: GLenum;
        glInternalFmt: GLenum;
        glFormat: GLenum;
        glType: GLenum;
        glUsage: GLenum;
        glTexture: WebGLTexture | null;
        glRenderbuffer: WebGLRenderbuffer | null;
        glWrapS: GLenum;
        glWrapT: GLenum;
        glMinFilter: GLenum;
        glMagFilter: GLenum;
    }
    export interface IWebGLGPURenderPass {
        colorAttachments: GFXColorAttachment[];
        depthStencilAttachment: GFXDepthStencilAttachment | null;
    }
    export interface IWebGLGPUFramebuffer {
        gpuRenderPass: IWebGLGPURenderPass;
        gpuColorTextures: IWebGLGPUTexture[];
        gpuDepthStencilTexture: IWebGLGPUTexture | null;
        glFramebuffer: WebGLFramebuffer | null;
    }
    export interface IWebGLGPUSampler {
        glMinFilter: GLenum;
        glMagFilter: GLenum;
        glWrapS: GLenum;
        glWrapT: GLenum;
        glWrapR: GLenum;
    }
    export interface IWebGLGPUInput {
        binding: number;
        name: string;
        type: GFXType;
        stride: number;
        count: number;
        size: number;
        glType: GLenum;
        glLoc: GLint;
    }
    export interface IWebGLGPUUniform {
        binding: number;
        name: string;
        type: GFXType;
        stride: number;
        count: number;
        size: number;
        offset: number;
        glType: GLenum;
        glLoc: WebGLUniformLocation;
        array: number[];
        begin: number;
    }
    export interface IWebGLGPUUniformBlock {
        set: number;
        binding: number;
        name: string;
        size: number;
        glUniforms: IWebGLGPUUniform[];
        glActiveUniforms: IWebGLGPUUniform[];
    }
    export interface IWebGLGPUUniformSampler {
        set: number;
        binding: number;
        name: string;
        type: GFXType;
        units: number[];
        glUnits: Int32Array;
        glType: GLenum;
        glLoc: WebGLUniformLocation;
    }
    export interface IWebGLGPUShaderStage {
        type: GFXShaderStageFlagBit;
        source: string;
        glShader: WebGLShader | null;
    }
    export interface IWebGLGPUShader {
        name: string;
        blocks: GFXUniformBlock[];
        samplers: GFXUniformSampler[];
        gpuStages: IWebGLGPUShaderStage[];
        glProgram: WebGLProgram | null;
        glInputs: IWebGLGPUInput[];
        glUniforms: IWebGLGPUUniform[];
        glBlocks: IWebGLGPUUniformBlock[];
        glSamplers: IWebGLGPUUniformSampler[];
    }
    export interface IWebGLGPUDescriptorSetLayout {
        bindings: IGFXDescriptorSetLayoutBinding[];
        dynamicBindings: number[];
        descriptorIndices: number[];
        descriptorCount: number;
    }
    export interface IWebGLGPUPipelineLayout {
        gpuSetLayouts: IWebGLGPUDescriptorSetLayout[];
        dynamicOffsetCount: number;
        dynamicOffsetOffsets: number[];
        dynamicOffsetIndices: number[][];
    }
    export interface IWebGLGPUPipelineState {
        glPrimitive: GLenum;
        gpuShader: IWebGLGPUShader | null;
        gpuPipelineLayout: IWebGLGPUPipelineLayout | null;
        rs: GFXRasterizerState;
        dss: GFXDepthStencilState;
        bs: GFXBlendState;
        dynamicStates: GFXDynamicStateFlagBit[];
        gpuRenderPass: IWebGLGPURenderPass | null;
    }
    export interface IWebGLGPUDescriptor {
        type: GFXDescriptorType;
        gpuBuffer: IWebGLGPUBuffer | IWebGLGPUBufferView | null;
        gpuTexture: IWebGLGPUTexture | null;
        gpuSampler: IWebGLGPUSampler | null;
    }
    export interface IWebGLGPUDescriptorSet {
        gpuDescriptors: IWebGLGPUDescriptor[];
        descriptorIndices: number[];
    }
    export interface IWebGLAttrib {
        name: string;
        glBuffer: WebGLBuffer | null;
        glType: GLenum;
        size: number;
        count: number;
        stride: number;
        componentCount: number;
        isNormalized: boolean;
        isInstanced: boolean;
        offset: number;
    }
    export interface IWebGLGPUInputAssembler {
        attributes: IGFXAttribute[];
        gpuVertexBuffers: IWebGLGPUBuffer[];
        gpuIndexBuffer: IWebGLGPUBuffer | null;
        gpuIndirectBuffer: IWebGLGPUBuffer | null;
        glAttribs: IWebGLAttrib[];
        glIndexType: GLenum;
        glVAOs: Map<WebGLProgram, WebGLVertexArrayObjectOES>;
    }
}
declare module "cocos/core/gfx/webgl/webgl-render-pass" {
    import { GFXRenderPass, IGFXRenderPassInfo } from "cocos/core/gfx/render-pass";
    import { IWebGLGPURenderPass } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLRenderPass extends GFXRenderPass {
        get gpuRenderPass(): IWebGLGPURenderPass;
        private _gpuRenderPass;
        initialize(info: IGFXRenderPassInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-texture" {
    import { GFXTexture, IGFXTextureInfo, IGFXTextureViewInfo } from "cocos/core/gfx/texture";
    import { IWebGLGPUTexture } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLTexture extends GFXTexture {
        get gpuTexture(): IWebGLGPUTexture;
        private _gpuTexture;
        initialize(info: IGFXTextureInfo | IGFXTextureViewInfo): boolean;
        destroy(): void;
        resize(width: number, height: number): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-framebuffer" {
    import { GFXFramebuffer, IGFXFramebufferInfo } from "cocos/core/gfx/framebuffer";
    import { IWebGLGPUFramebuffer } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLFramebuffer extends GFXFramebuffer {
        get gpuFramebuffer(): IWebGLGPUFramebuffer;
        private _gpuFramebuffer;
        initialize(info: IGFXFramebufferInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-input-assembler" {
    import { GFXInputAssembler, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { IWebGLGPUInputAssembler } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLInputAssembler extends GFXInputAssembler {
        get gpuInputAssembler(): IWebGLGPUInputAssembler;
        private _gpuInputAssembler;
        initialize(info: IGFXInputAssemblerInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-shader" {
    import { GFXShader, GFXShaderInfo } from "cocos/core/gfx/shader";
    import { IWebGLGPUShader } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLShader extends GFXShader {
        get gpuShader(): IWebGLGPUShader;
        private _gpuShader;
        initialize(info: GFXShaderInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-descriptor-set-layout" {
    import { GFXDescriptorSetLayout, IGFXDescriptorSetLayoutInfo } from "cocos/core/gfx/descriptor-set-layout";
    import { IWebGLGPUDescriptorSetLayout } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLDescriptorSetLayout extends GFXDescriptorSetLayout {
        get gpuDescriptorSetLayout(): IWebGLGPUDescriptorSetLayout;
        private _gpuDescriptorSetLayout;
        initialize(info: IGFXDescriptorSetLayoutInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-pipeline-layout" {
    import { GFXPipelineLayout, IGFXPipelineLayoutInfo } from "cocos/core/gfx/pipeline-layout";
    import { IWebGLGPUPipelineLayout } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLPipelineLayout extends GFXPipelineLayout {
        get gpuPipelineLayout(): IWebGLGPUPipelineLayout;
        private _gpuPipelineLayout;
        initialize(info: IGFXPipelineLayoutInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-pipeline-state" {
    import { GFXPipelineState, IGFXPipelineStateInfo } from "cocos/core/gfx/pipeline-state";
    import { IWebGLGPUPipelineState } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLPipelineState extends GFXPipelineState {
        get gpuPipelineState(): IWebGLGPUPipelineState;
        private _gpuPipelineState;
        initialize(info: IGFXPipelineStateInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-command-buffer" {
    import { GFXDescriptorSet } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer, GFXBufferSource } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer, IGFXCommandBufferInfo } from "cocos/core/gfx/command-buffer";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState } from "cocos/core/gfx/pipeline-state";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { WebGLCommandAllocator } from "cocos/core/gfx/webgl/webgl-command-allocator";
    import { WebGLDevice } from "cocos/core/gfx/webgl/webgl-device";
    import { IWebGLGPUInputAssembler, IWebGLGPUDescriptorSet, IWebGLGPUPipelineState } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    import { GFXBufferTextureCopy, GFXStencilFace, GFXColor, GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { WebGLCmdPackage } from "cocos/core/gfx/webgl/webgl-commands";
    export interface IWebGLDepthBias {
        constantFactor: number;
        clamp: number;
        slopeFactor: number;
    }
    export interface IWebGLDepthBounds {
        minBounds: number;
        maxBounds: number;
    }
    export interface IWebGLStencilWriteMask {
        face: GFXStencilFace;
        writeMask: number;
    }
    export interface IWebGLStencilCompareMask {
        face: GFXStencilFace;
        reference: number;
        compareMask: number;
    }
    export class WebGLCommandBuffer extends GFXCommandBuffer {
        cmdPackage: WebGLCmdPackage;
        protected _webGLAllocator: WebGLCommandAllocator | null;
        protected _isInRenderPass: boolean;
        protected _curGPUPipelineState: IWebGLGPUPipelineState | null;
        protected _curGPUInputAssembler: IWebGLGPUInputAssembler | null;
        protected _curGPUDescriptorSets: IWebGLGPUDescriptorSet[];
        protected _curDynamicOffsets: number[][];
        protected _curViewport: GFXViewport | null;
        protected _curScissor: GFXRect | null;
        protected _curLineWidth: number | null;
        protected _curDepthBias: IWebGLDepthBias | null;
        protected _curBlendConstants: number[];
        protected _curDepthBounds: IWebGLDepthBounds | null;
        protected _curStencilWriteMask: IWebGLStencilWriteMask | null;
        protected _curStencilCompareMask: IWebGLStencilCompareMask | null;
        protected _isStateInvalied: boolean;
        initialize(info: IGFXCommandBufferInfo): boolean;
        destroy(): void;
        begin(renderPass?: GFXRenderPass, subpass?: number, frameBuffer?: GFXFramebuffer): void;
        end(): void;
        beginRenderPass(renderPass: GFXRenderPass, framebuffer: GFXFramebuffer, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
        endRenderPass(): void;
        bindPipelineState(pipelineState: GFXPipelineState): void;
        bindDescriptorSet(set: number, descriptorSet: GFXDescriptorSet, dynamicOffsets?: number[]): void;
        bindInputAssembler(inputAssembler: GFXInputAssembler): void;
        setViewport(viewport: GFXViewport): void;
        setScissor(scissor: GFXRect): void;
        setLineWidth(lineWidth: number): void;
        setDepthBias(depthBiasConstantFactor: number, depthBiasClamp: number, depthBiasSlopeFactor: number): void;
        setBlendConstants(blendConstants: number[]): void;
        setDepthBound(minDepthBounds: number, maxDepthBounds: number): void;
        setStencilWriteMask(face: GFXStencilFace, writeMask: number): void;
        setStencilCompareMask(face: GFXStencilFace, reference: number, compareMask: number): void;
        draw(inputAssembler: GFXInputAssembler): void;
        updateBuffer(buffer: GFXBuffer, data: GFXBufferSource, offset?: number, size?: number): void;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        execute(cmdBuffs: GFXCommandBuffer[], count: number): void;
        get webGLDevice(): WebGLDevice;
        protected bindStates(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-define" {
    export enum WebGLEXT {
        RGBA16F_EXT = 34842,
        RGB16F_EXT = 34843,
        RGBA32F_EXT = 34836,
        FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297,
        UNSIGNED_NORMALIZED_EXT = 35863,
        UNSIGNED_INT_24_8_WEBGL = 34042,
        HALF_FLOAT_OES = 36193,
        COMPRESSED_RGB_S3TC_DXT1_EXT = 33776,
        COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777,
        COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778,
        COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779,
        COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918,
        COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919,
        COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840,
        COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841,
        COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842,
        COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843,
        COMPRESSED_RGB_ETC1_WEBGL = 36196,
        COMPRESSED_R11_EAC = 37488,
        COMPRESSED_SIGNED_R11_EAC = 37489,
        COMPRESSED_RG11_EAC = 37490,
        COMPRESSED_SIGNED_RG11_EAC = 37491,
        COMPRESSED_RGB8_ETC2 = 37492,
        COMPRESSED_SRGB8_ETC2 = 37493,
        COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494,
        COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495,
        COMPRESSED_RGBA8_ETC2_EAC = 37496,
        COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497,
        COMPRESSED_RGBA_ASTC_4x4_KHR = 37808,
        COMPRESSED_RGBA_ASTC_5x4_KHR = 37809,
        COMPRESSED_RGBA_ASTC_5x5_KHR = 37810,
        COMPRESSED_RGBA_ASTC_6x5_KHR = 37811,
        COMPRESSED_RGBA_ASTC_6x6_KHR = 37812,
        COMPRESSED_RGBA_ASTC_8x5_KHR = 37813,
        COMPRESSED_RGBA_ASTC_8x6_KHR = 37814,
        COMPRESSED_RGBA_ASTC_8x8_KHR = 37815,
        COMPRESSED_RGBA_ASTC_10x5_KHR = 37816,
        COMPRESSED_RGBA_ASTC_10x6_KHR = 37817,
        COMPRESSED_RGBA_ASTC_10x8_KHR = 37818,
        COMPRESSED_RGBA_ASTC_10x10_KHR = 37819,
        COMPRESSED_RGBA_ASTC_12x10_KHR = 37820,
        COMPRESSED_RGBA_ASTC_12x12_KHR = 37821,
        COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841,
        COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843,
        COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846,
        COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850,
        COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852,
        COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853
    }
}
declare module "cocos/core/gfx/webgl/webgl-commands" {
    import { CachedArray } from "cocos/core/memop/cached-array";
    import { GFXBufferSource, GFXDrawInfo } from "cocos/core/gfx/buffer";
    import { WebGLCommandAllocator } from "cocos/core/gfx/webgl/webgl-command-allocator";
    import { IWebGLDepthBias, IWebGLDepthBounds, IWebGLStencilCompareMask, IWebGLStencilWriteMask } from "cocos/core/gfx/webgl/webgl-command-buffer";
    import { WebGLDevice } from "cocos/core/gfx/webgl/webgl-device";
    import { IWebGLGPUInputAssembler, IWebGLGPUDescriptorSet, IWebGLGPUBuffer, IWebGLGPUFramebuffer, IWebGLGPUPipelineState, IWebGLGPUShader, IWebGLGPUTexture, IWebGLGPURenderPass } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    import { GFXBufferTextureCopy, GFXClearFlag, GFXFormat, GFXColor, GFXRect, GFXViewport } from "cocos/core/gfx/define";
    export function GFXFormatToWebGLType(format: GFXFormat, gl: WebGLRenderingContext): GLenum;
    export function GFXFormatToWebGLInternalFormat(format: GFXFormat, gl: WebGLRenderingContext): GLenum;
    export function GFXFormatToWebGLFormat(format: GFXFormat, gl: WebGLRenderingContext): GLenum;
    export enum WebGLCmd {
        BEGIN_RENDER_PASS = 0,
        END_RENDER_PASS = 1,
        BIND_STATES = 2,
        DRAW = 3,
        UPDATE_BUFFER = 4,
        COPY_BUFFER_TO_TEXTURE = 5,
        COUNT = 6
    }
    export abstract class WebGLCmdObject {
        cmdType: WebGLCmd;
        refCount: number;
        constructor(type: WebGLCmd);
        abstract clear(): any;
    }
    export class WebGLCmdBeginRenderPass extends WebGLCmdObject {
        gpuRenderPass: IWebGLGPURenderPass | null;
        gpuFramebuffer: IWebGLGPUFramebuffer | null;
        renderArea: GFXRect;
        clearFlag: GFXClearFlag;
        clearColors: GFXColor[];
        clearDepth: number;
        clearStencil: number;
        constructor();
        clear(): void;
    }
    export class WebGLCmdBindStates extends WebGLCmdObject {
        gpuPipelineState: IWebGLGPUPipelineState | null;
        gpuInputAssembler: IWebGLGPUInputAssembler | null;
        gpuDescriptorSets: IWebGLGPUDescriptorSet[];
        dynamicOffsets: number[];
        viewport: GFXViewport | null;
        scissor: GFXRect | null;
        lineWidth: number | null;
        depthBias: IWebGLDepthBias | null;
        blendConstants: number[];
        depthBounds: IWebGLDepthBounds | null;
        stencilWriteMask: IWebGLStencilWriteMask | null;
        stencilCompareMask: IWebGLStencilCompareMask | null;
        constructor();
        clear(): void;
    }
    export class WebGLCmdDraw extends WebGLCmdObject {
        drawInfo: GFXDrawInfo;
        constructor();
        clear(): void;
    }
    export class WebGLCmdUpdateBuffer extends WebGLCmdObject {
        gpuBuffer: IWebGLGPUBuffer | null;
        buffer: GFXBufferSource | null;
        offset: number;
        size: number;
        constructor();
        clear(): void;
    }
    export class WebGLCmdCopyBufferToTexture extends WebGLCmdObject {
        gpuTexture: IWebGLGPUTexture | null;
        buffers: ArrayBufferView[];
        regions: GFXBufferTextureCopy[];
        constructor();
        clear(): void;
    }
    export class WebGLCmdPackage {
        cmds: CachedArray<WebGLCmd>;
        beginRenderPassCmds: CachedArray<WebGLCmdBeginRenderPass>;
        bindStatesCmds: CachedArray<WebGLCmdBindStates>;
        drawCmds: CachedArray<WebGLCmdDraw>;
        updateBufferCmds: CachedArray<WebGLCmdUpdateBuffer>;
        copyBufferToTextureCmds: CachedArray<WebGLCmdCopyBufferToTexture>;
        clearCmds(allocator: WebGLCommandAllocator): void;
    }
    export function WebGLCmdFuncCreateBuffer(device: WebGLDevice, gpuBuffer: IWebGLGPUBuffer): void;
    export function WebGLCmdFuncDestroyBuffer(device: WebGLDevice, gpuBuffer: IWebGLGPUBuffer): void;
    export function WebGLCmdFuncResizeBuffer(device: WebGLDevice, gpuBuffer: IWebGLGPUBuffer): void;
    export function WebGLCmdFuncUpdateBuffer(device: WebGLDevice, gpuBuffer: IWebGLGPUBuffer, buffer: GFXBufferSource, offset: number, size: number): void;
    export function WebGLCmdFuncCreateTexture(device: WebGLDevice, gpuTexture: IWebGLGPUTexture): void;
    export function WebGLCmdFuncDestroyTexture(device: WebGLDevice, gpuTexture: IWebGLGPUTexture): void;
    export function WebGLCmdFuncResizeTexture(device: WebGLDevice, gpuTexture: IWebGLGPUTexture): void;
    export function WebGLCmdFuncCreateFramebuffer(device: WebGLDevice, gpuFramebuffer: IWebGLGPUFramebuffer): void;
    export function WebGLCmdFuncDestroyFramebuffer(device: WebGLDevice, gpuFramebuffer: IWebGLGPUFramebuffer): void;
    export function WebGLCmdFuncCreateShader(device: WebGLDevice, gpuShader: IWebGLGPUShader): void;
    export function WebGLCmdFuncDestroyShader(device: WebGLDevice, gpuShader: IWebGLGPUShader): void;
    export function WebGLCmdFuncCreateInputAssember(device: WebGLDevice, gpuInputAssembler: IWebGLGPUInputAssembler): void;
    export function WebGLCmdFuncDestroyInputAssembler(device: WebGLDevice, gpuInputAssembler: IWebGLGPUInputAssembler): void;
    export function WebGLCmdFuncBeginRenderPass(device: WebGLDevice, gpuRenderPass: IWebGLGPURenderPass | null, gpuFramebuffer: IWebGLGPUFramebuffer | null, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
    export function WebGLCmdFuncBindStates(device: WebGLDevice, gpuPipelineState: IWebGLGPUPipelineState | null, gpuInputAssembler: IWebGLGPUInputAssembler | null, gpuDescriptorSets: IWebGLGPUDescriptorSet[], dynamicOffsets: number[], viewport: GFXViewport | null, scissor: GFXRect | null, lineWidth: number | null, depthBias: IWebGLDepthBias | null, blendConstants: number[], depthBounds: IWebGLDepthBounds | null, stencilWriteMask: IWebGLStencilWriteMask | null, stencilCompareMask: IWebGLStencilCompareMask | null): void;
    export function WebGLCmdFuncDraw(device: WebGLDevice, drawInfo: GFXDrawInfo): void;
    export function WebGLCmdFuncExecuteCmds(device: WebGLDevice, cmdPackage: WebGLCmdPackage): void;
    export function WebGLCmdFuncCopyTexImagesToTexture(device: WebGLDevice, texImages: TexImageSource[], gpuTexture: IWebGLGPUTexture, regions: GFXBufferTextureCopy[]): void;
    export function WebGLCmdFuncCopyBuffersToTexture(device: WebGLDevice, buffers: ArrayBufferView[], gpuTexture: IWebGLGPUTexture, regions: GFXBufferTextureCopy[]): void;
}
declare module "cocos/core/gfx/webgl/webgl-buffer" {
    import { GFXBuffer, GFXBufferSource, IGFXBufferInfo, IGFXBufferViewInfo } from "cocos/core/gfx/buffer";
    import { IWebGLGPUBuffer, IWebGLGPUBufferView } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLBuffer extends GFXBuffer {
        get gpuBuffer(): IWebGLGPUBuffer;
        get gpuBufferView(): IWebGLGPUBufferView;
        private _gpuBuffer;
        private _gpuBufferView;
        private _uniformBuffer;
        initialize(info: IGFXBufferInfo | IGFXBufferViewInfo): boolean;
        destroy(): void;
        resize(size: number): void;
        update(buffer: GFXBufferSource, offset?: number, size?: number): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-sampler" {
    import { GFXSampler, IGFXSamplerInfo } from "cocos/core/gfx/sampler";
    import { IWebGLGPUSampler } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLSampler extends GFXSampler {
        get gpuSampler(): IWebGLGPUSampler;
        private _gpuSampler;
        initialize(info: IGFXSamplerInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-descriptor-set" {
    import { GFXDescriptorSet, IGFXDescriptorSetInfo } from "cocos/core/gfx/descriptor-set";
    import { IWebGLGPUDescriptorSet } from "cocos/core/gfx/webgl/webgl-gpu-objects";
    export class WebGLDescriptorSet extends GFXDescriptorSet {
        get gpuDescriptorSet(): IWebGLGPUDescriptorSet;
        private _gpuDescriptorSet;
        initialize(info: IGFXDescriptorSetInfo): boolean;
        destroy(): void;
        update(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-fence" {
    import { GFXFence, IGFXFenceInfo } from "cocos/core/gfx/fence";
    export class WebGLFence extends GFXFence {
        initialize(info: IGFXFenceInfo): boolean;
        destroy(): void;
        wait(): void;
        reset(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-primary-command-buffer" {
    import { GFXBuffer, GFXBufferSource } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { GFXBufferTextureCopy, GFXColor, GFXRect } from "cocos/core/gfx/define";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { WebGLCommandBuffer } from "cocos/core/gfx/webgl/webgl-command-buffer";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    export class WebGLPrimaryCommandBuffer extends WebGLCommandBuffer {
        beginRenderPass(renderPass: GFXRenderPass, framebuffer: GFXFramebuffer, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
        draw(inputAssembler: GFXInputAssembler): void;
        updateBuffer(buffer: GFXBuffer, data: GFXBufferSource, offset?: number, size?: number): void;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        execute(cmdBuffs: GFXCommandBuffer[], count: number): void;
        protected bindStates(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-queue" {
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { GFXQueue, IGFXQueueInfo } from "cocos/core/gfx/queue";
    import { GFXFence } from "cocos/core/gfx/fence";
    export class WebGLQueue extends GFXQueue {
        numDrawCalls: number;
        numInstances: number;
        numTris: number;
        initialize(info: IGFXQueueInfo): boolean;
        destroy(): void;
        submit(cmdBuffs: GFXCommandBuffer[], fence?: GFXFence): void;
        clear(): void;
    }
}
declare module "cocos/core/gfx/webgl/webgl-state-cache" {
    import { GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    export interface IWebGLTexUnit {
        glTexture: WebGLTexture | null;
    }
    export class WebGLStateCache {
        glArrayBuffer: WebGLBuffer | null;
        glElementArrayBuffer: WebGLBuffer | null;
        glVAO: WebGLVertexArrayObjectOES | null;
        texUnit: number;
        glTexUnits: IWebGLTexUnit[];
        glRenderbuffer: WebGLRenderbuffer | null;
        glFramebuffer: WebGLFramebuffer | null;
        viewport: GFXViewport;
        scissorRect: GFXRect;
        rs: GFXRasterizerState;
        dss: GFXDepthStencilState;
        bs: GFXBlendState;
        glProgram: WebGLProgram | null;
        glEnabledAttribLocs: boolean[];
        glCurrentAttribLocs: boolean[];
        constructor();
    }
}
declare module "cocos/core/gfx/webgl/webgl-device" {
    import { GFXDescriptorSet, IGFXDescriptorSetInfo } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer, IGFXBufferInfo, IGFXBufferViewInfo } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer, IGFXCommandBufferInfo } from "cocos/core/gfx/command-buffer";
    import { GFXDevice, IGFXDeviceInfo, GFXBindingMappingInfo } from "cocos/core/gfx/device";
    import { GFXFence, IGFXFenceInfo } from "cocos/core/gfx/fence";
    import { GFXFramebuffer, IGFXFramebufferInfo } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState, IGFXPipelineStateInfo } from "cocos/core/gfx/pipeline-state";
    import { GFXQueue, IGFXQueueInfo } from "cocos/core/gfx/queue";
    import { GFXRenderPass, IGFXRenderPassInfo } from "cocos/core/gfx/render-pass";
    import { GFXSampler, IGFXSamplerInfo } from "cocos/core/gfx/sampler";
    import { GFXShader, GFXShaderInfo } from "cocos/core/gfx/shader";
    import { GFXTexture, IGFXTextureInfo, IGFXTextureViewInfo } from "cocos/core/gfx/texture";
    import { WebGLCommandAllocator } from "cocos/core/gfx/webgl/webgl-command-allocator";
    import { WebGLQueue } from "cocos/core/gfx/webgl/webgl-queue";
    import { WebGLStateCache } from "cocos/core/gfx/webgl/webgl-state-cache";
    import { WebGLTexture } from "cocos/core/gfx/webgl/webgl-texture";
    import { GFXBufferTextureCopy, GFXFilter, GFXRect } from "cocos/core/gfx/define";
    import { IGFXDescriptorSetLayoutInfo, GFXDescriptorSetLayout, IGFXPipelineLayoutInfo, GFXPipelineLayout } from "cocos/core/index";
    export class WebGLDevice extends GFXDevice {
        get gl(): WebGLRenderingContext;
        get webGLQueue(): WebGLQueue;
        get isAntialias(): boolean;
        get isPremultipliedAlpha(): boolean;
        get useVAO(): boolean;
        get destroyShadersImmediately(): boolean;
        get noCompressedTexSubImage2D(): boolean;
        get bindingMappingInfo(): GFXBindingMappingInfo;
        get EXT_texture_filter_anisotropic(): EXT_texture_filter_anisotropic | null;
        get EXT_frag_depth(): EXT_frag_depth | null;
        get EXT_shader_texture_lod(): EXT_shader_texture_lod | null;
        get EXT_sRGB(): EXT_sRGB | null;
        get OES_vertex_array_object(): OES_vertex_array_object | null;
        get WEBGL_color_buffer_float(): WEBGL_color_buffer_float | null;
        get WEBGL_compressed_texture_etc1(): WEBGL_compressed_texture_etc1 | null;
        get WEBGL_compressed_texture_pvrtc(): WEBGL_compressed_texture_pvrtc | null;
        get WEBGL_compressed_texture_astc(): WEBGL_compressed_texture_astc | null;
        get WEBGL_compressed_texture_s3tc(): WEBGL_compressed_texture_s3tc | null;
        get WEBGL_compressed_texture_s3tc_srgb(): WEBGL_compressed_texture_s3tc_srgb | null;
        get WEBGL_debug_shaders(): WEBGL_debug_shaders | null;
        get WEBGL_draw_buffers(): WEBGL_draw_buffers | null;
        get WEBGL_lose_context(): WEBGL_lose_context | null;
        get WEBGL_depth_texture(): WEBGL_depth_texture | null;
        get WEBGL_debug_renderer_info(): WEBGL_debug_renderer_info | null;
        get OES_texture_half_float(): OES_texture_half_float | null;
        get OES_texture_half_float_linear(): OES_texture_half_float_linear | null;
        get OES_texture_float(): OES_texture_float | null;
        get OES_standard_derivatives(): OES_standard_derivatives | null;
        get OES_element_index_uint(): OES_element_index_uint | null;
        get ANGLE_instanced_arrays(): ANGLE_instanced_arrays | null;
        stateCache: WebGLStateCache;
        cmdAllocator: WebGLCommandAllocator;
        nullTex2D: WebGLTexture | null;
        nullTexCube: WebGLTexture | null;
        private _webGLRC;
        private _isAntialias;
        private _isPremultipliedAlpha;
        private _useVAO;
        private _destroyShadersImmediately;
        private _noCompressedTexSubImage2D;
        private _bindingMappingInfo;
        private _webGLContextLostHandler;
        private _extensions;
        private _EXT_texture_filter_anisotropic;
        private _EXT_frag_depth;
        private _EXT_shader_texture_lod;
        private _EXT_sRGB;
        private _OES_vertex_array_object;
        private _EXT_color_buffer_half_float;
        private _WEBGL_color_buffer_float;
        private _WEBGL_compressed_texture_etc1;
        private _WEBGL_compressed_texture_etc;
        private _WEBGL_compressed_texture_pvrtc;
        private _WEBGL_compressed_texture_astc;
        private _WEBGL_compressed_texture_s3tc;
        private _WEBGL_compressed_texture_s3tc_srgb;
        private _WEBGL_debug_shaders;
        private _WEBGL_draw_buffers;
        private _WEBGL_lose_context;
        private _WEBGL_depth_texture;
        private _WEBGL_debug_renderer_info;
        private _OES_texture_half_float;
        private _OES_texture_half_float_linear;
        private _OES_texture_float;
        private _OES_texture_float_linear;
        private _OES_standard_derivatives;
        private _OES_element_index_uint;
        private _ANGLE_instanced_arrays;
        initialize(info: IGFXDeviceInfo): boolean;
        destroy(): void;
        resize(width: number, height: number): void;
        acquire(): void;
        present(): void;
        createCommandBuffer(info: IGFXCommandBufferInfo): GFXCommandBuffer;
        createBuffer(info: IGFXBufferInfo | IGFXBufferViewInfo): GFXBuffer;
        createTexture(info: IGFXTextureInfo | IGFXTextureViewInfo): GFXTexture;
        createSampler(info: IGFXSamplerInfo): GFXSampler;
        createDescriptorSet(info: IGFXDescriptorSetInfo): GFXDescriptorSet;
        createShader(info: GFXShaderInfo): GFXShader;
        createInputAssembler(info: IGFXInputAssemblerInfo): GFXInputAssembler;
        createRenderPass(info: IGFXRenderPassInfo): GFXRenderPass;
        createFramebuffer(info: IGFXFramebufferInfo): GFXFramebuffer;
        createDescriptorSetLayout(info: IGFXDescriptorSetLayoutInfo): GFXDescriptorSetLayout;
        createPipelineLayout(info: IGFXPipelineLayoutInfo): GFXPipelineLayout;
        createPipelineState(info: IGFXPipelineStateInfo): GFXPipelineState;
        createFence(info: IGFXFenceInfo): GFXFence;
        createQueue(info: IGFXQueueInfo): GFXQueue;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        copyTexImagesToTexture(texImages: TexImageSource[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        copyFramebufferToBuffer(srcFramebuffer: GFXFramebuffer, dstBuffer: ArrayBuffer, regions: GFXBufferTextureCopy[]): void;
        blitFramebuffer(src: GFXFramebuffer, dst: GFXFramebuffer, srcRect: GFXRect, dstRect: GFXRect, filter: GFXFilter): void;
        private getExtension;
        private initStates;
        private _onWebGLContextLost;
    }
}
declare module "exports/gfx-webgl" {
    /**
     * @hidden
     */
    import { WebGLDevice } from "cocos/core/gfx/webgl/webgl-device";
    export { WebGLDevice };
}
declare module "cocos/core/gfx/webgl2/webgl2-command-allocator" {
    import { CachedArray } from "cocos/core/memop/cached-array";
    import { WebGL2CmdBeginRenderPass, WebGL2CmdBindStates, WebGL2CmdCopyBufferToTexture, WebGL2CmdDraw, WebGL2CmdObject, WebGL2CmdPackage, WebGL2CmdUpdateBuffer } from "cocos/core/gfx/webgl2/webgl2-commands";
    export class WebGL2CommandPool<T extends WebGL2CmdObject> {
        private _frees;
        private _freeIdx;
        private _freeCmds;
        constructor(clazz: new () => T, count: number);
        alloc(clazz: new () => T): T;
        free(cmd: T): void;
        freeCmds(cmds: CachedArray<T>): void;
        release(): void;
    }
    export class WebGL2CommandAllocator {
        beginRenderPassCmdPool: WebGL2CommandPool<WebGL2CmdBeginRenderPass>;
        bindStatesCmdPool: WebGL2CommandPool<WebGL2CmdBindStates>;
        drawCmdPool: WebGL2CommandPool<WebGL2CmdDraw>;
        updateBufferCmdPool: WebGL2CommandPool<WebGL2CmdUpdateBuffer>;
        copyBufferToTextureCmdPool: WebGL2CommandPool<WebGL2CmdCopyBufferToTexture>;
        constructor();
        clearCmds(cmdPackage: WebGL2CmdPackage): void;
        releaseCmds(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-gpu-objects" {
    import { GFXDrawInfo } from "cocos/core/gfx/buffer";
    import { GFXAddress, GFXDescriptorType, GFXBufferUsage, GFXFilter, GFXFormat, GFXMemoryUsage, GFXSampleCount, GFXShaderStageFlagBit, GFXTextureFlags, GFXTextureType, GFXTextureUsage, GFXType, GFXDynamicStateFlagBit } from "cocos/core/gfx/define";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    import { GFXColorAttachment, GFXDepthStencilAttachment } from "cocos/core/gfx/render-pass";
    import { GFXUniformBlock, GFXUniformSampler } from "cocos/core/gfx/shader";
    import { IGFXDescriptorSetLayoutBinding } from "cocos/core/gfx/descriptor-set-layout";
    export interface IWebGL2GPUUniformInfo {
        name: string;
        type: GFXType;
        count: number;
        offset: number;
        view: Float32Array | Int32Array;
        isDirty: boolean;
    }
    export interface IWebGL2GPUBuffer {
        usage: GFXBufferUsage;
        memUsage: GFXMemoryUsage;
        size: number;
        stride: number;
        glTarget: GLenum;
        glBuffer: WebGLBuffer | null;
        glOffset: number;
        buffer: ArrayBufferView | null;
        indirects: GFXDrawInfo[];
    }
    export interface IWebGL2GPUTexture {
        type: GFXTextureType;
        format: GFXFormat;
        usage: GFXTextureUsage;
        width: number;
        height: number;
        depth: number;
        size: number;
        arrayLayer: number;
        mipLevel: number;
        samples: GFXSampleCount;
        flags: GFXTextureFlags;
        isPowerOf2: boolean;
        glTarget: GLenum;
        glInternalFmt: GLenum;
        glFormat: GLenum;
        glType: GLenum;
        glUsage: GLenum;
        glTexture: WebGLTexture | null;
        glRenderbuffer: WebGLRenderbuffer | null;
        glWrapS: GLenum;
        glWrapT: GLenum;
        glMinFilter: GLenum;
        glMagFilter: GLenum;
    }
    export interface IWebGL2GPURenderPass {
        colorAttachments: GFXColorAttachment[];
        depthStencilAttachment: GFXDepthStencilAttachment | null;
    }
    export interface IWebGL2GPUFramebuffer {
        gpuRenderPass: IWebGL2GPURenderPass;
        gpuColorTextures: IWebGL2GPUTexture[];
        gpuDepthStencilTexture: IWebGL2GPUTexture | null;
        isOffscreen?: boolean;
        glFramebuffer: WebGLFramebuffer | null;
    }
    export interface IWebGL2GPUSampler {
        glSampler: WebGLSampler | null;
        minFilter: GFXFilter;
        magFilter: GFXFilter;
        mipFilter: GFXFilter;
        addressU: GFXAddress;
        addressV: GFXAddress;
        addressW: GFXAddress;
        minLOD: number;
        maxLOD: number;
        glMinFilter: GLenum;
        glMagFilter: GLenum;
        glWrapS: GLenum;
        glWrapT: GLenum;
        glWrapR: GLenum;
    }
    export interface IWebGL2GPUInput {
        name: string;
        type: GFXType;
        stride: number;
        count: number;
        size: number;
        glType: GLenum;
        glLoc: GLint;
    }
    export interface IWebGL2GPUUniform {
        binding: number;
        name: string;
        type: GFXType;
        stride: number;
        count: number;
        size: number;
        offset: number;
        glType: GLenum;
        glLoc: WebGLUniformLocation;
        array: number[];
        begin: number;
    }
    export interface IWebGL2GPUUniformBlock {
        set: number;
        binding: number;
        idx: number;
        name: string;
        size: number;
        glBinding: number;
    }
    export interface IWebGL2GPUUniformSampler {
        set: number;
        binding: number;
        name: string;
        type: GFXType;
        units: number[];
        glUnits: Int32Array;
        glType: GLenum;
        glLoc: WebGLUniformLocation;
    }
    export interface IWebGL2GPUShaderStage {
        type: GFXShaderStageFlagBit;
        source: string;
        glShader: WebGLShader | null;
    }
    export interface IWebGL2GPUShader {
        name: string;
        blocks: GFXUniformBlock[];
        samplers: GFXUniformSampler[];
        gpuStages: IWebGL2GPUShaderStage[];
        glProgram: WebGLProgram | null;
        glInputs: IWebGL2GPUInput[];
        glUniforms: IWebGL2GPUUniform[];
        glBlocks: IWebGL2GPUUniformBlock[];
        glSamplers: IWebGL2GPUUniformSampler[];
    }
    export interface IWebGL2GPUDescriptorSetLayout {
        bindings: IGFXDescriptorSetLayoutBinding[];
        dynamicBindings: number[];
        descriptorIndices: number[];
        descriptorCount: number;
    }
    export interface IWebGL2GPUPipelineLayout {
        gpuSetLayouts: IWebGL2GPUDescriptorSetLayout[];
        dynamicOffsetCount: number;
        dynamicOffsetOffsets: number[];
        dynamicOffsetIndices: number[][];
    }
    export interface IWebGL2GPUPipelineState {
        glPrimitive: GLenum;
        gpuShader: IWebGL2GPUShader | null;
        gpuPipelineLayout: IWebGL2GPUPipelineLayout | null;
        rs: GFXRasterizerState;
        dss: GFXDepthStencilState;
        bs: GFXBlendState;
        dynamicStates: GFXDynamicStateFlagBit[];
        gpuRenderPass: IWebGL2GPURenderPass | null;
    }
    export interface IWebGL2GPUDescriptor {
        type: GFXDescriptorType;
        gpuBuffer: IWebGL2GPUBuffer | null;
        gpuTexture: IWebGL2GPUTexture | null;
        gpuSampler: IWebGL2GPUSampler | null;
    }
    export interface IWebGL2GPUDescriptorSet {
        gpuDescriptors: IWebGL2GPUDescriptor[];
        descriptorIndices: number[];
    }
    export interface IWebGL2Attrib {
        name: string;
        glBuffer: WebGLBuffer | null;
        glType: GLenum;
        size: number;
        count: number;
        stride: number;
        componentCount: number;
        isNormalized: boolean;
        isInstanced: boolean;
        offset: number;
    }
    export interface IWebGL2GPUInputAssembler {
        attributes: IGFXAttribute[];
        gpuVertexBuffers: IWebGL2GPUBuffer[];
        gpuIndexBuffer: IWebGL2GPUBuffer | null;
        gpuIndirectBuffer: IWebGL2GPUBuffer | null;
        glAttribs: IWebGL2Attrib[];
        glIndexType: GLenum;
        glVAOs: Map<WebGLProgram, WebGLVertexArrayObject>;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-render-pass" {
    import { GFXRenderPass, IGFXRenderPassInfo } from "cocos/core/gfx/render-pass";
    import { IWebGL2GPURenderPass } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2RenderPass extends GFXRenderPass {
        get gpuRenderPass(): IWebGL2GPURenderPass;
        private _gpuRenderPass;
        initialize(info: IGFXRenderPassInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-texture" {
    import { GFXTexture, IGFXTextureInfo, IGFXTextureViewInfo } from "cocos/core/gfx/texture";
    import { IWebGL2GPUTexture } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2Texture extends GFXTexture {
        get gpuTexture(): IWebGL2GPUTexture;
        private _gpuTexture;
        initialize(info: IGFXTextureInfo | IGFXTextureViewInfo): boolean;
        destroy(): void;
        resize(width: number, height: number): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-framebuffer" {
    import { GFXFramebuffer, IGFXFramebufferInfo } from "cocos/core/gfx/framebuffer";
    import { IWebGL2GPUFramebuffer } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2Framebuffer extends GFXFramebuffer {
        get gpuFramebuffer(): IWebGL2GPUFramebuffer;
        private _gpuFramebuffer;
        initialize(info: IGFXFramebufferInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-input-assembler" {
    import { GFXInputAssembler, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { IWebGL2GPUInputAssembler } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2InputAssembler extends GFXInputAssembler {
        get gpuInputAssembler(): IWebGL2GPUInputAssembler;
        private _gpuInputAssembler;
        initialize(info: IGFXInputAssemblerInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-shader" {
    import { GFXShader, GFXShaderInfo } from "cocos/core/gfx/shader";
    import { IWebGL2GPUShader } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2Shader extends GFXShader {
        get gpuShader(): IWebGL2GPUShader;
        private _gpuShader;
        initialize(info: GFXShaderInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-descriptor-set-layout" {
    import { GFXDescriptorSetLayout, IGFXDescriptorSetLayoutInfo } from "cocos/core/gfx/descriptor-set-layout";
    import { IWebGL2GPUDescriptorSetLayout } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2DescriptorSetLayout extends GFXDescriptorSetLayout {
        get gpuDescriptorSetLayout(): IWebGL2GPUDescriptorSetLayout;
        private _gpuDescriptorSetLayout;
        initialize(info: IGFXDescriptorSetLayoutInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-pipeline-layout" {
    import { GFXPipelineLayout, IGFXPipelineLayoutInfo } from "cocos/core/gfx/pipeline-layout";
    import { IWebGL2GPUPipelineLayout } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2PipelineLayout extends GFXPipelineLayout {
        get gpuPipelineLayout(): IWebGL2GPUPipelineLayout;
        private _gpuPipelineLayout;
        initialize(info: IGFXPipelineLayoutInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-pipeline-state" {
    import { GFXPipelineState, IGFXPipelineStateInfo } from "cocos/core/gfx/pipeline-state";
    import { IWebGL2GPUPipelineState } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2PipelineState extends GFXPipelineState {
        get gpuPipelineState(): IWebGL2GPUPipelineState;
        private _gpuPipelineState;
        initialize(info: IGFXPipelineStateInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-command-buffer" {
    import { GFXDescriptorSet } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer, GFXBufferSource } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer, IGFXCommandBufferInfo } from "cocos/core/gfx/command-buffer";
    import { GFXBufferTextureCopy, GFXStencilFace, GFXColor, GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState } from "cocos/core/gfx/pipeline-state";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { WebGL2CommandAllocator } from "cocos/core/gfx/webgl2/webgl2-command-allocator";
    import { WebGL2CmdPackage } from "cocos/core/gfx/webgl2/webgl2-commands";
    import { WebGL2Device } from "cocos/core/gfx/webgl2/webgl2-device";
    import { IWebGL2GPUInputAssembler, IWebGL2GPUDescriptorSet, IWebGL2GPUPipelineState } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    export interface IWebGL2DepthBias {
        constantFactor: number;
        clamp: number;
        slopeFactor: number;
    }
    export interface IWebGL2DepthBounds {
        minBounds: number;
        maxBounds: number;
    }
    export interface IWebGL2StencilWriteMask {
        face: GFXStencilFace;
        writeMask: number;
    }
    export interface IWebGL2StencilCompareMask {
        face: GFXStencilFace;
        reference: number;
        compareMask: number;
    }
    export class WebGL2CommandBuffer extends GFXCommandBuffer {
        cmdPackage: WebGL2CmdPackage;
        protected _webGLAllocator: WebGL2CommandAllocator | null;
        protected _isInRenderPass: boolean;
        protected _curGPUPipelineState: IWebGL2GPUPipelineState | null;
        protected _curGPUDescriptorSets: IWebGL2GPUDescriptorSet[];
        protected _curGPUInputAssembler: IWebGL2GPUInputAssembler | null;
        protected _curDynamicOffsets: number[][];
        protected _curViewport: GFXViewport | null;
        protected _curScissor: GFXRect | null;
        protected _curLineWidth: number | null;
        protected _curDepthBias: IWebGL2DepthBias | null;
        protected _curBlendConstants: number[];
        protected _curDepthBounds: IWebGL2DepthBounds | null;
        protected _curStencilWriteMask: IWebGL2StencilWriteMask | null;
        protected _curStencilCompareMask: IWebGL2StencilCompareMask | null;
        protected _isStateInvalied: boolean;
        initialize(info: IGFXCommandBufferInfo): boolean;
        destroy(): void;
        begin(renderPass?: GFXRenderPass, subpass?: number, frameBuffer?: GFXFramebuffer): void;
        end(): void;
        beginRenderPass(renderPass: GFXRenderPass, framebuffer: GFXFramebuffer, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
        endRenderPass(): void;
        bindPipelineState(pipelineState: GFXPipelineState): void;
        bindDescriptorSet(set: number, descriptorSet: GFXDescriptorSet, dynamicOffsets?: number[]): void;
        bindInputAssembler(inputAssembler: GFXInputAssembler): void;
        setViewport(viewport: GFXViewport): void;
        setScissor(scissor: GFXRect): void;
        setLineWidth(lineWidth: number): void;
        setDepthBias(depthBiasConstantFactor: number, depthBiasClamp: number, depthBiasSlopeFactor: number): void;
        setBlendConstants(blendConstants: number[]): void;
        setDepthBound(minDepthBounds: number, maxDepthBounds: number): void;
        setStencilWriteMask(face: GFXStencilFace, writeMask: number): void;
        setStencilCompareMask(face: GFXStencilFace, reference: number, compareMask: number): void;
        draw(inputAssembler: GFXInputAssembler): void;
        updateBuffer(buffer: GFXBuffer, data: GFXBufferSource, offset?: number, size?: number): void;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        execute(cmdBuffs: GFXCommandBuffer[], count: number): void;
        get webGLDevice(): WebGL2Device;
        protected bindStates(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-commands" {
    import { CachedArray } from "cocos/core/memop/cached-array";
    import { GFXBufferSource, GFXDrawInfo } from "cocos/core/gfx/buffer";
    import { GFXBufferTextureCopy, GFXFilter, GFXFormat, GFXColor, GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { WebGL2CommandAllocator } from "cocos/core/gfx/webgl2/webgl2-command-allocator";
    import { IWebGL2DepthBias, IWebGL2DepthBounds, IWebGL2StencilCompareMask, IWebGL2StencilWriteMask } from "cocos/core/gfx/webgl2/webgl2-command-buffer";
    import { WebGL2Device } from "cocos/core/gfx/webgl2/webgl2-device";
    import { IWebGL2GPUInputAssembler, IWebGL2GPUDescriptorSet, IWebGL2GPUBuffer, IWebGL2GPUFramebuffer, IWebGL2GPUPipelineState, IWebGL2GPUSampler, IWebGL2GPUShader, IWebGL2GPUTexture, IWebGL2GPURenderPass } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export function GFXFormatToWebGLType(format: GFXFormat, gl: WebGL2RenderingContext): GLenum;
    export function GFXFormatToWebGLInternalFormat(format: GFXFormat, gl: WebGL2RenderingContext): GLenum;
    export function GFXFormatToWebGLFormat(format: GFXFormat, gl: WebGL2RenderingContext): GLenum;
    export enum WebGL2Cmd {
        BEGIN_RENDER_PASS = 0,
        END_RENDER_PASS = 1,
        BIND_STATES = 2,
        DRAW = 3,
        UPDATE_BUFFER = 4,
        COPY_BUFFER_TO_TEXTURE = 5,
        COUNT = 6
    }
    export abstract class WebGL2CmdObject {
        cmdType: WebGL2Cmd;
        refCount: number;
        constructor(type: WebGL2Cmd);
        abstract clear(): any;
    }
    export class WebGL2CmdBeginRenderPass extends WebGL2CmdObject {
        gpuRenderPass: IWebGL2GPURenderPass | null;
        gpuFramebuffer: IWebGL2GPUFramebuffer | null;
        renderArea: GFXRect;
        clearColors: GFXColor[];
        clearDepth: number;
        clearStencil: number;
        constructor();
        clear(): void;
    }
    export class WebGL2CmdBindStates extends WebGL2CmdObject {
        gpuPipelineState: IWebGL2GPUPipelineState | null;
        gpuInputAssembler: IWebGL2GPUInputAssembler | null;
        gpuDescriptorSets: IWebGL2GPUDescriptorSet[];
        dynamicOffsets: number[];
        viewport: GFXViewport | null;
        scissor: GFXRect | null;
        lineWidth: number | null;
        depthBias: IWebGL2DepthBias | null;
        blendConstants: number[];
        depthBounds: IWebGL2DepthBounds | null;
        stencilWriteMask: IWebGL2StencilWriteMask | null;
        stencilCompareMask: IWebGL2StencilCompareMask | null;
        constructor();
        clear(): void;
    }
    export class WebGL2CmdDraw extends WebGL2CmdObject {
        drawInfo: GFXDrawInfo;
        constructor();
        clear(): void;
    }
    export class WebGL2CmdUpdateBuffer extends WebGL2CmdObject {
        gpuBuffer: IWebGL2GPUBuffer | null;
        buffer: GFXBufferSource | null;
        offset: number;
        size: number;
        constructor();
        clear(): void;
    }
    export class WebGL2CmdCopyBufferToTexture extends WebGL2CmdObject {
        gpuTexture: IWebGL2GPUTexture | null;
        buffers: ArrayBufferView[];
        regions: GFXBufferTextureCopy[];
        constructor();
        clear(): void;
    }
    export class WebGL2CmdPackage {
        cmds: CachedArray<WebGL2Cmd>;
        beginRenderPassCmds: CachedArray<WebGL2CmdBeginRenderPass>;
        bindStatesCmds: CachedArray<WebGL2CmdBindStates>;
        drawCmds: CachedArray<WebGL2CmdDraw>;
        updateBufferCmds: CachedArray<WebGL2CmdUpdateBuffer>;
        copyBufferToTextureCmds: CachedArray<WebGL2CmdCopyBufferToTexture>;
        clearCmds(allocator: WebGL2CommandAllocator): void;
    }
    export function WebGL2CmdFuncCreateBuffer(device: WebGL2Device, gpuBuffer: IWebGL2GPUBuffer): void;
    export function WebGL2CmdFuncDestroyBuffer(device: WebGL2Device, gpuBuffer: IWebGL2GPUBuffer): void;
    export function WebGL2CmdFuncResizeBuffer(device: WebGL2Device, gpuBuffer: IWebGL2GPUBuffer): void;
    export function WebGL2CmdFuncUpdateBuffer(device: WebGL2Device, gpuBuffer: IWebGL2GPUBuffer, buffer: GFXBufferSource, offset: number, size: number): void;
    export function WebGL2CmdFuncCreateTexture(device: WebGL2Device, gpuTexture: IWebGL2GPUTexture): void;
    export function WebGL2CmdFuncDestroyTexture(device: WebGL2Device, gpuTexture: IWebGL2GPUTexture): void;
    export function WebGL2CmdFuncResizeTexture(device: WebGL2Device, gpuTexture: IWebGL2GPUTexture): void;
    export function WebGL2CmdFuncCreateSampler(device: WebGL2Device, gpuSampler: IWebGL2GPUSampler): void;
    export function WebGL2CmdFuncDestroySampler(device: WebGL2Device, gpuSampler: IWebGL2GPUSampler): void;
    export function WebGL2CmdFuncCreateFramebuffer(device: WebGL2Device, gpuFramebuffer: IWebGL2GPUFramebuffer): void;
    export function WebGL2CmdFuncDestroyFramebuffer(device: WebGL2Device, gpuFramebuffer: IWebGL2GPUFramebuffer): void;
    export function WebGL2CmdFuncCreateShader(device: WebGL2Device, gpuShader: IWebGL2GPUShader): void;
    export function WebGL2CmdFuncDestroyShader(device: WebGL2Device, gpuShader: IWebGL2GPUShader): void;
    export function WebGL2CmdFuncCreateInputAssember(device: WebGL2Device, gpuInputAssembler: IWebGL2GPUInputAssembler): void;
    export function WebGL2CmdFuncDestroyInputAssembler(device: WebGL2Device, gpuInputAssembler: IWebGL2GPUInputAssembler): void;
    export function WebGL2CmdFuncBeginRenderPass(device: WebGL2Device, gpuRenderPass: IWebGL2GPURenderPass | null, gpuFramebuffer: IWebGL2GPUFramebuffer | null, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
    export function WebGL2CmdFuncBindStates(device: WebGL2Device, gpuPipelineState: IWebGL2GPUPipelineState | null, gpuInputAssembler: IWebGL2GPUInputAssembler | null, gpuDescriptorSets: IWebGL2GPUDescriptorSet[], dynamicOffsets: number[], viewport: GFXViewport | null, scissor: GFXRect | null, lineWidth: number | null, depthBias: IWebGL2DepthBias | null, blendConstants: number[], depthBounds: IWebGL2DepthBounds | null, stencilWriteMask: IWebGL2StencilWriteMask | null, stencilCompareMask: IWebGL2StencilCompareMask | null): void;
    export function WebGL2CmdFuncDraw(device: WebGL2Device, drawInfo: GFXDrawInfo): void;
    export function WebGL2CmdFuncExecuteCmds(device: WebGL2Device, cmdPackage: WebGL2CmdPackage): void;
    export function WebGL2CmdFuncCopyTexImagesToTexture(device: WebGL2Device, texImages: TexImageSource[], gpuTexture: IWebGL2GPUTexture, regions: GFXBufferTextureCopy[]): void;
    export function WebGL2CmdFuncCopyBuffersToTexture(device: WebGL2Device, buffers: ArrayBufferView[], gpuTexture: IWebGL2GPUTexture, regions: GFXBufferTextureCopy[]): void;
    export function WebGL2CmdFuncBlitFramebuffer(device: WebGL2Device, src: IWebGL2GPUFramebuffer, dst: IWebGL2GPUFramebuffer, srcRect: GFXRect, dstRect: GFXRect, filter: GFXFilter): void;
}
declare module "cocos/core/gfx/webgl2/webgl2-buffer" {
    import { GFXBuffer, GFXBufferSource, IGFXBufferInfo, IGFXBufferViewInfo } from "cocos/core/gfx/buffer";
    import { IWebGL2GPUBuffer } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2Buffer extends GFXBuffer {
        get gpuBuffer(): IWebGL2GPUBuffer;
        private _gpuBuffer;
        initialize(info: IGFXBufferInfo | IGFXBufferViewInfo): boolean;
        destroy(): void;
        resize(size: number): void;
        update(buffer: GFXBufferSource, offset?: number, size?: number): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-sampler" {
    import { GFXSampler, IGFXSamplerInfo } from "cocos/core/gfx/sampler";
    import { IWebGL2GPUSampler } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2Sampler extends GFXSampler {
        get gpuSampler(): IWebGL2GPUSampler;
        private _gpuSampler;
        initialize(info: IGFXSamplerInfo): boolean;
        destroy(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-descriptor-set" {
    import { GFXDescriptorSet, IGFXDescriptorSetInfo } from "cocos/core/gfx/descriptor-set";
    import { IWebGL2GPUDescriptorSet } from "cocos/core/gfx/webgl2/webgl2-gpu-objects";
    export class WebGL2DescriptorSet extends GFXDescriptorSet {
        get gpuDescriptorSet(): IWebGL2GPUDescriptorSet;
        private _gpuDescriptorSet;
        initialize(info: IGFXDescriptorSetInfo): boolean;
        destroy(): void;
        update(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-fence" {
    import { GFXFence, IGFXFenceInfo } from "cocos/core/gfx/fence";
    export class WebGL2Fence extends GFXFence {
        private _sync;
        initialize(info: IGFXFenceInfo): boolean;
        destroy(): void;
        wait(): void;
        reset(): void;
        insert(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-primary-command-buffer" {
    import { GFXBuffer, GFXBufferSource } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { GFXBufferTextureCopy, GFXColor, GFXRect } from "cocos/core/gfx/define";
    import { GFXFramebuffer } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler } from "cocos/core/gfx/input-assembler";
    import { GFXTexture } from "cocos/core/gfx/texture";
    import { WebGL2CommandBuffer } from "cocos/core/gfx/webgl2/webgl2-command-buffer";
    import { GFXRenderPass } from "cocos/core/gfx/render-pass";
    export class WebGL2PrimaryCommandBuffer extends WebGL2CommandBuffer {
        beginRenderPass(renderPass: GFXRenderPass, framebuffer: GFXFramebuffer, renderArea: GFXRect, clearColors: GFXColor[], clearDepth: number, clearStencil: number): void;
        draw(inputAssembler: GFXInputAssembler): void;
        updateBuffer(buffer: GFXBuffer, data: GFXBufferSource, offset?: number, size?: number): void;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        execute(cmdBuffs: GFXCommandBuffer[], count: number): void;
        protected bindStates(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-queue" {
    import { GFXCommandBuffer } from "cocos/core/gfx/command-buffer";
    import { GFXQueue, IGFXQueueInfo } from "cocos/core/gfx/queue";
    import { GFXFence } from "cocos/core/gfx/fence";
    export class WebGL2Queue extends GFXQueue {
        numDrawCalls: number;
        numInstances: number;
        numTris: number;
        initialize(info: IGFXQueueInfo): boolean;
        destroy(): void;
        submit(cmdBuffs: GFXCommandBuffer[], fence?: GFXFence): void;
        clear(): void;
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-state-cache" {
    import { GFXRect, GFXViewport } from "cocos/core/gfx/define";
    import { GFXBlendState, GFXDepthStencilState, GFXRasterizerState } from "cocos/core/gfx/pipeline-state";
    export interface IWebGL2TexUnit {
        glTexture: WebGLTexture | null;
    }
    export class WebGL2StateCache {
        glArrayBuffer: WebGLBuffer | null;
        glElementArrayBuffer: WebGLBuffer | null;
        glUniformBuffer: WebGLBuffer | null;
        glBindUBOs: (WebGLBuffer | null)[];
        glBindUBOOffsets: number[];
        glVAO: WebGLVertexArrayObject | null;
        texUnit: number;
        glTexUnits: IWebGL2TexUnit[];
        glSamplerUnits: (WebGLSampler | null)[];
        glRenderbuffer: WebGLRenderbuffer | null;
        glFramebuffer: WebGLFramebuffer | null;
        glReadFramebuffer: WebGLFramebuffer | null;
        viewport: GFXViewport;
        scissorRect: GFXRect;
        rs: GFXRasterizerState;
        dss: GFXDepthStencilState;
        bs: GFXBlendState;
        glProgram: WebGLProgram | null;
        glEnabledAttribLocs: boolean[];
        glCurrentAttribLocs: boolean[];
        constructor();
    }
}
declare module "cocos/core/gfx/webgl2/webgl2-device" {
    import { GFXDescriptorSet, IGFXDescriptorSetInfo } from "cocos/core/gfx/descriptor-set";
    import { GFXBuffer, IGFXBufferInfo, IGFXBufferViewInfo } from "cocos/core/gfx/buffer";
    import { GFXCommandBuffer, IGFXCommandBufferInfo } from "cocos/core/gfx/command-buffer";
    import { GFXDevice, IGFXDeviceInfo, GFXBindingMappingInfo } from "cocos/core/gfx/device";
    import { GFXFence, IGFXFenceInfo } from "cocos/core/gfx/fence";
    import { GFXFramebuffer, IGFXFramebufferInfo } from "cocos/core/gfx/framebuffer";
    import { GFXInputAssembler, IGFXInputAssemblerInfo } from "cocos/core/gfx/input-assembler";
    import { GFXPipelineState, IGFXPipelineStateInfo } from "cocos/core/gfx/pipeline-state";
    import { GFXQueue, IGFXQueueInfo } from "cocos/core/gfx/queue";
    import { GFXRenderPass, IGFXRenderPassInfo } from "cocos/core/gfx/render-pass";
    import { GFXSampler, IGFXSamplerInfo } from "cocos/core/gfx/sampler";
    import { GFXShader, GFXShaderInfo } from "cocos/core/gfx/shader";
    import { GFXTexture, IGFXTextureInfo, IGFXTextureViewInfo } from "cocos/core/gfx/texture";
    import { WebGL2CommandAllocator } from "cocos/core/gfx/webgl2/webgl2-command-allocator";
    import { WebGL2StateCache } from "cocos/core/gfx/webgl2/webgl2-state-cache";
    import { WebGL2Texture } from "cocos/core/gfx/webgl2/webgl2-texture";
    import { GFXBufferTextureCopy, GFXFilter, GFXRect } from "cocos/core/gfx/define";
    import { GFXPipelineLayout, GFXDescriptorSetLayout, IGFXDescriptorSetLayoutInfo, IGFXPipelineLayoutInfo } from "cocos/core/index";
    export class WebGL2Device extends GFXDevice {
        get gl(): WebGL2RenderingContext;
        get isAntialias(): boolean;
        get isPremultipliedAlpha(): boolean;
        get useVAO(): boolean;
        get bindingMappingInfo(): GFXBindingMappingInfo;
        get EXT_texture_filter_anisotropic(): EXT_texture_filter_anisotropic | null;
        get OES_texture_float_linear(): OES_texture_float_linear | null;
        get EXT_color_buffer_float(): EXT_color_buffer_float | null;
        get EXT_disjoint_timer_query_webgl2(): EXT_disjoint_timer_query_webgl2 | null;
        get WEBGL_compressed_texture_etc1(): WEBGL_compressed_texture_etc1 | null;
        get WEBGL_compressed_texture_etc(): WEBGL_compressed_texture_etc | null;
        get WEBGL_compressed_texture_pvrtc(): WEBGL_compressed_texture_pvrtc | null;
        get WEBGL_compressed_texture_s3tc(): WEBGL_compressed_texture_s3tc | null;
        get WEBGL_compressed_texture_s3tc_srgb(): WEBGL_compressed_texture_s3tc_srgb | null;
        get WEBGL_texture_storage_multisample(): WEBGL_texture_storage_multisample | null;
        get WEBGL_debug_shaders(): WEBGL_debug_shaders | null;
        get WEBGL_lose_context(): WEBGL_lose_context | null;
        stateCache: WebGL2StateCache;
        cmdAllocator: WebGL2CommandAllocator;
        nullTex2D: WebGL2Texture | null;
        nullTexCube: WebGL2Texture | null;
        private _webGL2RC;
        private _isAntialias;
        private _isPremultipliedAlpha;
        private _useVAO;
        private _bindingMappingInfo;
        private _webGLContextLostHandler;
        private _extensions;
        private _EXT_texture_filter_anisotropic;
        private _OES_texture_float_linear;
        private _OES_texture_half_float_linear;
        private _EXT_color_buffer_float;
        private _EXT_disjoint_timer_query_webgl2;
        private _WEBGL_compressed_texture_etc1;
        private _WEBGL_compressed_texture_etc;
        private _WEBGL_compressed_texture_pvrtc;
        private _WEBGL_compressed_texture_astc;
        private _WEBGL_compressed_texture_s3tc;
        private _WEBGL_compressed_texture_s3tc_srgb;
        private _WEBGL_debug_renderer_info;
        private _WEBGL_texture_storage_multisample;
        private _WEBGL_debug_shaders;
        private _WEBGL_lose_context;
        initialize(info: IGFXDeviceInfo): boolean;
        destroy(): void;
        resize(width: number, height: number): void;
        acquire(): void;
        present(): void;
        createCommandBuffer(info: IGFXCommandBufferInfo): GFXCommandBuffer;
        createBuffer(info: IGFXBufferInfo | IGFXBufferViewInfo): GFXBuffer;
        createTexture(info: IGFXTextureInfo | IGFXTextureViewInfo): GFXTexture;
        createSampler(info: IGFXSamplerInfo): GFXSampler;
        createDescriptorSet(info: IGFXDescriptorSetInfo): GFXDescriptorSet;
        createShader(info: GFXShaderInfo): GFXShader;
        createInputAssembler(info: IGFXInputAssemblerInfo): GFXInputAssembler;
        createRenderPass(info: IGFXRenderPassInfo): GFXRenderPass;
        createFramebuffer(info: IGFXFramebufferInfo): GFXFramebuffer;
        createDescriptorSetLayout(info: IGFXDescriptorSetLayoutInfo): GFXDescriptorSetLayout;
        createPipelineLayout(info: IGFXPipelineLayoutInfo): GFXPipelineLayout;
        createPipelineState(info: IGFXPipelineStateInfo): GFXPipelineState;
        createFence(info: IGFXFenceInfo): GFXFence;
        createQueue(info: IGFXQueueInfo): GFXQueue;
        copyBuffersToTexture(buffers: ArrayBufferView[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        copyTexImagesToTexture(texImages: TexImageSource[], texture: GFXTexture, regions: GFXBufferTextureCopy[]): void;
        copyFramebufferToBuffer(srcFramebuffer: GFXFramebuffer, dstBuffer: ArrayBuffer, regions: GFXBufferTextureCopy[]): void;
        blitFramebuffer(src: GFXFramebuffer, dst: GFXFramebuffer, srcRect: GFXRect, dstRect: GFXRect, filter: GFXFilter): void;
        private getExtension;
        private initStates;
        private _onWebGLContextLost;
    }
}
declare module "exports/gfx-webgl2" {
    /**
     * @hidden
     */
    import { WebGL2Device } from "cocos/core/gfx/webgl2/webgl2-device";
    export { WebGL2Device };
}
declare module "cocos/particle/billboard" {
    import { Component } from "cocos/core/components/component";
    export class Billboard extends Component {
        private _texture;
        /**
         * @zh Billboard纹理。
         */
        get texture(): null;
        set texture(val: null);
        private _height;
        /**
         * @zh 高度。
         */
        get height(): number;
        set height(val: number);
        private _width;
        /**
         * @zh 宽度。
         */
        get width(): number;
        set width(val: number);
        private _rotation;
        /**
         * @zh 角度。
         */
        get rotation(): number;
        set rotation(val: number);
        private _model;
        private _mesh;
        private _material;
        private _uniform;
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        private attachToScene;
        private detachFromScene;
        private createModel;
    }
}
declare module "cocos/particle/animator/curve-range" {
    import { AnimationCurve } from "cocos/core/geometry/index";
    import { Texture2D } from "cocos/core/index";
    export const Mode: {
        Constant: number;
        Curve: number;
        TwoCurves: number;
        TwoConstants: number;
    };
    export default class CurveRange {
        static Mode: {
            Constant: number;
            Curve: number;
            TwoCurves: number;
            TwoConstants: number;
        };
        /**
         * @zh 曲线类型[[Mode]]。
         */
        mode: number;
        /**
         * @zh 当mode为Curve时，使用的曲线。
         */
        curve: AnimationCurve;
        /**
         * @zh 当mode为TwoCurves时，使用的曲线下限。
         */
        curveMin: AnimationCurve;
        /**
         * @zh 当mode为TwoCurves时，使用的曲线上限。
         */
        curveMax: AnimationCurve;
        /**
         * @zh 当mode为Constant时，曲线的值。
         */
        constant: number;
        /**
         * @zh 当mode为TwoConstants时，曲线的上限。
         */
        constantMin: number;
        /**
         * @zh 当mode为TwoConstants时，曲线的下限。
         */
        constantMax: number;
        /**
         * @zh 应用于曲线插值的系数。
         */
        multiplier: number;
        constructor();
        evaluate(time: number, rndRatio: number): number | undefined;
        getMax(): number;
        _onBeforeSerialize(props: any): any;
    }
    export function packCurveRangeZ(samples: number, cr: CurveRange, discrete?: boolean): Texture2D;
    export function packCurveRangeN(samples: number, cr: CurveRange, discrete?: boolean): Texture2D;
    export function packCurveRangeXY(samples: number, x: CurveRange, y: CurveRange, discrete?: boolean): Texture2D;
    export function packCurveRangeXYZ(samples: number, x: CurveRange, y: CurveRange, z: CurveRange, discrete?: boolean): Texture2D;
    export function packCurveRangeXYZW(samples: number, x: CurveRange, y: CurveRange, z: CurveRange, w: CurveRange, discrete?: boolean): Texture2D;
}
declare module "cocos/particle/animator/gradient" {
    import { Color } from "cocos/core/math/index";
    export class ColorKey {
        color: Color;
        time: number;
    }
    export class AlphaKey {
        alpha: number;
        time: number;
    }
    export default class Gradient {
        static Mode: {
            Blend: number;
            Fixed: number;
        };
        colorKeys: ColorKey[];
        alphaKeys: AlphaKey[];
        mode: number;
        private _color;
        constructor();
        setKeys(colorKeys: ColorKey[], alphaKeys: AlphaKey[]): void;
        sortKeys(): void;
        evaluate(time: number): Color;
        randomColor(): Color;
        private getRGB;
        private getAlpha;
    }
}
declare module "cocos/particle/animator/gradient-range" {
    import { Color } from "cocos/core/math/index";
    import Gradient from "cocos/particle/animator/gradient";
    import { Texture2D } from "cocos/core/index";
    export default class GradientRange {
        /**
         * @zh 渐变色类型 [[Mode]]。
         */
        get mode(): number;
        set mode(m: number);
        static Mode: {
            Color: number;
            Gradient: number;
            TwoColors: number;
            TwoGradients: number;
            RandomColor: number;
        };
        /**
         * @zh 当mode为Color时的颜色。
         */
        color: Color;
        /**
         * @zh 当mode为TwoColors时的颜色下限。
         */
        colorMin: Color;
        /**
         * @zh 当mode为TwoColors时的颜色上限。
         */
        colorMax: Color;
        /**
         * @zh 当mode为Gradient时的颜色渐变。
         */
        gradient: Gradient;
        /**
         * @zh 当mode为TwoGradients时的颜色渐变下限。
         */
        gradientMin: Gradient;
        /**
         * @zh 当mode为TwoGradients时的颜色渐变上限。
         */
        gradientMax: Gradient;
        private _mode;
        private _color;
        evaluate(time: number, rndRatio: number): Color;
        _onBeforeSerialize(props: any): any;
    }
    export function packGradientRange(samples: number, gr: GradientRange): Texture2D;
}
declare module "cocos/particle/models/line-model" {
    import { Vec3 } from "cocos/core/math/index";
    import { scene } from "cocos/core/renderer/index";
    import CurveRange from "cocos/particle/animator/curve-range";
    import GradientRange from "cocos/particle/animator/gradient-range";
    import { Material } from "cocos/core/assets/index";
    export class LineModel extends scene.Model {
        private _capacity;
        private _vertSize;
        private _vBuffer;
        private _vertAttrsFloatCount;
        private _vdataF32;
        private _vdataUint32;
        private _iaInfo;
        private _iaInfoBuffer;
        private _subMeshData;
        private _vertCount;
        private _indexCount;
        private _material;
        constructor();
        setCapacity(capacity: number): void;
        createBuffer(): void;
        updateMaterial(mat: Material): void;
        private createSubMeshData;
        addLineVertexData(positions: Vec3[], width: CurveRange, color: GradientRange): void;
        updateIA(count: number): void;
        private destroySubMeshData;
    }
}
declare module "cocos/particle/line" {
    import { Component } from "cocos/core/components/index";
    import { Vec2 } from "cocos/core/math/index";
    import CurveRange from "cocos/particle/animator/curve-range";
    import GradientRange from "cocos/particle/animator/gradient-range";
    export class Line extends Component {
        private _texture;
        /**
         * @zh 显示的纹理。
         */
        get texture(): null;
        set texture(val: null);
        private _material;
        private _materialInstance;
        private _worldSpace;
        /**
         * @zh positions是否为世界空间坐标。
         */
        get worldSpace(): boolean;
        set worldSpace(val: boolean);
        private _positions;
        /**
         * 每段折线的拐点坐标。
         */
        get positions(): never[];
        set positions(val: never[]);
        private _width;
        /**
         * @zh 线段的宽度。
         */
        get width(): CurveRange;
        set width(val: CurveRange);
        private _tile;
        /**
         * @zh 图块数。
         */
        get tile(): Vec2;
        set tile(val: Vec2);
        private _offset;
        get offset(): Vec2;
        set offset(val: Vec2);
        private _color;
        /**
         * @zh 线段颜色。
         */
        get color(): GradientRange;
        set color(val: GradientRange);
        /**
         * @ignore
         */
        private _model;
        private _tile_offset;
        constructor();
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        private attachToScene;
        private detachFromScene;
    }
}
declare module "cocos/particle/models/particle-batch-model" {
    /**
     * @hidden
     */
    import { Mesh } from "cocos/core/assets/mesh";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { scene } from "cocos/core/renderer/index";
    import { Particle } from "cocos/particle/particle";
    import { Material } from "cocos/core/assets/index";
    export default class ParticleBatchModel extends scene.Model {
        private _capacity;
        private _vertAttrs;
        private _vertSize;
        private _vBuffer;
        private _vertAttrsFloatCount;
        private _vdataF32;
        private _vdataUint32;
        private _iaInfo;
        private _iaInfoBuffer;
        private _subMeshData;
        private _mesh;
        private _vertCount;
        private _indexCount;
        private _startTimeOffset;
        private _lifeTimeOffset;
        private _iaInfoBufferReady;
        private _material;
        constructor();
        setCapacity(capacity: number): void;
        setVertexAttributes(mesh: Mesh | null, attrs: IGFXAttribute[]): void;
        private createSubMeshData;
        updateMaterial(mat: Material): void;
        addParticleVertexData(index: number, pvdata: any[]): void;
        addGPUParticleVertexData(p: Particle, num: number, time: number): void;
        updateGPUParticles(num: number, time: number, dt: number): number;
        constructAttributeIndex(): void;
        updateIA(count: number): void;
        clear(): void;
        destroy(): void;
        private rebuild;
        private destroySubMeshData;
    }
}
declare module "cocos/particle/enum" {
    export const Space: {
        World: number;
        Local: number;
        Custom: number;
    };
    /**
     * 粒子的生成模式。
     * @enum ParticleSystemRenderer.RenderMode
     */
    export const RenderMode: {
        /**
         * 粒子始终面向摄像机。
         */
        Billboard: number;
        /**
         * 粒子始终面向摄像机但会根据参数进行拉伸。
         */
        StrecthedBillboard: number;
        /**
         * 粒子始终与 XZ 平面平行。
         */
        HorizontalBillboard: number;
        /**
         * 粒子始终与 Y 轴平行且朝向摄像机。
         */
        VerticalBillboard: number;
        /**
         * 粒子保持模型本身状态。
         */
        Mesh: number;
    };
    /**
     * 粒子发射器类型。
     * @enum shapeModule.ShapeType
     */
    export const ShapeType: {
        /**
         * 立方体类型粒子发射器。
         */
        Box: number;
        /**
         * 圆形粒子发射器。
         */
        Circle: number;
        /**
         * 圆锥体粒子发射器。
         */
        Cone: number;
        /**
         * 球体粒子发射器。
         */
        Sphere: number;
        /**
         * 半球体粒子发射器。
         */
        Hemisphere: number;
    };
    /**
     * 粒子从发射器的哪个部位发射。
     * @enum shapeModule.EmitLocation
     */
    export const EmitLocation: {
        /**
         * 基础位置发射（仅对 Circle 类型及 Cone 类型的粒子发射器适用）。
         */
        Base: number;
        /**
         * 边框位置发射（仅对 Box 类型及 Circle 类型的粒子发射器适用）。
         */
        Edge: number;
        /**
         * 表面位置发射（对所有类型的粒子发射器都适用）。
         */
        Shell: number;
        /**
         * 内部位置发射（对所有类型的粒子发射器都适用）。
         */
        Volume: number;
    };
    /**
     * 粒子在扇形区域的发射方式。
     * @enum shapeModule.ArcMode
     */
    export const ArcMode: {
        /**
         * 随机位置发射。
         */
        Random: number;
        /**
         * 沿某一方向循环发射，每次循环方向相同。
         */
        Loop: number;
        /**
         * 循环发射，每次循环方向相反。
         */
        PingPong: number;
    };
    /**
     * 选择如何为粒子系统生成轨迹。
     * @enum trailModule.TrailMode
     */
    export const TrailMode: {
        /**
         * 粒子模式<bg>。
         * 创建一种效果，其中每个粒子在其路径中留下固定的轨迹。
         */
        Particles: number;
    };
    /**
     * 纹理填充模式。
     * @enum trailModule.TextureMode
     */
    export const TextureMode: {
        /**
         * 拉伸填充纹理。
         */
        Stretch: number;
    };
    export const ModuleRandSeed: {
        LIMIT: number;
        SIZE: number;
        TEXTURE: number;
        COLOR: number;
        FORCE: number;
        ROTATION: number;
        VELOCITY_X: number;
        VELOCITY_Y: number;
        VELOCITY_Z: number;
    };
}
declare module "cocos/particle/renderer/particle-system-renderer-cpu" {
    import { Material } from "cocos/core/assets/index";
    import { Particle, IParticleModule } from "cocos/particle/particle";
    import { ParticleSystemRendererBase } from "cocos/particle/renderer/particle-system-renderer-base";
    import { Component } from "cocos/core/index";
    export default class ParticleSystemRendererCPU extends ParticleSystemRendererBase {
        private _defines;
        private _trailDefines;
        private _frameTile_velLenScale;
        private _defaultMat;
        private _node_scale;
        private _attrs;
        private _particles;
        private _defaultTrailMat;
        private _updateList;
        private _animateList;
        private _runAnimateList;
        private _fillDataFunc;
        private _uScaleHandle;
        private _uLenHandle;
        private _inited;
        constructor(info: any);
        onInit(ps: Component): void;
        clear(): void;
        updateRenderMode(): void;
        getFreeParticle(): Particle | null;
        getDefaultTrailMaterial(): any;
        setNewParticle(p: Particle): void;
        private _initModuleList;
        enableModule(name: string, val: Boolean, pm: IParticleModule): void;
        updateParticles(dt: number): number;
        updateRenderData(): void;
        getParticleCount(): number;
        onMaterialModified(index: number, material: Material): void;
        onRebuildPSO(index: number, material: Material): void;
        private _setFillFunc;
        private _fillMeshData;
        private _fillStrecthedData;
        private _fillNormalData;
        private _setVertexAttrib;
        updateMaterialParams(): void;
        updateTrailMaterial(): void;
    }
}
declare module "cocos/particle/renderer/particle-system-renderer-gpu" {
    import { Material } from "cocos/core/assets/index";
    import { Component } from "cocos/core/components/index";
    import { IGFXAttribute } from "cocos/core/gfx/input-assembler";
    import { Particle, IParticleModule } from "cocos/particle/particle";
    import { ParticleSystemRendererBase } from "cocos/particle/renderer/particle-system-renderer-base";
    export default class ParticleSystemRendererGPU extends ParticleSystemRendererBase {
        private _defines;
        private _frameTile_velLenScale;
        private _node_scale;
        protected _vertAttrs: IGFXAttribute[];
        protected _defaultMat: Material | null;
        private _particleNum;
        private _tempParticle;
        private _colorTexture;
        private _forceTexture;
        private _velocityTexture;
        private _rotationTexture;
        private _sizeTexture;
        private _animTexture;
        private _uTimeHandle;
        private _uRotHandle;
        private _inited;
        constructor(info: any);
        onInit(ps: Component): void;
        updateRenderMode(): void;
        setVertexAttributes(): void;
        clear(): void;
        onDestroy(): void;
        enableModule(name: string, val: Boolean, pm: IParticleModule): void;
        getFreeParticle(): Particle | null;
        setNewParticle(p: Particle): void;
        updateParticles(dt: number): number;
        updateRenderData(): void;
        updateShaderUniform(dt: number): void;
        initShaderUniform(mat: Material): void;
        getParticleCount(): number;
        onMaterialModified(index: number, material: Material): void;
        onRebuildPSO(index: number, material: Material): void;
        private _setVertexAttrib;
        updateMaterialParams(): void;
    }
}
declare module "cocos/particle/renderer/particle-system-renderer-data" {
    import { Mesh, Texture2D } from "cocos/core/assets/index";
    export default class ParticleSystemRenderer {
        /**
         * @zh 设定粒子生成模式。
         */
        get renderMode(): number;
        set renderMode(val: number);
        /**
         * @zh 在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按速度大小进行拉伸。
         */
        get velocityScale(): number;
        set velocityScale(val: number);
        /**
         * @zh 在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按粒子大小进行拉伸。
         */
        get lengthScale(): number;
        set lengthScale(val: number);
        private _renderMode;
        private _velocityScale;
        private _lengthScale;
        private _mesh;
        /**
         * @zh 粒子发射的模型。
         */
        get mesh(): Mesh | null;
        set mesh(val: Mesh | null);
        /**
         * @zh 粒子使用的材质。
         */
        get particleMaterial(): any;
        set particleMaterial(val: any);
        /**
         * @zh 拖尾使用的材质。
         */
        get trailMaterial(): any;
        set trailMaterial(val: any);
        private _mainTexture;
        get mainTexture(): Texture2D | null;
        set mainTexture(val: Texture2D | null);
        private _useGPU;
        get useGPU(): boolean;
        set useGPU(val: boolean);
        private _particleSystem;
        onInit(ps: any): void;
        private _switchProcessor;
    }
}
declare module "cocos/particle/renderer/particle-system-renderer-base" {
    import { Component, IGFXAttribute } from "cocos/core/index";
    import ParticleBatchModel from "cocos/particle/models/particle-batch-model";
    import ParticleSystemRenderer from "cocos/particle/renderer/particle-system-renderer-data";
    import { Material } from "cocos/core/assets/index";
    import { Particle, IParticleModule } from "cocos/particle/particle";
    export interface IParticleSystemRenderer {
        onInit(ps: Component): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        clear(): void;
        attachToScene(): void;
        detachFromScene(): void;
        updateMaterialParams(): void;
        setVertexAttributes(): void;
        updateRenderMode(): void;
        onMaterialModified(index: number, material: Material): void;
        onRebuildPSO(index: number, material: Material): void;
        getParticleCount(): number;
        getFreeParticle(): Particle | null;
        setNewParticle(p: Particle): void;
        updateParticles(dt: number): number;
        updateRenderData(): void;
        enableModule(name: string, val: Boolean, pm: IParticleModule): void;
        updateTrailMaterial(): void;
        getDefaultTrailMaterial(): any;
    }
    export abstract class ParticleSystemRendererBase implements IParticleSystemRenderer {
        protected _particleSystem: any;
        protected _model: ParticleBatchModel | null;
        protected _renderInfo: ParticleSystemRenderer | null;
        protected _vertAttrs: IGFXAttribute[];
        constructor(info: ParticleSystemRenderer);
        onInit(ps: Component): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        attachToScene(): void;
        detachFromScene(): void;
        setVertexAttributes(): void;
        protected _initModel(): void;
        updateTrailMaterial(): void;
        getDefaultTrailMaterial(): null;
        abstract getParticleCount(): number;
        abstract getFreeParticle(): Particle | null;
        abstract onMaterialModified(index: number, material: Material): void;
        abstract onRebuildPSO(index: number, material: Material): void;
        abstract updateRenderMode(): void;
        abstract updateMaterialParams(): void;
        abstract clear(): void;
        abstract setNewParticle(p: Particle): void;
        abstract updateParticles(dt: number): number;
        abstract updateRenderData(): void;
        abstract enableModule(name: string, val: Boolean, pm: IParticleModule): void;
    }
}
declare module "cocos/particle/particle" {
    /**
     * @hidden
     */
    import { Color, Vec3, Mat4 } from "cocos/core/math/index";
    import { ParticleSystem } from "cocos/particle/particle-system";
    import { IParticleSystemRenderer } from "cocos/particle/renderer/particle-system-renderer-base";
    export class Particle {
        particleSystem: ParticleSystem;
        position: Vec3;
        velocity: Vec3;
        animatedVelocity: Vec3;
        ultimateVelocity: Vec3;
        angularVelocity: Vec3;
        axisOfRotation: Vec3;
        rotation: Vec3;
        startSize: Vec3;
        size: Vec3;
        startColor: Color;
        color: Color;
        randomSeed: number;
        remainingLifetime: number;
        startLifetime: number;
        emitAccumulator0: number;
        emitAccumulator1: number;
        frameIndex: number;
        startRow: number;
        constructor(particleSystem: any);
    }
    export const PARTICLE_MODULE_NAME: {
        COLOR: string;
        FORCE: string;
        LIMIT: string;
        ROTATION: string;
        SIZE: string;
        VELOCITY: string;
        TEXTURE: string;
    };
    export const PARTICLE_MODULE_ORDER: string[];
    export const PARTICLE_MODULE_PROPERTY: string[];
    export interface IParticleModule {
        target: IParticleSystemRenderer | null;
        needUpdate: Boolean;
        needAnimate: Boolean;
        name: string;
        bindTarget(target: any): void;
        update(space: number, trans: Mat4): void;
        animate(p: Particle, dt?: number): void;
    }
    export abstract class ParticleModuleBase implements IParticleModule {
        target: IParticleSystemRenderer | null;
        needUpdate: Boolean;
        needAnimate: Boolean;
        bindTarget(target: IParticleSystemRenderer): void;
        update(space: number, trans: Mat4): void;
        abstract name: string;
        abstract animate(p: Particle, dt?: number): void;
    }
}
declare module "cocos/particle/animator/color-overtime" {
    import { Particle } from "cocos/particle/particle";
    import GradientRange from "cocos/particle/animator/gradient-range";
    import { ParticleModuleBase } from "cocos/particle/particle";
    export default class ColorOvertimeModule extends ParticleModuleBase {
        _enable: boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): boolean;
        set enable(val: boolean);
        /**
         * @zh 颜色随时间变化的参数，各个 key 之间线性差值变化。
         */
        color: GradientRange;
        name: string;
        animate(particle: Particle): void;
    }
}
declare module "cocos/particle/particle-general-function" {
    /**
     * @hidden
     */
    import { Mat4, Quat, Vec2, Vec3 } from "cocos/core/math/index";
    export const particleEmitZAxis: Vec3;
    export function calculateTransform(systemSpace: number, moduleSpace: number, worldTransform: Mat4, outQuat: Quat): boolean;
    export function fixedAngleUnitVector2(out: Vec2 | Vec3, theta: number): void;
    export function randomUnitVector2(out: Vec2 | Vec3): void;
    export function randomUnitVector(out: Vec3): void;
    export function randomPointInUnitSphere(out: Vec3): void;
    export function randomPointBetweenSphere(out: Vec3, minRadius: number, maxRadius: number): void;
    export function randomPointInUnitCircle(out: Vec3): void;
    export function randomPointBetweenCircle(out: Vec3, minRadius: number, maxRadius: number): void;
    export function randomPointBetweenCircleAtFixedAngle(out: Vec3, minRadius: number, maxRadius: number, theta: number): void;
    export function randomPointInCube(out: Vec3, extents: Vec3): void;
    export function randomPointBetweenCube(out: Vec3, minBox: Vec3, maxBox: Vec3): void;
    export function randomSortArray(arr: any[]): void;
    export function randomSign(): number;
}
declare module "cocos/particle/animator/force-overtime" {
    import CurveRange from "cocos/particle/animator/curve-range";
    import { ParticleModuleBase } from "cocos/particle/particle";
    export default class ForceOvertimeModule extends ParticleModuleBase {
        _enable: Boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): Boolean;
        set enable(val: Boolean);
        /**
         * @zh X 轴方向上的加速度分量。
         */
        x: CurveRange;
        /**
         * @zh Y 轴方向上的加速度分量。
         */
        y: CurveRange;
        /**
         * @zh Z 轴方向上的加速度分量。
         */
        z: CurveRange;
        /**
         * @zh 加速度计算时采用的坐标系 [[Space]]。
         */
        space: number;
        randomized: boolean;
        private rotation;
        private needTransform;
        name: string;
        constructor();
        update(space: any, worldTransform: any): void;
        animate(p: any, dt: any): void;
    }
}
declare module "cocos/particle/animator/limit-velocity-overtime" {
    import { Mat4 } from "cocos/core/math/index";
    import { Particle, ParticleModuleBase } from "cocos/particle/particle";
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class LimitVelocityOvertimeModule extends ParticleModuleBase {
        _enable: Boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): Boolean;
        set enable(val: Boolean);
        /**
         * @zh X 轴方向上的速度下限。
         */
        limitX: CurveRange;
        /**
         * @zh Y 轴方向上的速度下限。
         */
        limitY: CurveRange;
        /**
         * @zh Z 轴方向上的速度下限。
         */
        limitZ: CurveRange;
        /**
         * @zh 速度下限。
         */
        limit: CurveRange;
        /**
         * @zh 当前速度与速度下限的插值。
         */
        dampen: number;
        /**
         * @zh 是否三个轴分开限制。
         */
        separateAxes: boolean;
        /**
         * @zh 计算速度下限时采用的坐标系 [[Space]]。
         */
        space: number;
        drag: null;
        multiplyDragByParticleSize: boolean;
        multiplyDragByParticleVelocity: boolean;
        name: string;
        private rotation;
        private needTransform;
        constructor();
        update(space: number, worldTransform: Mat4): void;
        animate(p: Particle, dt: number): void;
    }
}
declare module "cocos/particle/animator/rotation-overtime" {
    import { Particle, ParticleModuleBase } from "cocos/particle/particle";
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class RotationOvertimeModule extends ParticleModuleBase {
        _enable: Boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): Boolean;
        set enable(val: Boolean);
        private _separateAxes;
        /**
         * @zh 是否三个轴分开设定旋转（暂不支持）。
         */
        get separateAxes(): boolean;
        set separateAxes(val: boolean);
        /**
         * @zh 绕 X 轴设定旋转。
         */
        x: CurveRange;
        /**
         * @zh 绕 Y 轴设定旋转。
         */
        y: CurveRange;
        /**
         * @zh 绕 Z 轴设定旋转。
         */
        z: CurveRange;
        name: string;
        animate(p: Particle, dt: number): void;
    }
}
declare module "cocos/particle/animator/size-overtime" {
    import { Particle, ParticleModuleBase } from "cocos/particle/particle";
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class SizeOvertimeModule extends ParticleModuleBase {
        _enable: Boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): Boolean;
        set enable(val: Boolean);
        /**
         * @zh 决定是否在每个轴上独立控制粒子大小。
         */
        separateAxes: boolean;
        /**
         * @zh 定义一条曲线来决定粒子在其生命周期中的大小变化。
         */
        size: CurveRange;
        /**
         * @zh 定义一条曲线来决定粒子在其生命周期中 X 轴方向上的大小变化。
         */
        x: CurveRange;
        /**
         * @zh 定义一条曲线来决定粒子在其生命周期中 Y 轴方向上的大小变化。
         */
        y: CurveRange;
        /**
         * @zh 定义一条曲线来决定粒子在其生命周期中 Z 轴方向上的大小变化。
         */
        z: CurveRange;
        name: string;
        animate(particle: Particle, dt: number): void;
    }
}
declare module "cocos/particle/animator/texture-animation" {
    import { Particle, ParticleModuleBase } from "cocos/particle/particle";
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class TextureAnimationModule extends ParticleModuleBase {
        private _enable;
        private _numTilesX;
        private _numTilesY;
        /**
         * @zh 是否启用。
         */
        get enable(): boolean;
        set enable(val: boolean);
        private _mode;
        /**
         * @zh 设定粒子贴图动画的类型（暂只支持 Grid 模式）[[Mode]]。
         */
        get mode(): number;
        set mode(val: number);
        /**
         * @zh X 方向动画帧数。
         */
        get numTilesX(): number;
        set numTilesX(val: number);
        /**
         * @zh Y 方向动画帧数。
         */
        get numTilesY(): number;
        set numTilesY(val: number);
        /**
         * @zh 动画播放方式 [[Animation]]。
         */
        animation: number;
        /**
         * @zh 一个周期内动画播放的帧与时间变化曲线。
         */
        frameOverTime: CurveRange;
        /**
         * @zh 从第几帧开始播放，时间为整个粒子系统的生命周期。
         */
        startFrame: CurveRange;
        /**
         * @zh 一个生命周期内播放循环的次数。
         */
        cycleCount: number;
        private _flipU;
        /**
         * @ignore
         */
        get flipU(): number;
        set flipU(val: number);
        private _flipV;
        get flipV(): number;
        set flipV(val: number);
        private _uvChannelMask;
        get uvChannelMask(): number;
        set uvChannelMask(val: number);
        /**
         * @zh 随机从动画贴图中选择一行以生成动画。<br>
         * 此选项仅在动画播放方式为 SingleRow 时生效。
         */
        randomRow: boolean;
        /**
         * @zh 从动画贴图中选择特定行以生成动画。<br>
         * 此选项仅在动画播放方式为 SingleRow 时且禁用 randomRow 时可用。
         */
        rowIndex: number;
        name: string;
        init(p: Particle): void;
        animate(p: Particle, dt: number): void;
    }
}
declare module "cocos/particle/animator/velocity-overtime" {
    import { Mat4 } from "cocos/core/math/index";
    import { Particle, ParticleModuleBase } from "cocos/particle/particle";
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class VelocityOvertimeModule extends ParticleModuleBase {
        _enable: Boolean;
        /**
         * @zh 是否启用。
         */
        get enable(): Boolean;
        set enable(val: Boolean);
        /**
         * @zh X 轴方向上的速度分量。
         */
        x: CurveRange;
        /**
         * @zh Y 轴方向上的速度分量。
         */
        y: CurveRange;
        /**
         * @zh Z 轴方向上的速度分量。
         */
        z: CurveRange;
        /**
         * @zh 速度修正系数（只支持 CPU 粒子）。
         */
        speedModifier: CurveRange;
        /**
         * @zh 速度计算时采用的坐标系[[Space]]。
         */
        space: number;
        private rotation;
        private needTransform;
        name: string;
        constructor();
        update(space: number, worldTransform: Mat4): void;
        animate(p: Particle, dt: number): void;
    }
}
declare module "cocos/particle/burst" {
    import CurveRange from "cocos/particle/animator/curve-range";
    export default class Burst {
        private _time;
        /**
         * @zh 粒子系统开始运行到触发此次 Brust 的时间。
         */
        get time(): number;
        set time(val: number);
        private _repeatCount;
        /**
         * @zh Burst 的触发次数。
         */
        get repeatCount(): number;
        set repeatCount(val: number);
        /**
         * @zh 每次触发的间隔时间。
         */
        repeatInterval: number;
        /**
         * @zh 发射的粒子的数量。
         */
        count: CurveRange;
        private _remainingCount;
        private _curTime;
        constructor();
        update(psys: any, dt: number): void;
        getMaxCount(psys: any): number;
    }
}
declare module "cocos/particle/emitter/shape-module" {
    import { Vec3 } from "cocos/core/math/index";
    import CurveRange from "cocos/particle/animator/curve-range";
    import { ParticleSystem } from "cocos/particle/particle-system";
    export default class ShapeModule {
        /**
         * @zh 粒子发射器位置。
         */
        get position(): Vec3;
        set position(val: Vec3);
        /**
         * @zh 粒子发射器旋转角度。
         */
        get rotation(): Vec3;
        set rotation(val: Vec3);
        /**
         * @zh 粒子发射器缩放比例。
         */
        get scale(): Vec3;
        set scale(val: Vec3);
        /**
         * @zh 粒子发射器在一个扇形范围内发射。
         */
        get arc(): number;
        set arc(val: number);
        /**
         * @zh 圆锥的轴与母线的夹角<bg>。
         * 决定圆锥发射器的开合程度。
         */
        get angle(): number;
        set angle(val: number);
        private _enable;
        /**
         * @zh 是否启用。
         */
        get enable(): boolean;
        set enable(val: boolean);
        /**
         * @zh 粒子发射器类型 [[ShapeType]]。
         */
        _shapeType: number;
        get shapeType(): number;
        set shapeType(val: number);
        /**
         * @zh 粒子从发射器哪个部位发射 [[EmitLocation]]。
         */
        emitFrom: number;
        /**
         * @zh 根据粒子的初始方向决定粒子的移动方向。
         */
        alignToDirection: boolean;
        /**
         * @zh 粒子生成方向随机设定。
         */
        randomDirectionAmount: number;
        /**
         * @zh 表示当前发射方向与当前位置到结点中心连线方向的插值。
         */
        sphericalDirectionAmount: number;
        /**
         * @zh 粒子生成位置随机设定（设定此值为非 0 会使粒子生成位置超出生成器大小范围）。
         */
        randomPositionAmount: number;
        /**
         * @zh 粒子发射器半径。
         */
        radius: number;
        /**
         * @zh 粒子发射器发射位置（对 Box 类型的发射器无效）：<bg>
         * - 0 表示从表面发射；
         * - 1 表示从中心发射；
         * - 0 ~ 1 之间表示在中心到表面之间发射。
         */
        radiusThickness: number;
        /**
         * @zh 粒子在扇形范围内的发射方式 [[ArcMode]]。
         */
        arcMode: number;
        /**
         * @zh 控制可能产生粒子的弧周围的离散间隔。
         */
        arcSpread: number;
        /**
         * @zh 粒子沿圆周发射的速度。
         */
        arcSpeed: CurveRange;
        /**
         * @zh 圆锥顶部截面距离底部的轴长<bg>。
         * 决定圆锥发射器的高度。
         */
        length: number;
        /**
         * @zh 粒子发射器发射位置（针对 Box 类型的粒子发射器）。
         */
        boxThickness: Vec3;
        private _position;
        private _rotation;
        private _scale;
        private _arc;
        private _angle;
        private mat;
        private quat;
        private particleSystem;
        private lastTime;
        private totalAngle;
        constructor();
        onInit(ps: ParticleSystem): void;
        emit(p: any): void;
        private constructMat;
        private generateArcAngle;
    }
}
declare module "cocos/particle/renderer/trail" {
    import CurveRange from "cocos/particle/animator/curve-range";
    import GradientRange from "cocos/particle/animator/gradient-range";
    import { Particle } from "cocos/particle/particle";
    export default class TrailModule {
        /**
         * 是否启用。
         */
        get enable(): boolean;
        set enable(val: boolean);
        _enable: boolean;
        /**
         * 设定粒子生成轨迹的方式。
         */
        mode: number;
        /**
         * 轨迹存在的生命周期。
         */
        lifeTime: CurveRange;
        _minParticleDistance: number;
        /**
         * 每个轨迹粒子之间的最小间距。
         */
        get minParticleDistance(): number;
        set minParticleDistance(val: number);
        get space(): number;
        set space(val: number);
        /**
         * 粒子本身是否存在。
         */
        existWithParticles: boolean;
        /**
         * 设定纹理填充方式。
         */
        textureMode: number;
        widthFromParticle: boolean;
        /**
         * 控制轨迹长度的曲线。
         */
        widthRatio: CurveRange;
        colorFromParticle: boolean;
        colorOverTrail: GradientRange;
        colorOvertime: GradientRange;
        /**
         * 轨迹设定时的坐标系。
         */
        private _space;
        private _particleSystem;
        private _minSquaredDistance;
        private _vertSize;
        private _trailNum;
        private _trailLifetime;
        private vbOffset;
        private ibOffset;
        private _trailSegments;
        private _particleTrail;
        private _trailModel;
        private _iaInfo;
        private _iaInfoBuffer;
        private _subMeshData;
        private _vertAttrs;
        private _vbF32;
        private _vbUint32;
        private _iBuffer;
        private _needTransform;
        private _material;
        constructor();
        onInit(ps: any): void;
        onEnable(): void;
        onDisable(): void;
        _attachToScene(): void;
        _detachFromScene(): void;
        destroy(): void;
        clear(): void;
        updateMaterial(): void;
        update(): void;
        animate(p: Particle, scaledDt: number): void;
        removeParticle(p: Particle): void;
        updateRenderData(): void;
        updateIA(count: number): void;
        private _createModel;
        private rebuild;
        private _updateTrailElement;
        private _fillVertexBuffer;
        private _checkDirectionReverse;
        private destroySubMeshData;
    }
}
declare module "cocos/particle/particle-system" {
    /**
     * @category particle
     */
    import { RenderableComponent } from "cocos/core/3d/framework/renderable-component";
    import { Material } from "cocos/core/assets/material";
    import { scene } from "cocos/core/renderer/index";
    import ColorOverLifetimeModule from "cocos/particle/animator/color-overtime";
    import CurveRange from "cocos/particle/animator/curve-range";
    import ForceOvertimeModule from "cocos/particle/animator/force-overtime";
    import GradientRange from "cocos/particle/animator/gradient-range";
    import LimitVelocityOvertimeModule from "cocos/particle/animator/limit-velocity-overtime";
    import RotationOvertimeModule from "cocos/particle/animator/rotation-overtime";
    import SizeOvertimeModule from "cocos/particle/animator/size-overtime";
    import TextureAnimationModule from "cocos/particle/animator/texture-animation";
    import VelocityOvertimeModule from "cocos/particle/animator/velocity-overtime";
    import Burst from "cocos/particle/burst";
    import ShapeModule from "cocos/particle/emitter/shape-module";
    import ParticleSystemRenderer from "cocos/particle/renderer/particle-system-renderer-data";
    import TrailModule from "cocos/particle/renderer/trail";
    import { IParticleSystemRenderer } from "cocos/particle/renderer/particle-system-renderer-base";
    export class ParticleSystem extends RenderableComponent {
        /**
         * @zh 粒子系统能生成的最大粒子数量。
         */
        get capacity(): number;
        set capacity(val: number);
        /**
         * @zh 粒子初始颜色。
         */
        startColor: GradientRange;
        scaleSpace: number;
        startSize3D: boolean;
        /**
         * @zh 粒子初始大小。
         */
        startSizeX: CurveRange;
        /**
         * @zh 粒子初始大小。
         */
        startSizeY: CurveRange;
        /**
         * @zh 粒子初始大小。
         */
        startSizeZ: CurveRange;
        /**
         * @zh 粒子初始速度。
         */
        startSpeed: CurveRange;
        startRotation3D: boolean;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationX: CurveRange;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationY: CurveRange;
        /**
         * @zh 粒子初始旋转角度。
         */
        startRotationZ: CurveRange;
        /**
         * @zh 粒子系统开始运行后，延迟粒子发射的时间。
         */
        startDelay: CurveRange;
        /**
         * @zh 粒子生命周期。
         */
        startLifetime: CurveRange;
        /**
         * @zh 粒子系统运行时间。
         */
        duration: number;
        /**
         * @zh 粒子系统是否循环播放。
         */
        loop: boolean;
        /**
         * @zh 选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效）。
         */
        get prewarm(): boolean;
        set prewarm(val: boolean);
        /**
         * @zh 选择粒子系统所在的坐标系[[Space]]。<br>
         */
        get simulationSpace(): number;
        set simulationSpace(val: number);
        /**
         * @zh 控制整个粒子系统的更新速度。
         */
        simulationSpeed: number;
        /**
         * @zh 粒子系统加载后是否自动开始播放。
         */
        playOnAwake: boolean;
        /**
         * @zh 粒子受重力影响的重力系数。
         */
        gravityModifier: CurveRange;
        /**
         * @zh 每秒发射的粒子数。
         */
        rateOverTime: CurveRange;
        /**
         * @zh 每移动单位距离发射的粒子数。
         */
        rateOverDistance: CurveRange;
        /**
         * @zh 设定在指定时间发射指定数量的粒子的 burst 的数量。
         */
        bursts: Burst[];
        get sharedMaterials(): (Material | null)[];
        set sharedMaterials(val: (Material | null)[]);
        _colorOverLifetimeModule: ColorOverLifetimeModule | null;
        /**
         * @zh 颜色控制模块。
         */
        get colorOverLifetimeModule(): ColorOverLifetimeModule | null;
        set colorOverLifetimeModule(val: ColorOverLifetimeModule | null);
        _shapeModule: ShapeModule | null;
        /**
         * @zh 粒子发射器模块。
         */
        get shapeModule(): ShapeModule | null;
        set shapeModule(val: ShapeModule | null);
        _sizeOvertimeModule: SizeOvertimeModule | null;
        /**
         * @zh 粒子大小模块。
         */
        get sizeOvertimeModule(): SizeOvertimeModule | null;
        set sizeOvertimeModule(val: SizeOvertimeModule | null);
        _velocityOvertimeModule: VelocityOvertimeModule | null;
        /**
         * @zh 粒子速度模块。
         */
        get velocityOvertimeModule(): VelocityOvertimeModule | null;
        set velocityOvertimeModule(val: VelocityOvertimeModule | null);
        _forceOvertimeModule: ForceOvertimeModule | null;
        /**
         * @zh 粒子加速度模块。
         */
        get forceOvertimeModule(): ForceOvertimeModule | null;
        set forceOvertimeModule(val: ForceOvertimeModule | null);
        _limitVelocityOvertimeModule: LimitVelocityOvertimeModule | null;
        /**
         * @zh 粒子限制速度模块（只支持 CPU 粒子）。
         */
        get limitVelocityOvertimeModule(): LimitVelocityOvertimeModule | null;
        set limitVelocityOvertimeModule(val: LimitVelocityOvertimeModule | null);
        _rotationOvertimeModule: RotationOvertimeModule | null;
        /**
         * @zh 粒子旋转模块。
         */
        get rotationOvertimeModule(): RotationOvertimeModule | null;
        set rotationOvertimeModule(val: RotationOvertimeModule | null);
        _textureAnimationModule: TextureAnimationModule | null;
        /**
         * @zh 贴图动画模块。
         */
        get textureAnimationModule(): TextureAnimationModule | null;
        set textureAnimationModule(val: TextureAnimationModule | null);
        _trailModule: TrailModule | null;
        /**
         * @zh 粒子轨迹模块。
         */
        get trailModule(): TrailModule | null;
        set trailModule(val: TrailModule | null);
        renderer: ParticleSystemRenderer;
        enableCulling: boolean;
        /**
         * @ignore
         */
        private _isPlaying;
        private _isPaused;
        private _isStopped;
        private _isEmitting;
        private _time;
        private _emitRateTimeCounter;
        private _emitRateDistanceCounter;
        private _oldWPos;
        private _curWPos;
        private _customData1;
        private _customData2;
        private _subEmitters;
        private _prewarm;
        private _capacity;
        private _simulationSpace;
        processor: IParticleSystemRenderer;
        constructor();
        onLoad(): void;
        _onMaterialModified(index: number, material: Material): void;
        _onRebuildPSO(index: number, material: Material): void;
        _collectModels(): scene.Model[];
        protected _attachToScene(): void;
        protected _detachFromScene(): void;
        bindModule(): void;
        /**
         * 播放粒子效果。
         */
        play(): void;
        /**
         * 暂停播放粒子效果。
         */
        pause(): void;
        /**
         * 停止播放粒子。
         */
        stop(): void;
        /**
         * 将所有粒子从粒子系统中清除。
         */
        clear(): void;
        /**
         * @zh 获取当前粒子数量
         */
        getParticleCount(): number;
        /**
         * @ignore
         */
        setCustomData1(x: any, y: any): void;
        setCustomData2(x: any, y: any): void;
        protected onDestroy(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected update(dt: number): void;
        protected _onVisibilityChange(val: any): void;
        private emit;
        private _prewarmSystem;
        private _emit;
        private _resetPosition;
        private addSubEmitter;
        private removeSubEmitter;
        private addBurst;
        private removeBurst;
        /**
         * @ignore
         */
        get isPlaying(): boolean;
        get isPaused(): boolean;
        get isStopped(): boolean;
        get isEmitting(): boolean;
        get time(): number;
        _onBeforeSerialize(props: any): any;
    }
}
declare module "cocos/particle/particle-utils" {
    import { CCObject } from "cocos/core/data/object";
    import { Node } from "cocos/core/scene-graph/index";
    export class ParticleUtils {
        /**
         * instantiate
         */
        static instantiate(prefab: any): CCObject;
        static destroy(prefab: any): void;
        static play(rootNode: Node): void;
        static stop(rootNode: Node): void;
        private static particleSystemPool;
        private static registeredSceneEvent;
        private static onSceneUnload;
    }
}
declare module "cocos/particle/deprecated" {
    import { ParticleSystem } from "cocos/particle/particle-system";
    import { Billboard } from "cocos/particle/billboard";
    import { Line } from "cocos/particle/line";
    /**
     * Alias of [[ParticleSystem]]
     * @deprecated Since v1.2
     */
    export { ParticleSystem as ParticleSystemComponent };
    /**
     * Alias of [[Billboard]]
     * @deprecated Since v1.2
     */
    export { Billboard as BillboardComponent };
    /**
     * Alias of [[Line]]
     * @deprecated Since v1.2
     */
    export { Line as LineComponent };
}
declare module "cocos/particle/index" {
    /**
     * @hidden
     */
    import { Billboard } from "cocos/particle/billboard";
    import { Line } from "cocos/particle/line";
    import { ParticleSystem } from "cocos/particle/particle-system";
    import { ParticleUtils } from "cocos/particle/particle-utils";
    import CurveRange from "cocos/particle/animator/curve-range";
    export { Billboard, Line, ParticleSystem, ParticleUtils, CurveRange };
    export * from "cocos/particle/deprecated";
}
declare module "exports/particle" {
    /**
     * @hidden
     */
    export * from "cocos/particle/index";
}
declare module "cocos/physics/ammo/ammo-instantiated" {
    import AmmoClosure from '@cocos/ammo';
    const Ammo: typeof AmmoClosure;
    /**
     * `'@cocos/ammo'` exports an async namespace. Let's call it `Ammo`.
     * Contents of `Ammo` are only valid for access once `Ammo().then()` is called.
     * That means we should not only import the `Ammo` but also wait for its instantiation:
     * ```ts
     * import Ammo from '@cocos/ammo';
     * const v = Ammo.btVector3(); // Error: Ammo is not instantiated!
     * ```
     *
     * That's why this module comes ---
     * The default export `Ammo` from this module has the meaning:
     * when you got the export, it had been instantiated.
     *
     */
    export { Ammo as default };
    /**
     * With the stage 3 proposal "top level await",
     * we may got a simple `await waitForAmmoInstantiation();` statement in this module.
     * It guarantees the promise `waitForAmmoInstantiation()`
     * is resolved before this module finished its execution.
     * But this technique is rarely implemented for now and can not be implemented in CommonJS.
     * We have to expose this waiting function to beg for earlier invocation by the external.
     * In Cocos Creator Editor's implementation,
     * it awaits for the:
     * ```ts
     * import thisFunction from 'cc.wait-for-ammo-instantiated';
     * await thisFunction();
     * ```
     * before `'cc.physics-ammo'` can be imported;
     * @param wasmBinary The .wasm file, if any.
     */
    export function waitForAmmoInstantiation(wasmBinary?: ArrayBuffer): Promise<void>;
    export namespace waitForAmmoInstantiation {
        /**
         * True if the `'@cocos/ammo'` is the WebAssembly edition.
         */
        const isWasm: boolean;
    }
}
declare module "cocos/physics/framework/physics-selector" {
    /**
     * @hidden
     */
    interface IPhysicsWrapperObject {
        PhysicsWorld: any;
        RigidBody?: any;
        BoxShape: any;
        SphereShape: any;
        CapsuleShape?: any;
        TrimeshShape?: any;
        CylinderShape?: any;
        ConeShape?: any;
        TerrainShape?: any;
        SimplexShape?: any;
        PlaneShape?: any;
        PointToPointConstraint?: any;
        HingeConstraint?: any;
        ConeTwistConstraint?: any;
    }
    type IPhysicsEngineId = 'builtin' | 'cannon.js' | 'ammo.js' | string | undefined;
    export let WRAPPER: IPhysicsWrapperObject;
    export let physicsEngineId: IPhysicsEngineId;
    export function select(id: IPhysicsEngineId, wrapper: IPhysicsWrapperObject): void;
}
declare module "cocos/physics/framework/physics-ray-result" {
    /**
     * @category physics
     */
    import { Vec3 } from "cocos/core/math/index";
    import { Collider } from "exports/physics-framework";
    import { IVec3Like } from "cocos/core/math/type-define";
    /**
     * @en
     * Used to store physics ray test results.
     * @zh
     * 用于保存物理射线检测结果。
     */
    export class PhysicsRayResult {
        /**
         * @en
         * The hit point，in world space.
         * @zh
         * 在世界坐标系下的击中点。
         */
        get hitPoint(): Vec3;
        /**
         * @en
         * The distance between the ray origin with the hit.
         * @zh
         * 距离。
         */
        get distance(): number;
        /**
         * @en
         * The collider hit by the ray.
         * @zh
         * 击中的碰撞盒
         */
        get collider(): Collider;
        /**
         * @en
         * The normal of the hit plane，in world space.
         * @zh
         * 在世界坐标系下击中面的法线。
         */
        get hitNormal(): Vec3;
        private _hitPoint;
        private _hitNormal;
        private _distance;
        private _collider;
        /**
         * @en
         * internal methods.
         * @zh
         * 设置射线，此方法由引擎内部使用，请勿在外部脚本调用。
         */
        _assign(hitPoint: IVec3Like, distance: number, collider: Collider, hitNormal: IVec3Like): void;
        /**
         * @en
         * clone.
         * @zh
         * 克隆。
         */
        clone(): PhysicsRayResult;
    }
}
declare module "cocos/physics/spec/i-physics-world" {
    /**
     * @hidden
     */
    import { IVec3Like } from "cocos/core/math/type-define";
    import { PhysicsRayResult } from "cocos/physics/framework/physics-ray-result";
    import { ray } from "cocos/core/geometry/index";
    import { RecyclePool } from "cocos/core/index";
    import { PhysicMaterial } from "cocos/physics/framework/index";
    export interface IRaycastOptions {
        mask: number;
        group: number;
        queryTrigger: boolean;
        maxDistance: number;
    }
    export interface IPhysicsWorld {
        readonly impl: any;
        setGravity: (v: IVec3Like) => void;
        setAllowSleep: (v: boolean) => void;
        setDefaultMaterial: (v: PhysicMaterial) => void;
        step(fixedTimeStep: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
        raycast(worldRay: ray, options: IRaycastOptions, pool: RecyclePool<PhysicsRayResult>, results: PhysicsRayResult[]): boolean;
        raycastClosest(worldRay: ray, options: IRaycastOptions, out: PhysicsRayResult): boolean;
        emitEvents(): void;
        syncSceneToPhysics(): void;
        updateCollisionMatrix(group: number, mask: number): void;
    }
}
declare module "cocos/physics/spec/i-lifecycle" {
    /**
     * @hidden
     */
    export interface ILifecycle {
        /**
         * @en Update is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 update。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        update?(dt: number): void;
        /**
         * @en LateUpdate is called every frame, if the Component is enabled.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 如果该组件启用，则每帧调用 LateUpdate。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         * @param dt - the delta time in seconds it took to complete the last frame
         */
        lateUpdate?(dt: number): void;
        /**
         * @en `__preload` is called before every onLoad.<br/>
         * It is used to initialize the builtin components internally,<br/>
         * to avoid checking whether onLoad is called before every public method calls.<br/>
         * This method should be removed if script priority is supported.
         * @zh `__preload` 在每次onLoad之前调用。<br/>
         * 它用于在内部初始化内置组件，<br/>
         * 以避免在每次公有方法调用之前检查是否调用了onLoad。<br/>
         * 如果支持脚本优先级，则应删除此方法。
         * @private
         */
        __preload?(component: any): void;
        /**
         * @en
         * When attaching to an active node or its node first activated.<br/>
         * onLoad is always called before any start functions, this allows you to order initialization of scripts.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 当附加到一个激活的节点上或者其节点第一次激活时候调用。onLoad 总是会在任何 start 方法调用前执行，这能用于安排脚本的初始化顺序。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        onLoad?(): void;
        /**
         * @en
         * Called before all scripts' update if the Component is enabled the first time.<br/>
         * Usually used to initialize some logic which need to be called after all components' `onload` methods called.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh
         * 如果该组件第一次启用，则在所有组件的 update 之前调用。通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        start?(): void;
        /**
         * @en Called when this component becomes enabled and its node is active.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被启用，并且它的节点也激活时。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        onEnable?(): void;
        /**
         * @en Called when this component becomes disabled or its node becomes inactive.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被禁用或节点变为无效时调用。<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        onDisable?(): void;
        /**
         * @en Called when this component will be destroyed.<br/>
         * This is a lifecycle method. It may not be implemented in the super class.<br/>
         * You can only call its super class method inside it. It should not be called manually elsewhere.
         * @zh 当该组件被销毁时调用<br/>
         * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
         */
        onDestroy?(): void;
        onFocusInEditor?(): void;
        onLostFocusInEditor?(): void;
        /**
         * @en Called to initialize the component or node’s properties when adding the component the first time or when the Reset command is used.
         * This function is only called in editor.<br/>
         * @zh 用来初始化组件或节点的一些属性，当该组件被第一次添加到节点上或用户点击了它的 Reset 菜单时调用。这个回调只会在编辑器下调用。
         */
        resetInEditor?(): void;
        /**
         * @en
         * onRestore is called after the user clicks the Reset item in the Inspector's context menu or performs
         * an undo operation on this component.<br/>
         * <br/>
         * If the component contains the "internal state", short for "temporary member variables which not included<br/>
         * in its CCClass properties", then you may need to implement this function.<br/>
         * <br/>
         * The editor will call the getset accessors of your component to record/restore the component's state<br/>
         * for undo/redo operation. However, in extreme cases, it may not works well. Then you should implement<br/>
         * this function to manually synchronize your component's "internal states" with its public properties.<br/>
         * Once you implement this function, all the getset accessors of your component will not be called when<br/>
         * the user performs an undo/redo operation. Which means that only the properties with default value<br/>
         * will be recorded or restored by editor.<br/>
         * <br/>
         * Similarly, the editor may failed to reset your component correctly in extreme cases. Then if you need<br/>
         * to support the reset menu, you should manually synchronize your component's "internal states" with its<br/>
         * properties in this function. Once you implement this function, all the getset accessors of your component<br/>
         * will not be called during reset operation. Which means that only the properties with default value<br/>
         * will be reset by editor.
         *
         * This function is only called in editor mode.
         * @zh
         * onRestore 是用户在检查器菜单点击 Reset 时，对此组件执行撤消操作后调用的。<br/>
         * <br/>
         * 如果组件包含了“内部状态”（不在 CCClass 属性中定义的临时成员变量），那么你可能需要实现该方法。<br/>
         * <br/>
         * 编辑器执行撤销/重做操作时，将调用组件的 get set 来录制和还原组件的状态。
         * 然而，在极端的情况下，它可能无法良好运作。<br/>
         * 那么你就应该实现这个方法，手动根据组件的属性同步“内部状态”。
         * 一旦你实现这个方法，当用户撤销或重做时，组件的所有 get set 都不会再被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器记录和还原。<br/>
         * <br/>
         * 同样的，编辑可能无法在极端情况下正确地重置您的组件。<br/>
         * 于是如果你需要支持组件重置菜单，你需要在该方法中手工同步组件属性到“内部状态”。<br/>
         * 一旦你实现这个方法，组件的所有 get set 都不会在重置操作时被调用。
         * 这意味着仅仅指定了默认值的属性将被编辑器重置。
         * <br/>
         * 此方法仅在编辑器下会被调用。
         */
        onRestore?(): void;
    }
}
declare module "cocos/physics/spec/i-group-mask" {
    /**
     * @hidden
     */
    export interface IGroupMask {
        setGroup(v: number): void;
        getGroup(): number;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        setMask(v: number): void;
        getMask(): number;
        addMask(v: number): void;
        removeMask(v: number): void;
    }
}
declare module "cocos/physics/framework/physics-enum" {
    export enum ERigidBodyType {
        DYNAMIC = 1,
        STATIC = 2,
        KINEMATIC = 4
    }
    export enum EAxisDirection {
        X_AXIS = 0,
        Y_AXIS = 1,
        Z_AXIS = 2
    }
    export enum ESimplexType {
        VERTEX = 1,
        LINE = 2,
        TRIANGLE = 3,
        TETRAHEDRON = 4
    }
    export enum EColliderType {
        BOX = 0,
        SPHERE = 1,
        CAPSULE = 2,
        CYLINDER = 3,
        CONE = 4,
        MESH = 5,
        PLANE = 6,
        SIMPLEX = 7,
        TERRAIN = 8
    }
    export enum EConstraintType {
        POINT_TO_POINT = 0,
        HINGE = 1,
        CONE_TWIST = 2
    }
}
declare module "cocos/physics/framework/components/rigid-body" {
    import { Vec3 } from "cocos/core/math/index";
    import { Component } from "cocos/core/index";
    import { IRigidBody } from "cocos/physics/spec/i-rigid-body";
    import { ERigidBodyType } from "cocos/physics/framework/physics-enum";
    /**
     * @en
     * Rigid body component.
     * @zh
     * 刚体组件。
     */
    export class RigidBody extends Component {
        static readonly ERigidBodyType: typeof ERigidBodyType;
        /**
         * @en
         * Gets or sets the group of the rigid body.
         * @zh
         * 获取或设置分组。
         */
        get group(): number;
        set group(v: number);
        /**
         * @en
         * Gets or sets the mass of the rigid body.
         * @zh
         * 获取或设置刚体的质量。
         */
        get mass(): number;
        set mass(value: number);
        /**
         * @en
         * Gets or sets whether hibernation is allowed.
         * @zh
         * 获取或设置是否允许休眠。
         */
        get allowSleep(): boolean;
        set allowSleep(v: boolean);
        /**
         * @en
         * Gets or sets linear damping.
         * @zh
         * 获取或设置线性阻尼。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * @en
         * Gets or sets the rotation damping.
         * @zh
         * 获取或设置旋转阻尼。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * @en
         * Gets or sets whether a rigid body is controlled by a physical system.
         * @zh
         * 获取或设置刚体是否由物理系统控制运动。
         */
        get isKinematic(): boolean;
        set isKinematic(value: boolean);
        /**
         * @en
         * Gets or sets whether a rigid body uses gravity.
         * @zh
         * 获取或设置刚体是否使用重力。
         */
        get useGravity(): boolean;
        set useGravity(value: boolean);
        /**
         * @en
         * Gets or sets whether the rigid body is fixed for rotation.
         * @zh
         * 获取或设置刚体是否固定旋转。
         */
        get fixedRotation(): boolean;
        set fixedRotation(value: boolean);
        /**
         * @en
         * Gets or sets the linear velocity factor that can be used to control the scaling of the velocity in each axis direction.
         * @zh
         * 获取或设置线性速度的因子，可以用来控制每个轴方向上的速度的缩放。
         */
        get linearFactor(): Vec3;
        set linearFactor(value: Vec3);
        /**
         * @en
         * Gets or sets the rotation speed factor that can be used to control the scaling of the rotation speed in each axis direction.
         * @zh
         * 获取或设置旋转速度的因子，可以用来控制每个轴方向上的旋转速度的缩放。
         */
        get angularFactor(): Vec3;
        set angularFactor(value: Vec3);
        /**
         * @en
         * Gets or sets the speed threshold for going to sleep.
         * @zh
         * 获取或设置进入休眠的速度临界值。
         */
        get sleepThreshold(): number;
        set sleepThreshold(v: number);
        /**
         * @en
         * Gets whether it is the state of awake.
         * @zh
         * 获取是否是唤醒的状态。
         */
        get isAwake(): boolean;
        /**
         * @en
         * Gets whether you can enter a dormant state.
         * @zh
         * 获取是否是可进入休眠的状态。
         */
        get isSleepy(): boolean;
        /**
         * @en
         * Gets whether the state is dormant.
         * @zh
         * 获取是否是正在休眠的状态。
         */
        get isSleeping(): boolean;
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get body(): IRigidBody | null;
        private _body;
        private _group;
        private _mass;
        private _allowSleep;
        private _linearDamping;
        private _angularDamping;
        private _fixedRotation;
        private _isKinematic;
        private _useGravity;
        private _linearFactor;
        private _angularFactor;
        protected get _assertOnLoadCalled(): boolean;
        protected get _assertUseCollisionMatrix(): boolean;
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected onDestroy(): void;
        /**
         * @en
         * Apply force to a world point. This could, for example, be a point on the Body surface.
         * @zh
         * 在世界空间中，相对于刚体的质心的某点上对刚体施加作用力。
         * @param force - 作用力
         * @param relativePoint - 作用点，相对于刚体的质心
         */
        applyForce(force: Vec3, relativePoint?: Vec3): void;
        /**
         * @en
         * Apply force to a local point. This could, for example, be a point on the Body surface.
         * @zh
         * 在本地空间中，相对于刚体的质心的某点上对刚体施加作用力。
         * @param force - 作用力
         * @param localPoint - 作用点
         */
        applyLocalForce(force: Vec3, localPoint?: Vec3): void;
        /**
         * @en
         * In world space, impulse is applied to the rigid body at some point relative to the center of mass of the rigid body.
         * @zh
         * 在世界空间中，相对于刚体的质心的某点上对刚体施加冲量。
         * @param impulse - 冲量
         * @param relativePoint - 作用点，相对于刚体的中心点
         */
        applyImpulse(impulse: Vec3, relativePoint?: Vec3): void;
        /**
         * @en
         * In local space, impulse is applied to the rigid body at some point relative to the center of mass of the rigid body.
         * @zh
         * 在本地空间中，相对于刚体的质心的某点上对刚体施加冲量。
         * @param impulse - 冲量
         * @param localPoint - 作用点
         */
        applyLocalImpulse(impulse: Vec3, localPoint?: Vec3): void;
        /**
         * @en
         * In world space, torque is applied to the rigid body.
         * @zh
         * 在世界空间中，对刚体施加扭矩。
         * @param torque - 扭矩
         */
        applyTorque(torque: Vec3): void;
        /**
         * @zh
         * 在本地空间中，对刚体施加扭矩。
         * @param torque - 扭矩
         */
        applyLocalTorque(torque: Vec3): void;
        /**
         * @en
         * Wake up the rigid body.
         * @zh
         * 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @en
         * Dormancy of rigid body.
         * @zh
         * 休眠刚体。
         */
        sleep(): void;
        /**
         * @en
         * Clear the forces and velocity of the rigid body.
         * @zh
         * 清除刚体受到的力和速度。
         */
        clearState(): void;
        /**
         * @en
         * Clear the forces of the rigid body.
         * @zh
         * 清除刚体受到的力。
         */
        clearForces(): void;
        /**
         * @en
         * Clear velocity of the rigid body.
         * @zh
         * 清除刚体的速度。
         */
        clearVelocity(): void;
        /**
         * @en
         * Gets the linear velocity.
         * @zh
         * 获取线性速度。
         * @param out 速度 Vec3
         */
        getLinearVelocity(out: Vec3): void;
        /**
         * @en
         * Sets the linear velocity.
         * @zh
         * 设置线性速度。
         * @param value 速度 Vec3
         */
        setLinearVelocity(value: Vec3): void;
        /**
         * @en
         * Gets the angular velocity.
         * @zh
         * 获取旋转速度。
         * @param out 速度 Vec3
         */
        getAngularVelocity(out: Vec3): void;
        /**
         * @en
         * Sets the angular velocity.
         * @zh
         * 设置旋转速度。
         * @param value 速度 Vec3
         */
        setAngularVelocity(value: Vec3): void;
        /**
         * @en
         * Gets the group value.
         * @zh
         * 获取分组值。
         * @returns 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        getGroup(): number;
        /**
         * @en
         * Sets the group value.
         * @zh
         * 设置分组值。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        setGroup(v: number): void;
        /**
         * @en
         * Add a grouping value to fill in the group you want to join.
         * @zh
         * 添加分组值，可填要加入的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        addGroup(v: number): void;
        /**
         * @en
         * Subtract the grouping value to fill in the group to be removed.
         * @zh
         * 减去分组值，可填要移除的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        removeGroup(v: number): void;
        /**
         * @en
         * Gets the mask value.
         * @zh
         * 获取掩码值。
         * @returns 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        getMask(): number;
        /**
         * @en
         * Sets the mask value.
         * @zh
         * 设置掩码值。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        setMask(v: number): void;
        /**
         * @en
         * Add mask values to fill in groups that need to be checked.
         * @zh
         * 添加掩码值，可填入需要检查的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        addMask(v: number): void;
        /**
         * @en
         * Subtract the mask value to fill in the group that does not need to be checked.
         * @zh
         * 减去掩码值，可填入不需要检查的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        removeMask(v: number): void;
    }
    export namespace RigidBody {
        type ERigidBodyType = EnumAlias<typeof ERigidBodyType>;
    }
}
declare module "cocos/physics/spec/i-rigid-body" {
    /**
     * @hidden
     */
    import { ILifecycle } from "cocos/physics/spec/i-lifecycle";
    import { IGroupMask } from "cocos/physics/spec/i-group-mask";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { RigidBody } from "cocos/physics/framework/components/rigid-body";
    export interface IRigidBody extends ILifecycle, IGroupMask {
        readonly impl: any;
        readonly rigidBody: RigidBody;
        readonly isAwake: boolean;
        readonly isSleepy: boolean;
        readonly isSleeping: boolean;
        initialize(v: RigidBody): void;
        setMass: (v: number) => void;
        setLinearDamping: (v: number) => void;
        setAngularDamping: (v: number) => void;
        setIsKinematic: (v: boolean) => void;
        useGravity: (v: boolean) => void;
        fixRotation: (v: boolean) => void;
        setLinearFactor: (v: IVec3Like) => void;
        setAngularFactor: (v: IVec3Like) => void;
        setAllowSleep: (v: boolean) => void;
        wakeUp(): void;
        sleep(): void;
        clearState(): void;
        clearForces(): void;
        clearVelocity(): void;
        setSleepThreshold(v: number): void;
        getSleepThreshold(): number;
        getLinearVelocity(out: IVec3Like): void;
        setLinearVelocity(value: IVec3Like): void;
        getAngularVelocity(out: IVec3Like): void;
        setAngularVelocity(value: IVec3Like): void;
        applyForce(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyLocalForce(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyImpulse(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyLocalImpulse(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyTorque(torque: IVec3Like): void;
        applyLocalTorque(torque: IVec3Like): void;
    }
}
declare module "cocos/physics/spec/i-external" {
    export interface ITerrainAsset {
        _uuid: string;
        tileSize: number;
        getVertexCountI: () => number;
        getVertexCountJ: () => number;
        getHeight: (i: number, j: number) => number;
    }
}
declare module "cocos/physics/spec/i-physics-shape" {
    /**
     * @hidden
     */
    import { ILifecycle } from "cocos/physics/spec/i-lifecycle";
    import { IGroupMask } from "cocos/physics/spec/i-group-mask";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { Collider, RigidBody, PhysicMaterial, SimplexCollider } from "exports/physics-framework";
    import { Mesh } from "cocos/core/index";
    import { ITerrainAsset } from "cocos/physics/spec/i-external";
    import { aabb, sphere } from "cocos/core/geometry/index";
    export interface IBaseShape extends ILifecycle, IGroupMask {
        readonly impl: any;
        readonly collider: Collider;
        readonly attachedRigidBody: RigidBody | null;
        initialize(v: Collider): void;
        setMaterial: (v: PhysicMaterial | null) => void;
        setAsTrigger: (v: boolean) => void;
        setCenter: (v: IVec3Like) => void;
        getAABB: (v: aabb) => void;
        getBoundingSphere: (v: sphere) => void;
    }
    export interface IBoxShape extends IBaseShape {
        setSize: (v: IVec3Like) => void;
    }
    export interface ISphereShape extends IBaseShape {
        setRadius: (v: number) => void;
    }
    export interface ICapsuleShape extends IBaseShape {
        setRadius: (v: number) => void;
        setCylinderHeight: (v: number) => void;
        setDirection: (v: number) => void;
    }
    export interface ICylinderShape extends IBaseShape {
        setRadius: (v: number) => void;
        setHeight: (v: number) => void;
        setDirection: (v: number) => void;
    }
    export interface ISimplexShape extends IBaseShape {
        setShapeType: (v: SimplexCollider.ESimplexType) => void;
        setVertices: (v: IVec3Like[]) => void;
    }
    export interface IConeShape extends IBaseShape {
        setRadius: (v: number) => void;
        setHeight: (v: number) => void;
        setDirection: (v: number) => void;
    }
    export interface ITrimeshShape extends IBaseShape {
        setMesh: (v: Mesh | null) => void;
    }
    export interface ITerrainShape extends IBaseShape {
        setTerrain: (v: ITerrainAsset | null) => void;
    }
    export interface IConeShape extends IBaseShape {
        setRadius: (v: number) => void;
        setHeight: (v: number) => void;
        setDirection: (v: number) => void;
    }
    export interface IPlaneShape extends IBaseShape {
        setNormal: (v: IVec3Like) => void;
        setConstant: (v: number) => void;
    }
}
declare module "cocos/physics/spec/i-physics-constraint" {
    /**
     * @hidden
     */
    import { ILifecycle } from "cocos/physics/spec/i-lifecycle";
    import { Constraint, RigidBody } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/index";
    export interface IBaseConstraint extends ILifecycle {
        readonly impl: any;
        initialize(v: Constraint): void;
        setConnectedBody(v: RigidBody | null): void;
        setEnableCollision(v: boolean): void;
    }
    export interface IPointToPointConstraint extends IBaseConstraint {
        setPivotA(v: IVec3Like): void;
        setPivotB(v: IVec3Like): void;
    }
    export interface IHingeConstraint extends IBaseConstraint {
    }
    export interface IConeTwistConstraint extends IBaseConstraint {
    }
}
declare module "cocos/physics/framework/instance" {
    import { IRigidBody } from "cocos/physics/spec/i-rigid-body";
    import { IBaseShape } from "cocos/physics/spec/i-physics-shape";
    import { IPhysicsWorld } from "cocos/physics/spec/i-physics-world";
    import { EColliderType, EConstraintType } from "cocos/physics/framework/physics-enum";
    import { IBaseConstraint } from "cocos/physics/spec/i-physics-constraint";
    export function checkPhysicsModule(obj: any): boolean;
    export function createPhysicsWorld(): IPhysicsWorld;
    export function createRigidBody(): IRigidBody;
    export function createShape(type: EColliderType): IBaseShape;
    export function createConstraint(type: EConstraintType): IBaseConstraint;
}
declare module "cocos/physics/framework/assets/physic-material" {
    /**
     * @category physics
     */
    import { Asset } from "cocos/core/assets/asset";
    /**
     * @en
     * Physics materials.
     * @zh
     * 物理材质。
     */
    export class PhysicMaterial extends Asset {
        /**
         * @en
         * Gets all physics material instances.
         * @zh
         * 获取所有的物理材质实例。
         */
        static allMaterials: PhysicMaterial[];
        /**
         * @en
         * Friction for this material.
         * @zh
         * 此材质的摩擦系数。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * @en
         * Rolling friction for this material.
         * @zh
         * 此材质的滚动摩擦系数。
         */
        get rollingFriction(): number;
        set rollingFriction(value: number);
        /**
         * @en
         * Spinning friction for this material.
         * @zh
         * 此材质的自旋摩擦系数。
         */
        get spinningFriction(): number;
        set spinningFriction(value: number);
        /**
         * @en
         * Restitution for this material.
         * @zh
         * 此材质的回弹系数。
         */
        get restitution(): number;
        set restitution(value: number);
        private static _idCounter;
        private _friction;
        private _rollingFriction;
        private _spinningFriction;
        private _restitution;
        constructor();
        /**
         * @en
         * clone.
         * @zh
         * 克隆。
         */
        clone(): PhysicMaterial;
        /**
         * @en
         * destroy.
         * @zh
         * 销毁。
         * @return 是否成功
         */
        destroy(): boolean;
    }
}
declare module "cocos/physics/framework/physics-system" {
    /**
     * @category physics
     */
    import { Vec3 } from "cocos/core/math/index";
    import { IPhysicsWorld } from "cocos/physics/spec/i-physics-world";
    import { System } from "cocos/core/components/index";
    import { PhysicMaterial } from "cocos/physics/framework/assets/physic-material";
    import { ray } from "cocos/core/geometry/index";
    import { PhysicsRayResult } from "cocos/physics/framework/physics-ray-result";
    import { ICollisionMatrix } from "cocos/physics/framework/physics-config";
    enum PhysicsGroup {
        DEFAULT = 1
    }
    /**
     * @en
     * Physics system.
     * @zh
     * 物理系统。
     */
    export class PhysicsSystem extends System {
        static get PHYSICS_NONE(): boolean;
        static get PHYSICS_BUILTIN(): boolean;
        static get PHYSICS_CANNON(): boolean;
        static get PHYSICS_AMMO(): boolean;
        /**
         * @en
         * Gets the ID of the system.
         * @zh
         * 获取此系统的ID。
         */
        static readonly ID = "PHYSICS";
        /**
         * @en
         * Gets the predefined physics groups.
         * @zh
         * 获取预定义的物理分组。
         */
        static get PhysicsGroup(): typeof PhysicsGroup;
        /**
         * @en
         * Gets the physical system instance.
         * @zh
         * 获取物理系统实例。
         */
        static get instance(): PhysicsSystem;
        private static readonly _instance;
        /**
         * @en
         * Gets or sets whether the physical system is enabled, which can be used to pause or continue running the physical system.
         * @zh
         * 获取或设置是否启用物理系统，可以用于暂停或继续运行物理系统。
         */
        get enable(): boolean;
        set enable(value: boolean);
        /**
         * @zh
         * Gets or sets whether the physical system allows automatic sleep, which defaults to true.
         * @zh
         * 获取或设置物理系统是否允许自动休眠，默认为 true。
         */
        get allowSleep(): boolean;
        set allowSleep(v: boolean);
        /**
         * @en
         * Gets or sets the maximum number of simulated substeps per frame.
         * @zh
         * 获取或设置每帧模拟的最大子步数。
         */
        get maxSubSteps(): number;
        set maxSubSteps(value: number);
        /**
         * @en
         * Gets or sets the fixed delta time consumed by each simulation step.
         * @zh
         * 获取或设置每步模拟消耗的固定时间。
         */
        get fixedTimeStep(): number;
        set fixedTimeStep(value: number);
        /**
         * @en
         * Gets or sets the value of gravity in the physical world, which defaults to (0, -10, 0).
         * @zh
         * 获取或设置物理世界的重力数值，默认为 (0, -10, 0)。
         */
        get gravity(): Vec3;
        set gravity(gravity: Vec3);
        /**
         * @en
         * Gets or sets the default speed threshold for going to sleep.
         * @zh
         * 获取或设置进入休眠的默认速度临界值。
         */
        get sleepThreshold(): number;
        set sleepThreshold(v: number);
        /**
         * @en
         * Turn on or off the automatic simulation.
         * @zh
         * 获取或设置是否自动模拟。
         */
        get autoSimulation(): boolean;
        set autoSimulation(value: boolean);
        /**
         * @en
         * Gets the global default physical material.
         * @zh
         * 获取全局的默认物理材质。
         */
        get defaultMaterial(): PhysicMaterial;
        /**
         * @en
         * Gets the wrappered object of the physical world through which you can access the actual underlying object.
         * @zh
         * 获取物理世界的封装对象，通过它你可以访问到实际的底层对象。
         */
        readonly physicsWorld: IPhysicsWorld;
        /**
         * @en
         * Gets the raycastClosest test result.
         * @zh
         * 获取 raycastClosest 的检测结果。
         */
        readonly raycastClosestResult: PhysicsRayResult;
        /**
         * @en
         * Gets the raycast test results.
         * @zh
         * 获取 raycast 的检测结果。
         */
        readonly raycastResults: PhysicsRayResult[];
        /**
         * @en
         * Gets the collision matrix。
         * @zh
         * 获取碰撞矩阵。
         */
        readonly collisionMatrix: ICollisionMatrix;
        /**
         * @en
         * Gets or sets whether to use a collision matrix.
         * @zh
         * 获取或设置是否开启碰撞矩阵。
         */
        readonly useCollisionMatrix: boolean;
        readonly useNodeChains: boolean;
        private _enable;
        private _allowSleep;
        private _maxSubSteps;
        private _subStepCount;
        private _fixedTimeStep;
        private _autoSimulation;
        private _accumulator;
        private _sleepThreshold;
        private readonly _gravity;
        private readonly _material;
        private readonly raycastOptions;
        private readonly raycastResultPool;
        private constructor();
        /**
         * @en
         * The lifecycle function is automatically executed after all components `update` and `lateUpadte` are executed.
         * @zh
         * 生命周期函数，在所有组件的`update`和`lateUpadte`执行完成后自动执行。
         * @param deltaTime the time since last frame.
         */
        postUpdate(deltaTime: number): void;
        /**
         * @en
         * Reset the accumulator of time to given value.
         * @zh
         * 重置时间累积总量为给定值。
         */
        resetAccumulator(time?: number): void;
        /**
         * @en
         * Perform simulation steps for the physics world.
         * @zh
         * 执行物理世界的模拟步进。
         * @param fixedTimeStep
         */
        step(fixedTimeStep: number, deltaTime?: number, maxSubSteps?: number): void;
        /**
         * @en
         * Sync the scene world transform changes to the physics world.
         * @zh
         * 同步场景世界的变化信息到物理世界中。
         */
        syncSceneToPhysics(): void;
        /**
         * @en
         * Emit trigger and collision events.
         * @zh
         * 触发`trigger`和`collision`事件。
         */
        emitEvents(): void;
        /**
         * @en
         * Updates the mask corresponding to the collision matrix for the lowLevel rigid-body instance.
         * Automatic execution during automatic simulation.
         * @zh
         * 更新底层实例对应于碰撞矩阵的掩码，开启自动模拟时会自动更新。
         */
        updateCollisionMatrix(): void;
        /**
         * @en
         * Reset the mask corresponding to all groups of the collision matrix to the given value, the default given value is' 0xffffffff '.
         * @zh
         * 重置碰撞矩阵所有分组对应掩码为给定值，默认给定值为`0xffffffff`。
         */
        resetCollisionMatrix(mask?: number): void;
        /**
         * @en
         * Are collisions between `group1` and `group2`?
         * @zh
         * 两分组是否会产生碰撞？
         */
        isCollisionGroup(group1: number, group2: number): number | false;
        /**
         * @en
         * Sets whether collisions occur between `group1` and `group2`.
         * @zh
         * 设置两分组间是否产生碰撞。
         * @param collision is collision occurs?
         */
        setCollisionGroup(group1: number, group2: number, collision?: boolean): void;
        /**
         * @en
         * Collision detect all collider, and record all the detected results, through PhysicsSystem.Instance.RaycastResults access to the results.
         * @zh
         * 检测所有的碰撞盒，并记录所有被检测到的结果，通过 PhysicsSystem.instance.raycastResults 访问结果。
         * @param worldRay 世界空间下的一条射线
         * @param mask 掩码，默认为 0xffffffff
         * @param maxDistance 最大检测距离，默认为 10000000，目前请勿传入 Infinity 或 Number.MAX_VALUE
         * @param queryTrigger 是否检测触发器
         * @return boolean 表示是否有检测到碰撞盒
         */
        raycast(worldRay: ray, mask?: number, maxDistance?: number, queryTrigger?: boolean): boolean;
        /**
         * @en
         * Collision detect all collider, and record and ray test results with the shortest distance by PhysicsSystem.Instance.RaycastClosestResult access to the results.
         * @zh
         * 检测所有的碰撞盒，并记录与射线距离最短的检测结果，通过 PhysicsSystem.instance.raycastClosestResult 访问结果。
         * @param worldRay 世界空间下的一条射线
         * @param mask 掩码，默认为 0xffffffff
         * @param maxDistance 最大检测距离，默认为 10000000，目前请勿传入 Infinity 或 Number.MAX_VALUE
         * @param queryTrigger 是否检测触发器
         * @return boolean 表示是否有检测到碰撞盒
         */
        raycastClosest(worldRay: ray, mask?: number, maxDistance?: number, queryTrigger?: boolean): boolean;
        private _updateMaterial;
    }
}
declare module "cocos/physics/framework/physics-interface" {
    /**
     * @category physics
     */
    import { IVec3Like } from "cocos/core/math/index";
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    /**
     * @en
     * The definition of the triggering event.
     * @zh
     * 触发事件。
     */
    export interface ITriggerEvent {
        /**
         * @en
         * The type of trigger event.
         * @zh
         * 触发的事件类型。
         */
        readonly type: TriggerEventType;
        /**
         * @en
         * The collider component instance of the event owner.
         * @zh
         * 触发事件中的自己的碰撞器
         */
        readonly selfCollider: Collider;
        /**
         * @en
         * Trigger another collider in event.
         * @zh
         * 触发事件中的另一个碰撞器
         */
        readonly otherCollider: Collider;
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
    }
    /**
     * @en
     * The value type definition of the trigger event.
     * @zh
     * 触发事件的值类型定义。
     */
    export type TriggerEventType = 'onTriggerEnter' | 'onTriggerStay' | 'onTriggerExit';
    /**
     * @en
     * Signature definition of the callback function that triggers the event.
     * @zh
     * 触发事件的回调函数签名定义。
     */
    export type TriggerCallback = (event?: ITriggerEvent) => void;
    /**
     * @en
     * Collision information for collision events.
     * @zh
     * 碰撞事件的碰撞信息。
     */
    export interface IContactEquation {
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
        /**
         * @en
         * Gets whether the rigid body bound to the selfCollider is A.
         * @zh
         * 获取`selfCollider`所绑定的刚体是否为 A 。
         */
        readonly isBodyA: boolean;
        /**
         * @en
         * Gets the contact point relative to the rigid body A in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 A 的碰撞点。
         * @param out used to storage the output.
         */
        getLocalPointOnA(out: IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body B in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 B 的碰撞点。
         * @param out used to storage the output.
         */
        getLocalPointOnB(out: IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body A in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 A 的碰撞点。
         * @param out used to storage the output.
         */
        getWorldPointOnA(out: IVec3Like): void;
        /**
         * @en
         * Gets the contact point relative to the rigid body B in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 B 的碰撞点。
         * @param out used to storage the output.
         */
        getWorldPointOnB(out: IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body B in the local coordinate system.
         * @zh
         * 获取本地坐标系中相对于刚体 B 的碰撞法线。
         * @param out used to storage the output.
         */
        getLocalNormalOnB(out: IVec3Like): void;
        /**
         * @en
         * Gets the contact normal relative to the rigid body B in the world coordinate system.
         * @zh
         * 获取世界坐标系中相对于刚体 B 的碰撞法线。
         * @param out used to storage the output.
         */
        getWorldNormalOnB(out: IVec3Like): void;
    }
    /**
     * @en
     * The definition of the collision event.
     * @zh
     * 碰撞事件。
     */
    export interface ICollisionEvent {
        /**
         * @en
         * The type of collision event.
         * @zh
         * 碰撞的事件类型。
         */
        readonly type: CollisionEventType;
        /**
         * @en
         * The collider component instance of the event owner.
         * @zh
         * 碰撞中的自己的碰撞器。
         */
        readonly selfCollider: Collider;
        /**
         * @en
         * Another collider in collision.
         * @zh
         * 碰撞中的另一个碰撞器。
         */
        readonly otherCollider: Collider;
        /**
         * @en
         * Information about all points of impact in a collision event.
         * @zh
         * 碰撞中的所有碰撞点的信息。
         */
        readonly contacts: IContactEquation[];
        /**
         * @en
         * Gets the lowLevel object, through which all the exposed properties can be accessed.
         * @zh
         * 获取实现对象，通过它可以访问到底层暴露的所有属性。
         */
        readonly impl: any;
    }
    /**
     * @en
     * Value type definitions for collision events.
     * @zh
     * 碰撞事件的值类型定义。
     */
    export type CollisionEventType = 'onCollisionEnter' | 'onCollisionStay' | 'onCollisionExit';
    /**
     * @en
     * Callback function signature definition for collision events.
     * @zh
     * 碰撞事件的回调函数签名定义。
     */
    export type CollisionCallback = (event?: ICollisionEvent) => void;
}
declare module "cocos/physics/framework/components/colliders/collider" {
    import { Vec3 } from "cocos/core/math/index";
    import { CollisionEventType, TriggerEventType } from "cocos/physics/framework/physics-interface";
    import { RigidBody } from "cocos/physics/framework/components/rigid-body";
    import { PhysicMaterial } from "cocos/physics/framework/assets/physic-material";
    import { Component } from "cocos/core/index";
    import { IBaseShape } from "cocos/physics/spec/i-physics-shape";
    import { aabb, sphere } from "cocos/core/geometry/index";
    import { EColliderType, EAxisDirection } from "cocos/physics/framework/physics-enum";
    const Collider_base: new (...args: any[]) => Component & import("cocos/core/event/eventify").IEventified;
    /**
     * @en
     * Base class of collider.
     * @zh
     * 碰撞器的基类。
     */
    export class Collider extends Collider_base {
        static readonly EColliderType: typeof EColliderType;
        static readonly EAxisDirection: typeof EAxisDirection;
        /**
         * @en
         * Gets the collider attached rigid-body, this may be null.
         * @zh
         * 获取碰撞器所绑定的刚体组件，可能为 null 。
         */
        get attachedRigidBody(): RigidBody | null;
        /**
         * @en
         * Gets or sets the physical material for this collider.
         * @zh
         * 获取或设置此碰撞器的物理材质。
         */
        get sharedMaterial(): PhysicMaterial | null;
        set sharedMaterial(value: PhysicMaterial | null);
        /**
         * @en
         * Gets or sets the physics material for this collider, which in Shared state will generate a new instance.
         * @zh
         * 获取或设置此碰撞器的物理材质，共享状态下获取将会生成新的实例。
         */
        get material(): PhysicMaterial | null;
        set material(value: PhysicMaterial | null);
        /**
         * @en
         * Gets or sets the collider is trigger, this will be always trigger if using builtin.
         * @zh
         * 获取或设置碰撞器是否为触发器，若使用 builtin ，属性值无论真假 ，此碰撞器都为触发器。
         */
        get isTrigger(): boolean;
        set isTrigger(value: boolean);
        /**
         * @en
         * Gets or sets the center of the collider, in local space.
         * @zh
         * 获取或设置碰撞器的中心点。
         */
        get center(): Vec3;
        set center(value: Vec3);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): IBaseShape | null;
        get worldBounds(): Readonly<aabb>;
        get boundingSphere(): Readonly<sphere>;
        get needTriggerEvent(): boolean;
        get needCollisionEvent(): boolean;
        readonly TYPE: EColliderType;
        protected _shape: IBaseShape | null;
        protected _aabb: aabb | null;
        protected _boundingSphere: sphere | null;
        protected _isSharedMaterial: boolean;
        protected _needTriggerEvent: boolean;
        protected _needCollisionEvent: boolean;
        protected _material: PhysicMaterial | null;
        protected _isTrigger: boolean;
        protected readonly _center: Vec3;
        protected get _assertOnLoadCalled(): boolean;
        protected get _assertUseCollisionMatrix(): boolean;
        constructor(type: EColliderType);
        /**
         * @en
         * Registers callbacks associated with triggered or collision events.
         * @zh
         * 注册触发或碰撞事件相关的回调。
         * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
         * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
         * @param target - The event callback target.
         */
        on(type: TriggerEventType | CollisionEventType, callback: Function, target?: Object, once?: boolean): any;
        /**
         * @en
         * Unregisters callbacks associated with trigger or collision events that have been registered.
         * @zh
         * 取消已经注册的触发或碰撞事件相关的回调。
         * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
         * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
         * @param target - The event callback target.
         */
        off(type: TriggerEventType | CollisionEventType, callback?: Function, target?: Object): void;
        /**
         * @en
         * Registers a callback associated with a trigger or collision event, which is automatically unregistered once executed.
         * @zh
         * 注册触发或碰撞事件相关的回调，执行一次后会自动取消注册。
         * @param type - The event type, onTriggerEnter|onTriggerStay|onTriggerExit|onCollisionEnter|onCollisionStay|onCollisionExit;
         * @param callback - The event callback, signature:`(event?:ICollisionEvent|ITriggerEvent)=>void`.
         * @param target - The event callback target.
         */
        once(type: TriggerEventType | CollisionEventType, callback: Function, target?: Object): any;
        /**
         * @en
         * Removes all registered events of the specified target or type.
         * @zh
         * 移除所有指定目标或类型的注册事件。
         * @param typeOrTarget - The event type or target.
         */
        removeAll(typeOrTarget: TriggerEventType | CollisionEventType | {}): void;
        /**
         * @en
         * Gets the group value.
         * @zh
         * 获取分组值。
         * @returns 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        getGroup(): number;
        /**
         * @en
         * Sets the group value.
         * @zh
         * 设置分组值。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        setGroup(v: number): void;
        /**
         * @en
         * Add a grouping value to fill in the group you want to join.
         * @zh
         * 添加分组值，可填要加入的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        addGroup(v: number): void;
        /**
         * @en
         * Subtract the grouping value to fill in the group to be removed.
         * @zh
         * 减去分组值，可填要移除的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        removeGroup(v: number): void;
        /**
         * @en
         * Gets the mask value.
         * @zh
         * 获取掩码值。
         * @returns 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        getMask(): number;
        /**
         * @en
         * Sets the mask value.
         * @zh
         * 设置掩码值。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        setMask(v: number): void;
        /**
         * @en
         * Add mask values to fill in groups that need to be checked.
         * @zh
         * 添加掩码值，可填入需要检查的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        addMask(v: number): void;
        /**
         * @en
         * Subtract the mask value to fill in the group that does not need to be checked.
         * @zh
         * 减去掩码值，可填入不需要检查的 group。
         * @param v - 整数，范围为 2 的 0 次方 到 2 的 31 次方
         */
        removeMask(v: number): void;
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected onDestroy(): void;
        private _updateMaterial;
        private _updateNeedEvent;
        private _updateMask;
    }
    export namespace Collider {
        type EColliderType = EnumAlias<typeof EColliderType>;
        type EAxisDirection = EnumAlias<typeof EAxisDirection>;
    }
}
declare module "cocos/physics/framework/components/colliders/box-collider" {
    import { Vec3 } from "cocos/core/math/index";
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { IBoxShape } from "cocos/physics/spec/i-physics-shape";
    /**
     * @en
     * Box collider component.
     * @zh
     * 盒子碰撞器。
     */
    export class BoxCollider extends Collider {
        /**
         * @en
         * Gets or sets the size of the box, in local space.
         * @zh
         * 获取或设置盒的大小。
         */
        get size(): Vec3;
        set size(value: Vec3);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): IBoxShape;
        private _size;
        constructor();
    }
}
declare module "cocos/physics/framework/components/colliders/sphere-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { ISphereShape } from "cocos/physics/spec/i-physics-shape";
    /**
     * @en
     * Sphere collider component.
     * @zh
     * 球碰撞器。
     */
    export class SphereCollider extends Collider {
        /**
         * @en
         * Gets or sets the radius of the sphere.
         * @zh
         * 获取或设置球的半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): ISphereShape;
        private _radius;
        constructor();
    }
}
declare module "cocos/physics/framework/components/colliders/capsule-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { ICapsuleShape } from "cocos/physics/spec/i-physics-shape";
    import { EAxisDirection } from "cocos/physics/framework/physics-enum";
    /**
     * @en
     * Capsule collider component.
     * @zh
     * 胶囊体碰撞器。
     */
    export class CapsuleCollider extends Collider {
        /**
         * @en
         * Gets or sets the radius of the sphere on the capsule body, in local space.
         * @zh
         * 获取或设置胶囊体在本地坐标系下的球半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en
         * Gets or sets the cylinder on the capsule body is at the corresponding axial height, in local space.
         * @zh
         * 获取或设置在本地坐标系下的胶囊体上圆柱体的高度。
         */
        get cylinderHeight(): number;
        set cylinderHeight(value: number);
        /**
         * @en
         * Gets or sets the capsule direction, in local space.
         * @zh
         * 获取或设置在本地坐标系下胶囊体的方向。
         */
        get direction(): EAxisDirection;
        set direction(value: EAxisDirection);
        /**
         * @en
         * Gets or sets the capsule height, in local space, with the minimum value being the diameter of the sphere.
         * @zh
         * 获取或设置在本地坐标系下胶囊体的高度，最小值为球的直径。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en
         * Gets the capsule body is at the corresponding axial height, in world space.
         * @zh
         * 获取胶囊体在世界坐标系下相应胶囊体朝向上的高度，只读属性。
         */
        get worldHeight(): number;
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): ICapsuleShape;
        private _radius;
        private _cylinderHeight;
        private _direction;
        constructor();
        private _getRadiusScale;
        private _getHeightScale;
    }
}
declare module "cocos/physics/framework/components/colliders/cylinder-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { ICylinderShape } from "cocos/physics/spec/i-physics-shape";
    import { EAxisDirection } from "cocos/physics/framework/physics-enum";
    /**
     * @en
     * Cylinder collider component.
     * @zh
     * 圆柱体碰撞器。
     */
    export class CylinderCollider extends Collider {
        /**
         * @en
         * Gets or sets the radius of the circle on the cylinder body, in local space.
         * @zh
         * 获取或设置圆柱体上圆面半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en
         * Gets or sets the cylinder body is at the corresponding axial height, in local space.
         * @zh
         * 获取或设置圆柱体在相应轴向的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en
         * Gets or sets the cylinder direction, in local space.
         * @zh
         * 获取或设置在圆柱体本地空间上的方向。
         */
        get direction(): EAxisDirection;
        set direction(value: EAxisDirection);
        get shape(): ICylinderShape;
        private _radius;
        private _height;
        private _direction;
        constructor();
    }
}
declare module "cocos/physics/framework/components/colliders/cone-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { IConeShape } from "cocos/physics/spec/i-physics-shape";
    import { EAxisDirection } from "cocos/physics/framework/physics-enum";
    /**
     * @en
     * Cone collider component.
     * @zh
     * 圆锥体碰撞器。
     */
    export class ConeCollider extends Collider {
        /**
         * @en
         * Gets or sets the radius of the circle on the cone body, in local space.
         * @zh
         * 获取或设置圆锥体上圆面半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * @en
         * Gets or sets the cone body is at the corresponding axial height, in local space.
         * @zh
         * 获取或设置圆锥体在相应轴向的高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * @en
         * Gets or sets the cone direction, in local space.
         * @zh
         * 获取或设置在圆锥体本地空间上的方向。
         */
        get direction(): EAxisDirection;
        set direction(value: EAxisDirection);
        get shape(): IConeShape;
        private _radius;
        private _height;
        private _direction;
        constructor();
    }
}
declare module "cocos/physics/framework/components/colliders/mesh-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { Mesh } from "cocos/core/index";
    import { ITrimeshShape } from "cocos/physics/spec/i-physics-shape";
    /**
     * @en
     * Triangle mesh collider component.
     * @zh
     * 三角网格碰撞器。
     */
    export class MeshCollider extends Collider {
        /**
         * @en
         * Gets or sets the mesh assets referenced by this collider.
         * @zh
         * 获取或设置此碰撞体引用的网格资源.
         */
        get mesh(): Mesh | null;
        set mesh(value: Mesh | null);
        /**
         * @en
         * Gets or sets whether the collider replaces the mesh with a convex shape.
         * @zh
         * 获取或设置此碰撞体是否用凸形状代替网格.
         */
        get convex(): boolean;
        set convex(value: boolean);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): ITrimeshShape;
        private _mesh;
        private _convex;
        constructor();
    }
}
declare module "cocos/physics/framework/components/constant-force" {
    import { Component } from "cocos/core/components/component";
    import { Vec3 } from "cocos/core/math/vec3";
    /**
     * @en
     * A tool component to help apply force to the rigid body at each frame.
     * @zh
     * 在每帧对一个刚体施加持续的力，依赖 RigidBody 组件。
     */
    export class ConstantForce extends Component {
        private _rigidBody;
        private readonly _force;
        private readonly _localForce;
        private readonly _torque;
        private readonly _localTorque;
        private _mask;
        /**
         * @en
         * Gets or sets forces in world coordinates.
         * @zh
         * 获取或设置世界坐标系下的力。
         */
        get force(): Vec3;
        set force(value: Vec3);
        /**
         * @en
         * Gets or sets the forces in the local coordinate system.
         * @zh
         * 获取或设置本地坐标系下的力。
         */
        get localForce(): Vec3;
        set localForce(value: Vec3);
        /**
         * @en
         * Gets or sets the torsional force in world coordinates.
         * @zh
         * 获取或设置世界坐标系下的扭转力。
         */
        get torque(): Vec3;
        set torque(value: Vec3);
        /**
         * @en
         * Gets or sets the torsional force in the local coordinate system.
         * @zh
         * 获取或设置本地坐标系下的扭转力。
         */
        get localTorque(): Vec3;
        set localTorque(value: Vec3);
        onLoad(): void;
        lateUpdate(dt: number): void;
        private _maskUpdate;
    }
}
declare module "cocos/terrain/terrain-asset" {
    /**
     * @category terrain
     */
    import { Asset } from "cocos/core/assets/index";
    export const TERRAIN_MAX_LEVELS = 4;
    export const TERRAIN_MAX_BLEND_LAYERS = 4;
    export const TERRAIN_MAX_LAYER_COUNT = 256;
    export const TERRAIN_BLOCK_TILE_COMPLEXITY = 32;
    export const TERRAIN_BLOCK_VERTEX_COMPLEXITY = 33;
    export const TERRAIN_BLOCK_VERTEX_SIZE = 8;
    export const TERRAIN_HEIGHT_BASE = 32768;
    export const TERRAIN_HEIGHT_FACTORY: number;
    export const TERRAIN_HEIGHT_FMIN: number;
    export const TERRAIN_HEIGHT_FMAX: number;
    export const TERRAIN_NORTH_INDEX = 0;
    export const TERRAIN_SOUTH_INDEX = 1;
    export const TERRAIN_WEST_INDEX = 2;
    export const TERRAIN_EAST_INDEX = 3;
    export const TERRAIN_DATA_VERSION = 16842753;
    export const TERRAIN_DATA_VERSION2 = 16842754;
    export const TERRAIN_DATA_VERSION3 = 16842755;
    export const TERRAIN_DATA_VERSION_DEFAULT = 16843025;
    /**
     * @en terrain layer info
     * @zh 地形纹理信息
     */
    export class TerrainLayerInfo {
        slot: number;
        tileSize: number;
        detailMap: string;
    }
    /**
     * @en terrain asset
     * @zh 地形资源
     */
    export class TerrainAsset extends Asset {
        protected _data: Uint8Array | null;
        protected _tileSize: number;
        protected _blockCount: number[];
        protected _weightMapSize: number;
        protected _lightMapSize: number;
        protected _heights: Uint16Array;
        protected _weights: Uint8Array;
        protected _layerBuffer: number[];
        protected _layerInfos: TerrainLayerInfo[];
        constructor();
        get _nativeAsset(): ArrayBuffer;
        set _nativeAsset(value: ArrayBuffer);
        /**
         * @en tile size
         * @zh 栅格大小
         */
        set tileSize(value: number);
        get tileSize(): number;
        /**
         * @en block count
         * @zh 块数量
         */
        set blockCount(value: number[]);
        get blockCount(): number[];
        /**
         * @en light map size
         * @zh 光照图大小
         */
        set lightMapSize(value: number);
        get lightMapSize(): number;
        /**
         * @en weight map size
         * @zh 权重图大小
         */
        set weightMapSize(value: number);
        get weightMapSize(): number;
        /**
         * @en height buffer
         * @zh 高度缓存
         */
        set heights(value: Uint16Array);
        get heights(): Uint16Array;
        /**
         * @en weight buffer
         * @zh 权重缓存
         */
        set weights(value: Uint8Array);
        get weights(): Uint8Array;
        /**
         * @en layer buffer
         * @zh 纹理索引缓存
         */
        set layerBuffer(value: number[]);
        get layerBuffer(): number[];
        /**
         * @en layer info
         * @zh 纹理信息
         */
        set layerInfos(value: TerrainLayerInfo[]);
        get layerInfos(): TerrainLayerInfo[];
        /**
         * @en get layer
         * @param xBlock block index x
         * @param yBlock block index y
         * @param layerId layer id
         * @zh 获得纹理索引
         * @param xBlock 地形块索引x
         * @param yBlock 地形块索引y
         * @param layerId 层Id
         */
        getLayer(xBlock: number, yBlock: number, layerId: number): number;
        getHeight(i: number, j: number): number;
        getVertexCountI(): number;
        getVertexCountJ(): number;
        _setNativeData(_nativeData: Uint8Array): void;
        _loadNativeData(_nativeData: Uint8Array): boolean;
        _exportNativeData(): Uint8Array;
        _exportDefaultNativeData(): Uint8Array;
    }
}
declare module "cocos/physics/framework/components/colliders/terrain-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { ITerrainShape } from "cocos/physics/spec/i-physics-shape";
    import { ITerrainAsset } from "cocos/physics/spec/i-external";
    /**
     * @en
     * Terrain collider component.
     * @zh
     * 地形碰撞器。
     */
    export class TerrainCollider extends Collider {
        /**
         * @en
         * Gets or sets the terrain assets referenced by this collider.
         * @zh
         * 获取或设置此碰撞体引用的网格资源.
         */
        get terrain(): ITerrainAsset | null;
        set terrain(value: ITerrainAsset | null);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): ITerrainShape;
        private _terrain;
        constructor();
    }
}
declare module "cocos/physics/framework/components/colliders/simplex-collider" {
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { ISimplexShape } from "cocos/physics/spec/i-physics-shape";
    import { ESimplexType } from "cocos/physics/framework/physics-enum";
    import { IVec3Like } from "cocos/core/math/type-define";
    /**
     * @en
     * Simplex collider, support point, line, triangle, tetrahedron.
     * @zh
     * 单纯形碰撞器，支持点、线、三角形、四面体。
     */
    export class SimplexCollider extends Collider {
        static readonly ESimplexType: typeof ESimplexType;
        get shapeType(): ESimplexType;
        set shapeType(v: ESimplexType);
        get vertex0(): IVec3Like;
        set vertex0(v: IVec3Like);
        get vertex1(): IVec3Like;
        set vertex1(v: IVec3Like);
        get vertex2(): IVec3Like;
        set vertex2(v: IVec3Like);
        get vertex3(): IVec3Like;
        set vertex3(v: IVec3Like);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): ISimplexShape;
        get vertices(): IVec3Like[];
        private _shapeType;
        private _vertices;
        constructor();
        updateVertices(): void;
    }
    export namespace SimplexCollider {
        type ESimplexType = EnumAlias<typeof ESimplexType>;
    }
}
declare module "cocos/physics/framework/components/colliders/plane-collider" {
    import { Vec3 } from "cocos/core/math/index";
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { IPlaneShape } from "cocos/physics/spec/i-physics-shape";
    /**
     * @en
     * Plane collider component.
     * @zh
     * 静态平面碰撞器。
     */
    export class PlaneCollider extends Collider {
        /**
         * @en
         * Gets or sets the normal of the plane, in local space.
         * @zh
         * 获取或设置平面在本地坐标系下的法线。
         */
        get normal(): Vec3;
        set normal(value: Vec3);
        /**
         * @en
         * Gets or sets the value of the plane moving along the normal, in local space.
         * @zh
         * 获取或设置平面在本地坐标系下沿着法线移动的数值。
         */
        get constant(): number;
        set constant(v: number);
        /**
         * @en
         * Gets the wrapper object, through which the lowLevel instance can be accessed.
         * @zh
         * 获取封装对象，通过此对象可以访问到底层实例。
         */
        get shape(): IPlaneShape;
        private _normal;
        private _constant;
        constructor();
    }
}
declare module "cocos/physics/framework/components/constraints/constraint" {
    import { Component } from "cocos/core/index";
    import { RigidBody } from "cocos/physics/framework/components/rigid-body";
    import { IBaseConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { EConstraintType } from "cocos/physics/framework/physics-enum";
    const Constraint_base: new (...args: any[]) => Component & import("cocos/core/event/eventify").IEventified;
    export class Constraint extends Constraint_base {
        static readonly EConstraintType: typeof EConstraintType;
        get attachedBody(): RigidBody | null;
        get connectedBody(): RigidBody | null;
        set connectedBody(v: RigidBody | null);
        get enableCollision(): boolean;
        set enableCollision(v: boolean);
        readonly TYPE: EConstraintType;
        protected _enableCollision: boolean;
        protected _connectedBody: RigidBody | null;
        protected _constraint: IBaseConstraint | null;
        constructor(type: EConstraintType);
        protected onLoad(): void;
        protected onEnable(): void;
        protected onDisable(): void;
        protected onDestroy(): void;
    }
    export namespace Constraint {
        type EConstraintType = EnumAlias<typeof EConstraintType>;
    }
}
declare module "cocos/physics/framework/components/constraints/hinge-constraint" {
    import { Constraint } from "cocos/physics/framework/components/constraints/constraint";
    import { IVec3Like } from "cocos/core/index";
    export class HingeConstraint extends Constraint {
        axisA: IVec3Like;
        axisB: IVec3Like;
        pivotA: IVec3Like;
        pivotB: IVec3Like;
        constructor();
    }
}
declare module "cocos/physics/framework/components/constraints/point-to-point-constraint" {
    import { Constraint } from "cocos/physics/framework/components/constraints/constraint";
    import { IVec3Like } from "cocos/core/index";
    import { IPointToPointConstraint } from "cocos/physics/spec/i-physics-constraint";
    export class PointToPointConstraint extends Constraint {
        get pivotA(): IVec3Like;
        set pivotA(v: IVec3Like);
        get pivotB(): IVec3Like;
        set pivotB(v: IVec3Like);
        get constraint(): IPointToPointConstraint;
        private readonly _pivotA;
        private readonly _pivotB;
        constructor();
    }
}
declare module "cocos/physics/framework/deprecated" {
    import { BoxCollider } from "cocos/physics/framework/components/colliders/box-collider";
    import { SphereCollider } from "cocos/physics/framework/components/colliders/sphere-collider";
    import { CapsuleCollider } from "cocos/physics/framework/components/colliders/capsule-collider";
    import { CylinderCollider } from "cocos/physics/framework/components/colliders/cylinder-collider";
    import { MeshCollider } from "cocos/physics/framework/components/colliders/mesh-collider";
    import { RigidBody } from "cocos/physics/framework/components/rigid-body";
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    /**
     * Alias of [[RigidBody]]
     * @deprecated Since v1.2
     */
    export { RigidBody as RigidBodyComponent };
    /**
     * Alias of [[Collider]]
     * @deprecated Since v1.2
     */
    export { Collider as ColliderComponent };
    /**
     * Alias of [[BoxCollider]]
     * @deprecated Since v1.2
     */
    export { BoxCollider as BoxColliderComponent };
    /**
     * Alias of [[SphereCollider]]
     * @deprecated Since v1.2
     */
    export { SphereCollider as SphereColliderComponent };
    /**
     * Alias of [[CapsuleCollider]]
     * @deprecated Since v1.2
     */
    export { CapsuleCollider as CapsuleColliderComponent };
    /**
     * Alias of [[MeshCollider]]
     * @deprecated Since v1.2
     */
    export { MeshCollider as MeshColliderComponent };
    /**
     * Alias of [[CylinderCollider]]
     * @deprecated Since v1.2
     */
    export { CylinderCollider as CylinderColliderComponent };
}
declare module "cocos/physics/framework/index" {
    /**
     * @hidden
     */
    import { PhysicsSystem } from "cocos/physics/framework/physics-system";
    import { PhysicMaterial } from "cocos/physics/framework/assets/physic-material";
    import { PhysicsRayResult } from "cocos/physics/framework/physics-ray-result";
    import { BoxCollider } from "cocos/physics/framework/components/colliders/box-collider";
    import { Collider } from "cocos/physics/framework/components/colliders/collider";
    import { SphereCollider } from "cocos/physics/framework/components/colliders/sphere-collider";
    import { CapsuleCollider } from "cocos/physics/framework/components/colliders/capsule-collider";
    import { CylinderCollider } from "cocos/physics/framework/components/colliders/cylinder-collider";
    import { ConeCollider } from "cocos/physics/framework/components/colliders/cone-collider";
    import { MeshCollider } from "cocos/physics/framework/components/colliders/mesh-collider";
    import { RigidBody } from "cocos/physics/framework/components/rigid-body";
    import { ConstantForce } from "cocos/physics/framework/components/constant-force";
    import { TerrainCollider } from "cocos/physics/framework/components/colliders/terrain-collider";
    import { SimplexCollider } from "cocos/physics/framework/components/colliders/simplex-collider";
    import { PlaneCollider } from "cocos/physics/framework/components/colliders/plane-collider";
    import { Constraint } from "cocos/physics/framework/components/constraints/constraint";
    import { HingeConstraint } from "cocos/physics/framework/components/constraints/hinge-constraint";
    import { PointToPointConstraint } from "cocos/physics/framework/components/constraints/point-to-point-constraint";
    export { PhysicsSystem, PhysicsRayResult, Collider, BoxCollider, SphereCollider, CapsuleCollider, MeshCollider, CylinderCollider, ConeCollider, TerrainCollider, SimplexCollider, PlaneCollider, Constraint, HingeConstraint, PointToPointConstraint, RigidBody, PhysicMaterial, ConstantForce, };
    export * from "cocos/physics/framework/physics-interface";
    export { EAxisDirection, ERigidBodyType } from "cocos/physics/framework/physics-enum";
    export * from "cocos/physics/framework/deprecated";
}
declare module "exports/physics-framework" {
    /**
     * @hidden
     */
    export * from "cocos/physics/framework/index";
}
declare module "cocos/physics/ammo/ammo-enum" {
    export enum EAmmoSharedBodyDirty {
        BODY_RE_ADD = 1,
        GHOST_RE_ADD = 2
    }
    export enum AmmoCollisionFlags {
        CF_STATIC_OBJECT = 1,
        CF_KINEMATIC_OBJECT = 2,
        CF_NO_CONTACT_RESPONSE = 4,
        CF_CUSTOM_MATERIAL_CALLBACK = 8,
        CF_CHARACTER_OBJECT = 16,
        CF_DISABLE_VISUALIZE_OBJECT = 32,
        CF_DISABLE_SPU_COLLISION_PROCESSING = 64
    }
    export enum AmmoCollisionObjectTypes {
        CO_COLLISION_OBJECT = 1,
        CO_RIGID_BODY = 2,
        CO_GHOST_OBJECT = 4,
        CO_SOFT_BODY = 8,
        CO_HF_FLUID = 16,
        CO_USER_TYPE = 32,
        CO_FEATHERSTONE_LINK = 64
    }
    export enum AmmoCollisionObjectStates {
        ACTIVE_TAG = 1,
        ISLAND_SLEEPING = 2,
        WANTS_DEACTIVATION = 3,
        DISABLE_DEACTIVATION = 4,
        DISABLE_SIMULATION = 5
    }
    export enum AmmoAnisotropicFrictionFlags {
        CF_ANISOTROPIC_FRICTION_DISABLED = 0,
        CF_ANISOTROPIC_FRICTION = 1,
        CF_ANISOTROPIC_ROLLING_FRICTION = 2
    }
    export enum AmmoRigidBodyFlags {
        BT_DISABLE_WORLD_GRAVITY = 1,
        BT_ENABLE_GYROPSCOPIC_FORCE = 2
    }
    export enum AmmoBroadphaseNativeTypes {
        BOX_SHAPE_PROXYTYPE = 0,
        TRIANGLE_SHAPE_PROXYTYPE = 1,
        TETRAHEDRAL_SHAPE_PROXYTYPE = 2,
        CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE = 3,
        CONVEX_HULL_SHAPE_PROXYTYPE = 4,
        CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE = 5,
        CUSTOM_POLYHEDRAL_SHAPE_TYPE = 6,
        IMPLICIT_CONVEX_SHAPES_START_HERE = 7,
        SPHERE_SHAPE_PROXYTYPE = 8,
        MULTI_SPHERE_SHAPE_PROXYTYPE = 9,
        CAPSULE_SHAPE_PROXYTYPE = 10,
        CONE_SHAPE_PROXYTYPE = 11,
        CONVEX_SHAPE_PROXYTYPE = 12,
        CYLINDER_SHAPE_PROXYTYPE = 13,
        UNIFORM_SCALING_SHAPE_PROXYTYPE = 14,
        MINKOWSKI_SUM_SHAPE_PROXYTYPE = 15,
        MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE = 16,
        BOX_2D_SHAPE_PROXYTYPE = 17,
        CONVEX_2D_SHAPE_PROXYTYPE = 18,
        CUSTOM_CONVEX_SHAPE_TYPE = 19,
        CONCAVE_SHAPES_START_HERE = 20,
        TRIANGLE_MESH_SHAPE_PROXYTYPE = 21,
        SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE = 22,
        FAST_CONCAVE_MESH_PROXYTYPE = 23,
        TERRAIN_SHAPE_PROXYTYPE = 24,
        GIMPACT_SHAPE_PROXYTYPE = 25,
        MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE = 26,
        EMPTY_SHAPE_PROXYTYPE = 27,
        STATIC_PLANE_PROXYTYPE = 28,
        CUSTOM_CONCAVE_SHAPE_TYPE = 29,
        CONCAVE_SHAPES_END_HERE = 30,
        COMPOUND_SHAPE_PROXYTYPE = 31,
        SOFTBODY_SHAPE_PROXYTYPE = 32,
        HFFLUID_SHAPE_PROXYTYPE = 33,
        HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE = 34,
        INVALID_SHAPE_PROXYTYPE = 35,
        MAX_BROADPHASE_COLLISION_TYPES = 36
    }
    export enum AmmoCollisionFilterGroups {
        DefaultFilter = 1,
        StaticFilter = 2,
        KinematicFilter = 4,
        DebrisFilter = 8,
        SensorTrigger = 16,
        CharacterFilter = 32,
        AllFilter = -1
    }
    export enum AmmoDispatcherFlags {
        CD_STATIC_STATIC_REPORTED = 1,
        CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD = 2,
        CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION = 4
    }
}
declare module "cocos/physics/ammo/ammo-util" {
    import { IVec3Like, IQuatLike } from "cocos/core/math/type-define";
    import { Mesh } from "cocos/core/index";
    export function cocos2AmmoVec3(out: Ammo.btVector3, v: IVec3Like): Ammo.btVector3;
    export function ammo2CocosVec3<T extends IVec3Like>(out: T, v: Ammo.btVector3): T;
    export function cocos2AmmoQuat(out: Ammo.btQuaternion, q: IQuatLike): Ammo.btQuaternion;
    export function ammo2CocosQuat<T extends IQuatLike>(out: T, q: Ammo.btQuaternion): T;
    export function ammoDeletePtr(obj: Ammo.Type, klass: Constructor<Ammo.Type>): void;
    export function cocos2AmmoTriMesh(out: Ammo.btTriangleMesh, mesh: Mesh): Ammo.btTriangleMesh;
}
declare module "cocos/physics/ammo/ammo-const" {
    import { Collider, TriggerEventType, CollisionEventType, IContactEquation } from "exports/physics-framework";
    import { Vec3, Quat } from "cocos/core/index";
    export const TriggerEventObject: {
        type: TriggerEventType;
        selfCollider: Collider;
        otherCollider: Collider;
        impl: null;
    };
    export const CollisionEventObject: {
        type: CollisionEventType;
        selfCollider: Collider;
        otherCollider: Collider;
        contacts: IContactEquation[];
        impl: null;
    };
    export class AmmoConstant {
        private static _instance;
        static get instance(): AmmoConstant;
        readonly EMPTY_SHAPE: Ammo.btEmptyShape;
        readonly TRANSFORM: Ammo.btTransform;
        readonly VECTOR3_0: Ammo.btVector3;
        readonly VECTOR3_1: Ammo.btVector3;
        readonly QUAT_0: Ammo.btQuaternion;
    }
    export const CC_V3_0: Vec3;
    export const CC_V3_1: Vec3;
    export const CC_QUAT_0: Quat;
}
declare module "cocos/physics/ammo/shapes/ammo-shape" {
    import { Collider, PhysicMaterial } from "exports/physics-framework";
    import { AmmoBroadphaseNativeTypes } from "cocos/physics/ammo/ammo-enum";
    import { Node } from "cocos/core/index";
    import { IBaseShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { AmmoSharedBody } from "cocos/physics/ammo/ammo-shared-body";
    import { aabb, sphere } from "cocos/core/geometry/index";
    export class AmmoShape implements IBaseShape {
        setMaterial(v: PhysicMaterial | null): void;
        setCenter(v: IVec3Like): void;
        setAsTrigger(v: boolean): void;
        get attachedRigidBody(): import("exports/physics-framework").RigidBody | null;
        get impl(): Ammo.btCollisionShape;
        get collider(): Collider;
        get sharedBody(): AmmoSharedBody;
        get index(): number;
        private static idCounter;
        readonly id: number;
        readonly type: AmmoBroadphaseNativeTypes;
        protected _index: number;
        protected _isEnabled: boolean;
        protected _isBinding: boolean;
        protected _isTrigger: boolean;
        protected _sharedBody: AmmoSharedBody;
        protected _btShape: Ammo.btCollisionShape;
        protected _btCompound: Ammo.btCompoundShape | null;
        protected _collider: Collider;
        protected readonly transform: Ammo.btTransform;
        protected readonly pos: Ammo.btVector3;
        protected readonly quat: Ammo.btQuaternion;
        protected readonly scale: Ammo.btVector3;
        constructor(type: AmmoBroadphaseNativeTypes);
        getAABB(v: aabb): void;
        getBoundingSphere(v: sphere): void;
        initialize(com: Collider): void;
        protected onComponentSet(): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /** group mask */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
        setCompound(compound: Ammo.btCompoundShape | null): void;
        setWrapper(): void;
        setScale(): void;
        updateCompoundTransform(): void;
        needCompound(): boolean;
        /**DEBUG */
        private static _debugTransform;
        debugTransform(n: Node): void;
    }
}
declare module "cocos/physics/ammo/ammo-interface" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    export interface IAmmoBodyStruct {
        readonly id: number;
        readonly body: Ammo.btRigidBody;
        readonly shape: Ammo.btCollisionShape;
        readonly worldQuat: Ammo.btQuaternion;
        readonly localInertia: Ammo.btVector3;
        readonly rbInfo: Ammo.btRigidBodyConstructionInfo;
        readonly startTransform: Ammo.btTransform;
        readonly motionState: Ammo.btDefaultMotionState;
        readonly wrappedShapes: AmmoShape[];
        useCompound: boolean;
    }
    export interface IAmmoGhostStruct {
        readonly id: number;
        readonly ghost: Ammo.btCollisionObject;
        readonly shape: Ammo.btCollisionShape;
        readonly worldQuat: Ammo.btQuaternion;
        readonly wrappedShapes: AmmoShape[];
    }
}
declare module "cocos/physics/ammo/ammo-instance" {
    import { IAmmoBodyStruct, IAmmoGhostStruct } from "cocos/physics/ammo/ammo-interface";
    export class AmmoInstance {
        static readonly bodyAndGhosts: {
            [x: string]: IAmmoBodyStruct | IAmmoGhostStruct;
        };
        static get bodyStructs(): {
            [x: string]: IAmmoBodyStruct;
        };
        static get ghostStructs(): {
            [x: string]: IAmmoGhostStruct;
        };
    }
}
declare module "cocos/physics/ammo/ammo-shared-body" {
    import { Node } from "cocos/core/index";
    import { AmmoWorld } from "cocos/physics/ammo/ammo-world";
    import { AmmoRigidBody } from "cocos/physics/ammo/ammo-rigid-body";
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { EAmmoSharedBodyDirty } from "cocos/physics/ammo/ammo-enum";
    import { IAmmoBodyStruct, IAmmoGhostStruct } from "cocos/physics/ammo/ammo-interface";
    /**
     * shared object, node : shared = 1 : 1
     * body for static \ dynamic \ kinematic (collider)
     * ghost for trigger
     */
    export class AmmoSharedBody {
        private static idCounter;
        private static readonly sharedBodesMap;
        static getSharedBody(node: Node, wrappedWorld: AmmoWorld, wrappedBody?: AmmoRigidBody): AmmoSharedBody;
        get wrappedBody(): AmmoRigidBody | null;
        get bodyCompoundShape(): Ammo.btCompoundShape;
        get ghostCompoundShape(): Ammo.btCompoundShape;
        get body(): Ammo.btRigidBody;
        get ghost(): Ammo.btCollisionObject;
        get collisionFilterGroup(): number;
        set collisionFilterGroup(v: number);
        get collisionFilterMask(): number;
        set collisionFilterMask(v: number);
        get bodyStruct(): IAmmoBodyStruct;
        get ghostStruct(): IAmmoGhostStruct;
        readonly id: number;
        readonly node: Node;
        readonly wrappedWorld: AmmoWorld;
        dirty: EAmmoSharedBodyDirty;
        private _collisionFilterGroup;
        private _collisionFilterMask;
        private ref;
        private bodyIndex;
        private ghostIndex;
        private _bodyStruct;
        private _ghostStruct;
        private _wrappedBody;
        /**
         * add or remove from world \
         * add, if enable \
         * remove, if disable & shapes.length == 0 & wrappedBody disable
         */
        set bodyEnabled(v: boolean);
        set ghostEnabled(v: boolean);
        set reference(v: boolean);
        private constructor();
        private _instantiateBodyStruct;
        private _instantiateGhostStruct;
        addShape(v: AmmoShape, isTrigger: boolean): void;
        removeShape(v: AmmoShape, isTrigger: boolean): void;
        updateDirty(): void;
        syncSceneToPhysics(): void;
        /**
         * TODO: use motion state
         */
        syncPhysicsToScene(): void;
        syncSceneToGhost(): void;
        syncInitialBody(): void;
        syncInitialGhost(): void;
        /**
         * see: https://pybullet.org/Bullet/phpBB3/viewtopic.php?f=9&t=5312&p=19094&hilit=how+to+change+group+mask#p19097
         */
        updateBodyByReAdd(): void;
        updateGhostByReAdd(): void;
        private destroy;
        private isBodySleeping;
    }
}
declare module "cocos/physics/utils/array-collision-matrix" {
    /**
     * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
     * @class ArrayCollisionMatrix
     * @constructor
     */
    export class ArrayCollisionMatrix {
        /**
         * The matrix storage
         */
        matrix: number[];
        /**
         * Get an element
         * @method get
         * @param  {Number} i
         * @param  {Number} j
         * @return {Number}
         */
        get(i: number, j: number): number;
        /**
         * Set an element
         * @method set
         * @param {Number} i
         * @param {Number} j
         * @param {boolean} value
         */
        set(i: number, j: number, value: boolean): void;
        /**
         * Sets all elements to zero
         * @method reset
         */
        reset(): void;
        /**
         * Sets the max number of objects
         * @param {Number} n
         */
        setNumObjects(n: number): void;
    }
}
declare module "cocos/physics/utils/tuple-dictionary" {
    /**
     * @class TupleDictionary
     * @constructor
     */
    export class TupleDictionary {
        /**
         * The data storage
         */
        data: {
            keys: string[];
        };
        constructor();
        /**
         * @method get
         * @param  {number} i
         * @param  {number} j
         * @return {Object}
         */
        get<T>(i: number, j: number): T;
        /**
         * @method set
         * @param  {number} i
         * @param  {number} j
         * @param {Object} value
         */
        set<T>(i: number, j: number, value: T): T;
        /**
         * @method reset
         */
        reset(): void;
        /**
         * @method getLength
         */
        getLength(): number;
        /**
         * @method getKeyByIndex
         * @param {number} index
         */
        getKeyByIndex(index: number): string;
        /**
         * @method getDataByKey
         * @param {string} Key
         */
        getDataByKey<T>(Key: string): T;
    }
}
declare module "cocos/physics/ammo/ammo-contact-equation" {
    import { IContactEquation, ICollisionEvent } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/index";
    export class AmmoContactEquation implements IContactEquation {
        get isBodyA(): boolean;
        impl: Ammo.btManifoldPoint | null;
        event: ICollisionEvent;
        constructor(event: ICollisionEvent);
        getLocalPointOnA(out: IVec3Like): void;
        getLocalPointOnB(out: IVec3Like): void;
        getWorldPointOnA(out: IVec3Like): void;
        getWorldPointOnB(out: IVec3Like): void;
        getLocalNormalOnB(out: IVec3Like): void;
        getWorldNormalOnB(out: IVec3Like): void;
    }
}
declare module "cocos/physics/ammo/constraints/ammo-constraint" {
    import { IBaseConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { Constraint, RigidBody } from "cocos/physics/framework/index";
    export class AmmoConstraint implements IBaseConstraint {
        setConnectedBody(v: RigidBody | null): void;
        setEnableCollision(v: boolean): void;
        get impl(): Ammo.btTypedConstraint;
        get constraint(): Constraint;
        dirty: number;
        index: number;
        protected _impl: Ammo.btTypedConstraint;
        protected _com: Constraint;
        protected _rigidBody: RigidBody | null;
        protected _collided: boolean;
        updateByReAdd(): void;
        initialize(v: Constraint): void;
        protected onComponentSet(): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
    }
}
declare module "cocos/physics/ammo/ammo-world" {
    import { AmmoSharedBody } from "cocos/physics/ammo/ammo-shared-body";
    import { AmmoRigidBody } from "cocos/physics/ammo/ammo-rigid-body";
    import { ArrayCollisionMatrix } from "cocos/physics/utils/array-collision-matrix";
    import { TupleDictionary } from "cocos/physics/utils/tuple-dictionary";
    import { ray } from "cocos/core/geometry/index";
    import { IRaycastOptions, IPhysicsWorld } from "cocos/physics/spec/i-physics-world";
    import { PhysicsRayResult, PhysicMaterial } from "cocos/physics/framework/index";
    import { Node, RecyclePool } from "cocos/core/index";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { AmmoConstraint } from "cocos/physics/ammo/constraints/ammo-constraint";
    export class AmmoWorld implements IPhysicsWorld {
        setAllowSleep(v: boolean): void;
        setDefaultMaterial(v: PhysicMaterial): void;
        setGravity(gravity: IVec3Like): void;
        get impl(): Ammo.btDiscreteDynamicsWorld;
        private readonly _btWorld;
        private readonly _btBroadphase;
        private readonly _btSolver;
        private readonly _btDispatcher;
        private readonly _btGravity;
        readonly bodies: AmmoSharedBody[];
        readonly ghosts: AmmoSharedBody[];
        readonly constraints: AmmoConstraint[];
        readonly triggerArrayMat: ArrayCollisionMatrix;
        readonly collisionArrayMat: ArrayCollisionMatrix;
        readonly contactsDic: TupleDictionary;
        readonly oldContactsDic: TupleDictionary;
        readonly closeHitCB: Ammo.ClosestRayResultCallback;
        readonly allHitsCB: Ammo.AllHitsRayResultCallback;
        constructor(options?: any);
        step(deltaTime: number, timeSinceLastCalled?: number, maxSubStep?: number): void;
        syncSceneToPhysics(): void;
        raycast(worldRay: ray, options: IRaycastOptions, pool: RecyclePool<PhysicsRayResult>, results: PhysicsRayResult[]): boolean;
        /**
         * Ray cast, and return information of the closest hit.
         * @return True if any body was hit.
         */
        raycastClosest(worldRay: ray, options: IRaycastOptions, result: PhysicsRayResult): boolean;
        getSharedBody(node: Node, wrappedBody?: AmmoRigidBody): AmmoSharedBody;
        addSharedBody(sharedBody: AmmoSharedBody): void;
        removeSharedBody(sharedBody: AmmoSharedBody): void;
        addGhostObject(sharedBody: AmmoSharedBody): void;
        removeGhostObject(sharedBody: AmmoSharedBody): void;
        addConstraint(constraint: AmmoConstraint): void;
        removeConstraint(constraint: AmmoConstraint): void;
        updateCollisionMatrix(group: number, mask: number): void;
        emitEvents(): void;
    }
}
declare module "cocos/physics/ammo/ammo-rigid-body" {
    import { Vec3 } from "cocos/core/index";
    import { RigidBody } from "exports/physics-framework";
    import { IRigidBody } from "cocos/physics/spec/i-rigid-body";
    import { ERigidBodyType } from "cocos/physics/framework/physics-enum";
    import { AmmoSharedBody } from "cocos/physics/ammo/ammo-shared-body";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoRigidBody implements IRigidBody {
        get isAwake(): boolean;
        get isSleepy(): boolean;
        get isSleeping(): boolean;
        setMass(value: number): void;
        setLinearDamping(value: number): void;
        setAngularDamping(value: number): void;
        setIsKinematic(value: boolean): void;
        useGravity(value: boolean): void;
        fixRotation(value: boolean): void;
        setLinearFactor(value: IVec3Like): void;
        setAngularFactor(value: IVec3Like): void;
        setAllowSleep(v: boolean): void;
        get isEnabled(): boolean;
        get impl(): Ammo.btRigidBody;
        get rigidBody(): RigidBody;
        get sharedBody(): AmmoSharedBody;
        private static idCounter;
        readonly id: number;
        private _isEnabled;
        private _sharedBody;
        private _rigidBody;
        constructor();
        clearState(): void;
        clearVelocity(): void;
        clearForces(): void;
        /** LIFECYCLE */
        initialize(com: RigidBody): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /** INTERFACE */
        wakeUp(force?: boolean): void;
        sleep(): void;
        setSleepThreshold(v: number): void;
        getSleepThreshold(): number;
        /** type */
        getType(): ERigidBodyType;
        /** kinematic */
        getLinearVelocity(out: Vec3): Vec3;
        setLinearVelocity(value: Vec3): void;
        getAngularVelocity(out: Vec3): Vec3;
        setAngularVelocity(value: Vec3): void;
        /** dynamic */
        applyLocalForce(force: Vec3, rel_pos?: Vec3): void;
        applyLocalTorque(torque: Vec3): void;
        applyLocalImpulse(impulse: Vec3, rel_pos?: Vec3): void;
        applyForce(force: Vec3, rel_pos?: Vec3): void;
        applyTorque(torque: Vec3): void;
        applyImpulse(impulse: Vec3, rel_pos?: Vec3): void;
        /** group mask */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
        protected _wakeUpIfSleep(): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-box-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { BoxCollider } from "exports/physics-framework";
    import { IBoxShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoBoxShape extends AmmoShape implements IBoxShape {
        setSize(size: IVec3Like): void;
        get impl(): Ammo.btBoxShape;
        get collider(): BoxCollider;
        readonly halfExt: Ammo.btVector3;
        constructor();
        onComponentSet(): void;
        onDestroy(): void;
        setScale(): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-sphere-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { SphereCollider } from "exports/physics-framework";
    import { ISphereShape } from "cocos/physics/spec/i-physics-shape";
    export class AmmoSphereShape extends AmmoShape implements ISphereShape {
        setRadius(radius: number): void;
        get impl(): Ammo.btSphereShape;
        get collider(): SphereCollider;
        constructor();
        onComponentSet(): void;
        setScale(): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-capsule-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { CapsuleCollider } from "exports/physics-framework";
    import { ICapsuleShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoCapsuleShape extends AmmoShape implements ICapsuleShape {
        setCylinderHeight(v: number): void;
        setDirection(v: number): void;
        setRadius(v: number): void;
        get impl(): Ammo.btCapsuleShape;
        get collider(): CapsuleCollider;
        constructor();
        onLoad(): void;
        setScale(): void;
        updateProperties(radius: number, height: number, direction: number, scale: IVec3Like): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-trimesh-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { Mesh } from "cocos/core/index";
    import { MeshCollider } from "exports/physics-framework";
    import { ITrimeshShape } from "cocos/physics/spec/i-physics-shape";
    export class AmmoTrimeshShape extends AmmoShape implements ITrimeshShape {
        get collider(): MeshCollider;
        get impl(): Ammo.btConvexTriangleMeshShape | Ammo.btBvhTriangleMeshShape;
        setMesh(v: Mesh | null): void;
        private refBtTriangleMesh;
        constructor();
        onComponentSet(): void;
        onDestroy(): void;
        setCompound(compound: Ammo.btCompoundShape | null): void;
        setScale(): void;
        private _getBtTriangleMesh;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-cylinder-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { CylinderCollider } from "exports/physics-framework";
    import { ICylinderShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoCylinderShape extends AmmoShape implements ICylinderShape {
        setHeight(v: number): void;
        setDirection(v: number): void;
        setRadius(v: number): void;
        get impl(): Ammo.btCylinderShape;
        get collider(): CylinderCollider;
        readonly halfExtents: Ammo.btVector3;
        constructor();
        onLoad(): void;
        onDestroy(): void;
        setScale(): void;
        updateProperties(radius: number, height: number, direction: number, scale: IVec3Like): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-cone-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { ConeCollider } from "exports/physics-framework";
    import { ICylinderShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoConeShape extends AmmoShape implements ICylinderShape {
        setHeight(v: number): void;
        setDirection(v: number): void;
        setRadius(v: number): void;
        get impl(): Ammo.btConeShape;
        get collider(): ConeCollider;
        constructor();
        onLoad(): void;
        setScale(): void;
        updateProperties(radius: number, height: number, direction: number, scale: IVec3Like): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-terrain-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { TerrainCollider } from "exports/physics-framework";
    import { ITerrainShape } from "cocos/physics/spec/i-physics-shape";
    import { ITerrainAsset } from "cocos/physics/spec/i-external";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoTerrainShape extends AmmoShape implements ITerrainShape {
        get collider(): TerrainCollider;
        get impl(): Ammo.btHeightfieldTerrainShape;
        setTerrain(v: ITerrainAsset | null): void;
        private _terrainID;
        private _buffPtr;
        private _tileSize;
        private _localOffset;
        constructor();
        onComponentSet(): void;
        onDestroy(): void;
        setCompound(compound: Ammo.btCompoundShape | null): void;
        setCenter(v: IVec3Like): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-simplex-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { SimplexCollider } from "exports/physics-framework";
    import { ISimplexShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoSimplexShape extends AmmoShape implements ISimplexShape {
        setShapeType(v: SimplexCollider.ESimplexType): void;
        setVertices(v: IVec3Like[]): void;
        get impl(): Ammo.btBU_Simplex1to4;
        get collider(): SimplexCollider;
        readonly VERTICES: Ammo.btVector3[];
        constructor();
        protected onComponentSet(): void;
        onLoad(): void;
        onDestroy(): void;
        setScale(): void;
    }
}
declare module "cocos/physics/ammo/shapes/ammo-plane-shape" {
    import { AmmoShape } from "cocos/physics/ammo/shapes/ammo-shape";
    import { PlaneCollider } from "exports/physics-framework";
    import { IPlaneShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class AmmoPlaneShape extends AmmoShape implements IPlaneShape {
        setNormal(v: IVec3Like): void;
        setConstant(v: number): void;
        setScale(): void;
        get impl(): Ammo.btStaticPlaneShape;
        get collider(): PlaneCollider;
        readonly NORMAL: Ammo.btVector3;
        constructor();
        onComponentSet(): void;
        onDestroy(): void;
    }
}
declare module "cocos/physics/ammo/constraints/ammo-point-to-point-constraint" {
    import { AmmoConstraint } from "cocos/physics/ammo/constraints/ammo-constraint";
    import { IPointToPointConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { IVec3Like } from "cocos/core/index";
    import { PointToPointConstraint } from "cocos/physics/framework/index";
    export class AmmoPointToPointConstraint extends AmmoConstraint implements IPointToPointConstraint {
        setPivotA(v: IVec3Like): void;
        setPivotB(v: IVec3Like): void;
        get impl(): Ammo.btPoint2PointConstraint;
        get constraint(): PointToPointConstraint;
        private _pivotA;
        private _pivotB;
        onComponentSet(): void;
    }
}
declare module "cocos/physics/ammo/constraints/ammo-hinge-constraint" {
    import { AmmoConstraint } from "cocos/physics/ammo/constraints/ammo-constraint";
    import { IHingeConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { IVec3Like } from "cocos/core/index";
    import { HingeConstraint } from "cocos/physics/framework/index";
    export class AmmoHingeConstraint extends AmmoConstraint implements IHingeConstraint {
        setPivotA(v: IVec3Like): void;
        setPivotB(v: IVec3Like): void;
        setAxisA(v: IVec3Like): void;
        setAxisB(v: IVec3Like): void;
        get impl(): Ammo.btHingeConstraint;
        get constraint(): HingeConstraint;
        private _pivotA;
        private _pivotB;
        private _axisA;
        private _axisB;
        onComponentSet(): void;
    }
}
declare module "cocos/physics/ammo/deprecated" { }
declare module "cocos/physics/ammo/instantiate" {
    import "cocos/physics/ammo/deprecated";
}
declare module "exports/physics-ammo" {
    import "cocos/physics/ammo/instantiate";
}
declare module "cocos/physics/cocos/object/builtin-object" {
    export class BuiltinObject {
        collisionFilterGroup: number;
        collisionFilterMask: number;
        /** group */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        /** mask */
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
    }
}
declare module "cocos/physics/cocos/builtin-interface" {
    /**
     * @hidden
     */
    import { Mat4, Vec3 } from "cocos/core/math/index";
    import { IVec3Like, IQuatLike } from "cocos/core/math/type-define";
    /**
     * declare interface
     */
    export interface IBuiltinShape {
        center: Vec3;
        transform(m: Mat4, pos: IVec3Like, rot: IQuatLike, scale: IVec3Like, out: IBuiltinShape): any;
    }
}
declare module "cocos/physics/cocos/shapes/builtin-shape" {
    import { Mat4, Quat, Vec3 } from "cocos/core/math/index";
    import { BuiltinSharedBody } from "cocos/physics/cocos/builtin-shared-body";
    import { IBuiltinShape } from "cocos/physics/cocos/builtin-interface";
    import { Collider, RigidBody, PhysicMaterial } from "exports/physics-framework";
    import { IBaseShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { aabb, sphere } from "cocos/core/geometry/index";
    export class BuiltinShape implements IBaseShape {
        getAABB(v: aabb): void;
        getBoundingSphere(v: sphere): void;
        setMaterial(v: PhysicMaterial | null): void;
        setAsTrigger(v: boolean): void;
        get attachedRigidBody(): RigidBody | null;
        setCenter(v: IVec3Like): void;
        get localShape(): IBuiltinShape;
        get worldShape(): IBuiltinShape;
        get impl(): IBuiltinShape;
        get sharedBody(): BuiltinSharedBody;
        get collider(): Collider;
        /** id generator */
        private static idCounter;
        readonly id: number;
        protected _sharedBody: BuiltinSharedBody;
        protected _collider: Collider;
        protected _localShape: IBuiltinShape;
        protected _worldShape: IBuiltinShape;
        initialize(comp: Collider): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        transform(m: Mat4, pos: Vec3, rot: Quat, scale: Vec3): void;
        /** group */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        /** mask */
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
    }
}
declare module "cocos/physics/cocos/builtin-rigid-body" {
    import { IRigidBody } from "cocos/physics/spec/i-rigid-body";
    import { IVec3Like } from "cocos/core/index";
    import { RigidBody } from "cocos/physics/framework/index";
    import { BuiltinSharedBody } from "cocos/physics/cocos/builtin-shared-body";
    export class BuiltinRigidBody implements IRigidBody {
        get impl(): this;
        get isAwake(): boolean;
        get isSleepy(): boolean;
        get isSleeping(): boolean;
        get rigidBody(): RigidBody;
        get sharedBody(): BuiltinSharedBody;
        private _rigidBody;
        protected _sharedBody: BuiltinSharedBody;
        initialize(com: RigidBody): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        setMass(v: number): void;
        setLinearDamping(v: number): void;
        setAngularDamping(v: number): void;
        setIsKinematic(v: boolean): void;
        useGravity(v: boolean): void;
        fixRotation(v: boolean): void;
        setLinearFactor(v: IVec3Like): void;
        setAngularFactor(v: IVec3Like): void;
        setAllowSleep(v: boolean): void;
        wakeUp(): void;
        sleep(): void;
        clearState(): void;
        clearForces(): void;
        clearVelocity(): void;
        setSleepThreshold(v: number): void;
        getSleepThreshold(): number;
        getLinearVelocity(out: IVec3Like): void;
        setLinearVelocity(value: IVec3Like): void;
        getAngularVelocity(out: IVec3Like): void;
        setAngularVelocity(value: IVec3Like): void;
        applyForce(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyLocalForce(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyImpulse(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyLocalImpulse(force: IVec3Like, relativePoint?: IVec3Like): void;
        applyTorque(torque: IVec3Like): void;
        applyLocalTorque(torque: IVec3Like): void;
        setGroup(v: number): void;
        getGroup(): number;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        setMask(v: number): void;
        getMask(): number;
        addMask(v: number): void;
        removeMask(v: number): void;
    }
}
declare module "cocos/physics/cocos/builtin-shared-body" {
    import { BuiltInWorld } from "cocos/physics/cocos/builtin-world";
    import { BuiltinObject } from "cocos/physics/cocos/object/builtin-object";
    import { BuiltinShape } from "cocos/physics/cocos/shapes/builtin-shape";
    import { Node } from "cocos/core/index";
    import { BuiltinRigidBody } from "cocos/physics/cocos/builtin-rigid-body";
    /**
     * Built-in static collider, no physical forces involved
     */
    export class BuiltinSharedBody extends BuiltinObject {
        private static readonly sharedBodesMap;
        static getSharedBody(node: Node, wrappedWorld: BuiltInWorld): BuiltinSharedBody;
        get id(): number;
        /**
         * add or remove from world \
         * add, if enable \
         * remove, if disable & shapes.length == 0 & wrappedBody disable
         */
        set enabled(v: boolean);
        set reference(v: boolean);
        /** id generator */
        private static idCounter;
        private readonly _id;
        private index;
        private ref;
        readonly node: Node;
        readonly world: BuiltInWorld;
        readonly shapes: BuiltinShape[];
        wrappedBody: BuiltinRigidBody | null;
        private constructor();
        intersects(body: BuiltinSharedBody): void;
        addShape(shape: BuiltinShape): void;
        removeShape(shape: BuiltinShape): void;
        syncSceneToPhysics(): void;
        syncInitial(): void;
        private destroy;
    }
}
declare module "cocos/physics/cocos/builtin-world" {
    import { PhysicsRayResult } from "cocos/physics/framework/physics-ray-result";
    import { BuiltinSharedBody } from "cocos/physics/cocos/builtin-shared-body";
    import { BuiltinShape } from "cocos/physics/cocos/shapes/builtin-shape";
    import { ray } from "cocos/core/geometry/index";
    import { RecyclePool, Node } from "cocos/core/index";
    import { IPhysicsWorld, IRaycastOptions } from "cocos/physics/spec/i-physics-world";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { PhysicMaterial } from "cocos/physics/framework/assets/physic-material";
    /**
     * Built-in collision system, intended for use as a
     * efficient discrete collision detector,
     * not a full physical simulator
     */
    export class BuiltInWorld implements IPhysicsWorld {
        setGravity(v: IVec3Like): void;
        setAllowSleep(v: boolean): void;
        setDefaultMaterial(v: PhysicMaterial): void;
        get impl(): this;
        shapeArr: BuiltinShape[];
        readonly bodies: BuiltinSharedBody[];
        private _shapeArrPrev;
        private _collisionMatrix;
        private _collisionMatrixPrev;
        step(deltaTime: number): void;
        syncSceneToPhysics(): void;
        emitEvents(): void;
        raycastClosest(worldRay: ray, options: IRaycastOptions, out: PhysicsRayResult): boolean;
        raycast(worldRay: ray, options: IRaycastOptions, pool: RecyclePool<PhysicsRayResult>, results: PhysicsRayResult[]): boolean;
        getSharedBody(node: Node): BuiltinSharedBody;
        addSharedBody(body: BuiltinSharedBody): void;
        removeSharedBody(body: BuiltinSharedBody): void;
        updateCollisionMatrix(group: number, mask: number): void;
        private emitTriggerEvent;
    }
}
declare module "cocos/physics/cocos/shapes/builtin-box-shape" {
    import { obb } from "cocos/core/geometry/index";
    import { BuiltinShape } from "cocos/physics/cocos/shapes/builtin-shape";
    import { IBoxShape } from "cocos/physics/spec/i-physics-shape";
    import { BoxCollider } from "exports/physics-framework";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class BuiltinBoxShape extends BuiltinShape implements IBoxShape {
        get localObb(): obb;
        get worldObb(): obb;
        get collider(): BoxCollider;
        constructor();
        setSize(size: IVec3Like): void;
        onLoad(): void;
    }
}
declare module "cocos/physics/framework/util" {
    /**
     * @hidden
     */
    import { IVec3Like } from "cocos/core/math/type-define";
    export function setWrap<Wrapper>(object: any, wrapper: Wrapper): void;
    export function getWrap<Wrapper>(object: any): Wrapper;
    export function maxComponent(v: IVec3Like): number;
}
declare module "cocos/physics/cocos/shapes/builtin-sphere-shape" {
    import { sphere } from "cocos/core/geometry/index";
    import { BuiltinShape } from "cocos/physics/cocos/shapes/builtin-shape";
    import { ISphereShape } from "cocos/physics/spec/i-physics-shape";
    import { SphereCollider } from "exports/physics-framework";
    export class BuiltinSphereShape extends BuiltinShape implements ISphereShape {
        setRadius(radius: number): void;
        get localSphere(): sphere;
        get worldSphere(): sphere;
        get collider(): SphereCollider;
        constructor(radius?: number);
        onLoad(): void;
    }
}
declare module "cocos/physics/cocos/shapes/builtin-capsule-shape" {
    import { BuiltinShape } from "cocos/physics/cocos/shapes/builtin-shape";
    import { ICapsuleShape } from "cocos/physics/spec/i-physics-shape";
    import { capsule } from "cocos/core/geometry/index";
    import { EAxisDirection, CapsuleCollider } from "cocos/physics/framework/index";
    export class BuiltinCapsuleShape extends BuiltinShape implements ICapsuleShape {
        get localCapsule(): capsule;
        get worldCapsule(): capsule;
        get collider(): CapsuleCollider;
        constructor(radius?: number, height?: number, direction?: EAxisDirection);
        setRadius(v: number): void;
        setCylinderHeight(v: number): void;
        setDirection(v: EAxisDirection): void;
        onLoad(): void;
    }
}
declare module "cocos/physics/cocos/deprecated" { }
declare module "cocos/physics/cocos/instantiate" {
    import "cocos/physics/cocos/deprecated";
}
declare module "exports/physics-builtin" {
    /**
     * @hidden
     */
    import "cocos/physics/cocos/instantiate";
    export * from "cocos/physics/framework/physics-interface";
}
declare module "cocos/physics/cannon/cannon-util" {
    import CANNON from '@cocos/cannon';
    import { PhysicsRayResult } from "cocos/physics/framework/index";
    import { IRaycastOptions } from "cocos/physics/spec/i-physics-world";
    export function toCannonRaycastOptions(out: CANNON.IRaycastOptions, options: IRaycastOptions): void;
    export function fillRaycastResult(result: PhysicsRayResult, cannonResult: CANNON.RaycastResult): void;
    export function commitShapeUpdates(body: CANNON.Body): void;
}
declare module "cocos/physics/cannon/constraints/cannon-constraint" {
    import CANNON from '@cocos/cannon';
    import { IBaseConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { Constraint, RigidBody } from "cocos/physics/framework/index";
    export class CannonConstraint implements IBaseConstraint {
        setConnectedBody(v: RigidBody | null): void;
        setEnableCollision(v: boolean): void;
        get impl(): CANNON.Constraint;
        get constraint(): Constraint;
        protected _impl: CANNON.Constraint;
        protected _com: Constraint;
        protected _rigidBody: RigidBody | null;
        initialize(v: Constraint): void;
        protected onComponentSet(): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-shape" {
    import CANNON from '@cocos/cannon';
    import { PhysicMaterial } from "cocos/physics/framework/assets/physic-material";
    import { IBaseShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { CannonSharedBody } from "cocos/physics/cannon/cannon-shared-body";
    import { Collider, RigidBody } from "cocos/physics/framework/index";
    import { aabb, sphere } from "cocos/core/geometry/index";
    export class CannonShape implements IBaseShape {
        static readonly idToMaterial: {};
        get impl(): CANNON.Shape;
        get collider(): Collider;
        get attachedRigidBody(): RigidBody | null;
        get sharedBody(): CannonSharedBody;
        setMaterial(mat: PhysicMaterial | null): void;
        setAsTrigger(v: boolean): void;
        setCenter(v: IVec3Like): void;
        setAttachedBody(v: RigidBody | null): void;
        getAABB(v: aabb): void;
        getBoundingSphere(v: sphere): void;
        protected _collider: Collider;
        protected _shape: CANNON.Shape;
        protected _offset: CANNON.Vec3;
        protected _orient: CANNON.Quaternion;
        protected _index: number;
        protected _sharedBody: CannonSharedBody;
        protected get _body(): CANNON.Body;
        protected onTriggerListener: (event: CANNON.ITriggeredEvent) => void;
        protected _isBinding: boolean;
        /** LIFECYCLE */
        initialize(comp: Collider): void;
        protected onComponentSet(): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /** INTERFACE */
        /** group */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        /** mask */
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
        /**
         * change scale will recalculate center & size \
         * size handle by child class
         * @param scale
         */
        setScale(scale: IVec3Like): void;
        setIndex(index: number): void;
        setOffsetAndOrient(offset: CANNON.Vec3, orient: CANNON.Quaternion): void;
        protected _setCenter(v: IVec3Like): void;
        protected _onTrigger(event: CANNON.ITriggeredEvent): void;
    }
}
declare module "cocos/physics/cannon/cannon-world" {
    import CANNON from '@cocos/cannon';
    import { CannonConstraint } from "cocos/physics/cannon/constraints/cannon-constraint";
    import { ray } from "cocos/core/geometry/index";
    import { RecyclePool, Node } from "cocos/core/index";
    import { CannonSharedBody } from "cocos/physics/cannon/cannon-shared-body";
    import { IPhysicsWorld, IRaycastOptions } from "cocos/physics/spec/i-physics-world";
    import { PhysicMaterial, PhysicsRayResult } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class CannonWorld implements IPhysicsWorld {
        get impl(): CANNON.World;
        setDefaultMaterial(mat: PhysicMaterial): void;
        setAllowSleep(v: boolean): void;
        setGravity(gravity: IVec3Like): void;
        readonly bodies: CannonSharedBody[];
        readonly constraints: CannonConstraint[];
        private _world;
        private _raycastResult;
        constructor();
        emitEvents(): void;
        syncSceneToPhysics(): void;
        step(deltaTime: number, timeSinceLastCalled?: number, maxSubStep?: number): void;
        raycastClosest(worldRay: ray, options: IRaycastOptions, result: PhysicsRayResult): boolean;
        raycast(worldRay: ray, options: IRaycastOptions, pool: RecyclePool<PhysicsRayResult>, results: PhysicsRayResult[]): boolean;
        getSharedBody(node: Node): CannonSharedBody;
        addSharedBody(sharedBody: CannonSharedBody): void;
        removeSharedBody(sharedBody: CannonSharedBody): void;
        addConstraint(constraint: CannonConstraint): void;
        removeConstraint(constraint: CannonConstraint): void;
        updateCollisionMatrix(group: number, mask: number): void;
    }
}
declare module "cocos/physics/cannon/cannon-contact-equation" {
    import { IContactEquation, ICollisionEvent } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/index";
    export class CannonContactEquation implements IContactEquation {
        get isBodyA(): boolean;
        impl: CANNON.ContactEquation | null;
        event: ICollisionEvent;
        constructor(event: ICollisionEvent);
        getLocalPointOnA(out: IVec3Like): void;
        getLocalPointOnB(out: IVec3Like): void;
        getWorldPointOnA(out: IVec3Like): void;
        getWorldPointOnB(out: IVec3Like): void;
        getLocalNormalOnB(out: IVec3Like): void;
        getWorldNormalOnB(out: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/cannon-shared-body" {
    import CANNON from '@cocos/cannon';
    import { CannonWorld } from "cocos/physics/cannon/cannon-world";
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { Node } from "cocos/core/index";
    import { CannonRigidBody } from "cocos/physics/cannon/cannon-rigid-body";
    /**
     * node : shared-body = 1 : 1
     * static
     */
    export class CannonSharedBody {
        private static readonly sharedBodesMap;
        static getSharedBody(node: Node, wrappedWorld: CannonWorld): CannonSharedBody;
        readonly node: Node;
        readonly wrappedWorld: CannonWorld;
        readonly body: CANNON.Body;
        readonly shapes: CannonShape[];
        wrappedBody: CannonRigidBody | null;
        private index;
        private ref;
        private onCollidedListener;
        /**
         * add or remove from world \
         * add, if enable \
         * remove, if disable & shapes.length == 0 & wrappedBody disable
         */
        set enabled(v: boolean);
        set reference(v: boolean);
        private constructor();
        addShape(v: CannonShape): void;
        removeShape(v: CannonShape): void;
        syncSceneToPhysics(): void;
        syncPhysicsToScene(): void;
        syncInitial(): void;
        private destroy;
        private onCollided;
    }
}
declare module "cocos/physics/cannon/cannon-rigid-body" {
    import CANNON from '@cocos/cannon';
    import { Vec3 } from "cocos/core/math/index";
    import { IRigidBody } from "cocos/physics/spec/i-rigid-body";
    import { CannonSharedBody } from "cocos/physics/cannon/cannon-shared-body";
    import { RigidBody } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/math/type-define";
    /**
     * wrapped shared body
     * dynamic
     * kinematic
     */
    export class CannonRigidBody implements IRigidBody {
        get isAwake(): boolean;
        get isSleepy(): boolean;
        get isSleeping(): boolean;
        setAllowSleep(v: boolean): void;
        setMass(value: number): void;
        setIsKinematic(value: boolean): void;
        fixRotation(value: boolean): void;
        setLinearDamping(value: number): void;
        setAngularDamping(value: number): void;
        useGravity(value: boolean): void;
        setLinearFactor(value: IVec3Like): void;
        setAngularFactor(value: IVec3Like): void;
        get impl(): CANNON.Body;
        get rigidBody(): RigidBody;
        get sharedBody(): CannonSharedBody;
        get isEnabled(): boolean;
        private _rigidBody;
        private _sharedBody;
        private _isEnabled;
        /** LIFECYCLE */
        initialize(com: RigidBody): void;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        /** INTERFACE */
        clearVelocity(): void;
        clearForces(): void;
        clearState(): void;
        wakeUp(): void;
        sleep(): void;
        setSleepThreshold(v: number): void;
        getSleepThreshold(): number;
        getLinearVelocity(out: Vec3): Vec3;
        setLinearVelocity(value: Vec3): void;
        getAngularVelocity(out: Vec3): Vec3;
        setAngularVelocity(value: Vec3): void;
        applyForce(force: Vec3, worldPoint?: Vec3): void;
        applyImpulse(impulse: Vec3, worldPoint?: Vec3): void;
        applyLocalForce(force: Vec3, localPoint?: Vec3): void;
        applyLocalImpulse(impulse: Vec3, localPoint?: Vec3): void;
        applyTorque(torque: Vec3): void;
        applyLocalTorque(torque: Vec3): void;
        /** group */
        getGroup(): number;
        setGroup(v: number): void;
        addGroup(v: number): void;
        removeGroup(v: number): void;
        /** mask */
        getMask(): number;
        setMask(v: number): void;
        addMask(v: number): void;
        removeMask(v: number): void;
        protected _wakeUpIfSleep(): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-box-shape" {
    import CANNON from '@cocos/cannon';
    import { Vec3 } from "cocos/core/math/index";
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { IBoxShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { BoxCollider } from "exports/physics-framework";
    export class CannonBoxShape extends CannonShape implements IBoxShape {
        get collider(): BoxCollider;
        get impl(): CANNON.Box;
        readonly HALF_EXTENT: CANNON.Vec3;
        constructor();
        setSize(v: IVec3Like): void;
        onLoad(): void;
        setScale(scale: Vec3): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-sphere-shape" {
    import CANNON from '@cocos/cannon';
    import { Vec3 } from "cocos/core/math/index";
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { ISphereShape } from "cocos/physics/spec/i-physics-shape";
    import { SphereCollider } from "exports/physics-framework";
    export class CannonSphereShape extends CannonShape implements ISphereShape {
        get collider(): SphereCollider;
        get impl(): CANNON.Sphere;
        setRadius(v: number): void;
        constructor(radius?: number);
        onLoad(): void;
        setScale(scale: Vec3): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-trimesh-shape" {
    import CANNON from '@cocos/cannon';
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { MeshCollider } from "cocos/physics/framework/index";
    import { Mesh, Vec3 } from "cocos/core/index";
    import { ITrimeshShape } from "cocos/physics/spec/i-physics-shape";
    export class CannonTrimeshShape extends CannonShape implements ITrimeshShape {
        get collider(): MeshCollider;
        get impl(): CANNON.Trimesh;
        setMesh(v: Mesh | null): void;
        protected onComponentSet(): void;
        onLoad(): void;
        setScale(scale: Vec3): void;
        updateProperties(vertices: Float32Array, indices: Uint16Array): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-cylinder-shape" {
    import CANNON from '@cocos/cannon';
    import { Vec3 } from "cocos/core/math/index";
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { ICylinderShape } from "cocos/physics/spec/i-physics-shape";
    import { CylinderCollider } from "exports/physics-framework";
    import { EAxisDirection } from "cocos/physics/framework/physics-enum";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class CannonCylinderShape extends CannonShape implements ICylinderShape {
        get collider(): CylinderCollider;
        get impl(): CANNON.Cylinder;
        setRadius(v: number): void;
        setHeight(v: number): void;
        setDirection(v: number): void;
        constructor(radius?: number, height?: number, direction?: EAxisDirection);
        onLoad(): void;
        setScale(scale: Vec3): void;
        updateProperties(radius: number, height: number, numSegments: number, direction: number, scale: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-cone-shape" {
    import CANNON from '@cocos/cannon';
    import { Vec3 } from "cocos/core/math/index";
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { IConeShape } from "cocos/physics/spec/i-physics-shape";
    import { ConeCollider } from "exports/physics-framework";
    import { EAxisDirection } from "cocos/physics/framework/physics-enum";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class CannonConeShape extends CannonShape implements IConeShape {
        get collider(): ConeCollider;
        get impl(): CANNON.Cylinder;
        setRadius(v: number): void;
        setHeight(v: number): void;
        setDirection(v: number): void;
        constructor(radius?: number, height?: number, direction?: EAxisDirection);
        onLoad(): void;
        setScale(scale: Vec3): void;
        updateProperties(radius: number, height: number, numSegments: number, direction: number, scale: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-terrain-shape" {
    import CANNON from '@cocos/cannon';
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { TerrainCollider } from "cocos/physics/framework/index";
    import { ITerrainShape } from "cocos/physics/spec/i-physics-shape";
    import { ITerrainAsset } from "cocos/physics/spec/i-external";
    import { IVec3Like } from "cocos/core/math/type-define";
    export class CannonTerrainShape extends CannonShape implements ITerrainShape {
        get collider(): TerrainCollider;
        get impl(): CANNON.Heightfield;
        setTerrain(v: ITerrainAsset | null): void;
        readonly DATA: number[][];
        readonly OPTIONS: CANNON.IHightfield;
        private _terrainID;
        constructor();
        protected onComponentSet(): void;
        onLoad(): void;
        updateProperties(data: number[][], elementSize: number): void;
        protected _setCenter(v: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-simplex-shape" {
    import CANNON from '@cocos/cannon';
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { ISimplexShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { SimplexCollider } from "exports/physics-framework";
    export class CannonSimplexShape extends CannonShape implements ISimplexShape {
        setShapeType(v: SimplexCollider.ESimplexType): void;
        setVertices(v: IVec3Like[]): void;
        get collider(): SimplexCollider;
        get impl(): CANNON.ConvexPolyhedron | CANNON.Particle;
        readonly VERTICES: CANNON.Vec3[];
        protected onComponentSet(): void;
        onLoad(): void;
        setScale(scale: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/shapes/cannon-plane-shape" {
    import CANNON from '@cocos/cannon';
    import { CannonShape } from "cocos/physics/cannon/shapes/cannon-shape";
    import { IPlaneShape } from "cocos/physics/spec/i-physics-shape";
    import { IVec3Like } from "cocos/core/math/type-define";
    import { PlaneCollider } from "exports/physics-framework";
    export class CannonPlaneShape extends CannonShape implements IPlaneShape {
        get collider(): PlaneCollider;
        get impl(): CANNON.Plane;
        constructor();
        setNormal(v: IVec3Like): void;
        setConstant(v: number): void;
        onLoad(): void;
        _setCenter(v: IVec3Like): void;
    }
}
declare module "cocos/physics/cannon/constraints/cannon-point-to-point-constraint" {
    import CANNON from '@cocos/cannon';
    import { CannonConstraint } from "cocos/physics/cannon/constraints/cannon-constraint";
    import { IPointToPointConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { IVec3Like } from "cocos/core/index";
    import { PointToPointConstraint } from "cocos/physics/framework/index";
    export class CannonPointToPointConstraint extends CannonConstraint implements IPointToPointConstraint {
        get impl(): CANNON.PointToPointConstraint;
        get constraint(): PointToPointConstraint;
        setPivotA(v: IVec3Like): void;
        setPivotB(v: IVec3Like): void;
        onComponentSet(): void;
    }
}
declare module "cocos/physics/cannon/constraints/cannon-hinge-constraint" {
    import CANNON from '@cocos/cannon';
    import { CannonConstraint } from "cocos/physics/cannon/constraints/cannon-constraint";
    import { IHingeConstraint } from "cocos/physics/spec/i-physics-constraint";
    import { HingeConstraint } from "cocos/physics/framework/index";
    import { IVec3Like } from "cocos/core/index";
    export class CannonHingeConstraint extends CannonConstraint implements IHingeConstraint {
        get impl(): CANNON.HingeConstraint;
        get constraint(): HingeConstraint;
        setPivotA(v: IVec3Like): void;
        setPivotB(v: IVec3Like): void;
        setAxisA(v: IVec3Like): void;
        setAxisB(v: IVec3Like): void;
        onComponentSet(): void;
    }
}
declare module "cocos/physics/cannon/deprecated" { }
declare module "cocos/physics/cannon/instantiate" {
    import "cocos/physics/cannon/deprecated";
}
declare module "exports/physics-cannon" {
    import "cocos/physics/cannon/instantiate";
}
declare module "cocos/terrain/height-field" {
    export class HeightField {
        data: Uint16Array;
        w: number;
        h: number;
        constructor(w: number, h: number);
        set(i: number, j: number, value: number): void;
        get(i: number, j: number): number;
        getClamp(i: number, j: number): number;
        getAt(x: number, y: number): number;
    }
}
declare module "cocos/terrain/terrain" {
    import { EffectAsset, Texture2D } from "cocos/core/assets/index";
    import { Material } from "cocos/core/assets/material";
    import { Component } from "cocos/core/components/index";
    import { GFXBuffer } from "cocos/core/gfx/buffer";
    import { Rect, Size, Vec3, Vec4 } from "cocos/core/math/index";
    import { MacroRecord } from "cocos/core/renderer/core/pass-utils";
    import { HeightField } from "cocos/terrain/height-field";
    import { TerrainAsset } from "cocos/terrain/terrain-asset";
    /**
     * @en Terrain info
     * @zh 地形信息
     */
    export class TerrainInfo {
        /**
         * @en tile size
         * @zh 栅格大小
         */
        tileSize: number;
        /**
         * @en block count
         * @zh 地形块的数量
         */
        blockCount: number[];
        /**
         * @en weight map size
         * @zh 权重图大小
         */
        weightMapSize: number;
        /**
         * @en light map size
         * @zh 光照图大小
         */
        lightMapSize: number;
        /**
         * @en terrain size
         * @zh 地形大小
         */
        get size(): Size;
        /**
         * @en tile count
         * @zh 栅格数量
         */
        get tileCount(): number[];
        /**
         * @en vertex count
         * @zh 顶点数量
         */
        get vertexCount(): number[];
    }
    /**
     * @en Terrain layer
     * @zh 地形纹理层
     */
    export class TerrainLayer {
        /**
         * @en detail texture
         * @zh 细节纹理
         */
        detailMap: Texture2D | null;
        /**
         * @en tile size
         * @zh 平铺大小
         */
        tileSize: number;
    }
    /**
     * @en Terrain block info
     * @zh 地形块信息
     */
    export class TerrainBlockInfo {
        layers: number[];
    }
    /**
     * @en Terrain block light map info
     * @zh 地形块光照图信息
     */
    export class TerrainBlockLightmapInfo {
        texture: Texture2D | null;
        UOff: number;
        VOff: number;
        UScale: number;
        VScale: number;
    }
    /**
     * @en Terrain block
     * @zh 地形块
     */
    export class TerrainBlock {
        private _terrain;
        private _info;
        private _node;
        private _renderable;
        private _index;
        private _weightMap;
        private _lightmapInfo;
        constructor(t: Terrain, i: number, j: number);
        build(): void;
        rebuild(): void;
        destroy(): void;
        update(): void;
        setBrushMaterial(mtl: Material | null): void;
        /**
         * @en get layers
         * @zh 获得纹理层索引
         */
        get layers(): number[];
        /**
         * @en get light map
         * @zh 获得光照图
         */
        get lightmap(): Texture2D | null;
        /**
         * @en get light map uv parameter
         * @zh 获得光照图纹理坐标参数
         */
        get lightmapUVParam(): Vec4;
        /**
         * @en get terrain owner
         * @zh 获得地形对象
         */
        getTerrain(): Terrain;
        /**
         * @en get index
         * @zh 获得地形索引
         */
        getIndex(): number[];
        /**
         * @en get rect bound
         * @zh 获得地形矩形包围体
         */
        getRect(): Rect;
        /**
         * @en set layer
         * @zh 设置纹理层
         */
        setLayer(index: number, layerId: number): void;
        /**
         * @en get layer
         * @zh 获得纹理层
         */
        getLayer(index: number): number;
        /**
         * @en get max layer index
         * @zh 获得最大纹理索引
         */
        getMaxLayer(): 1 | 0 | 2 | 3;
        _getMaterialDefines(nlayers: number): MacroRecord;
        _invalidMaterial(): void;
        _updateMaterial(init: boolean): void;
        _updateHeight(): void;
        _updateWeightMap(): void;
        _updateLightmap(info: TerrainBlockLightmapInfo): void;
    }
    /**
     * @en Terrain
     * @zh 地形组件
     */
    export class Terrain extends Component {
        protected __asset: TerrainAsset | null;
        protected _effectAsset: EffectAsset | null;
        protected _layers: (TerrainLayer | null)[];
        protected _blockInfos: TerrainBlockInfo[];
        protected _lightmapInfos: TerrainBlockLightmapInfo[];
        protected _tileSize: number;
        protected _blockCount: number[];
        protected _weightMapSize: number;
        protected _lightMapSize: number;
        protected _heights: Uint16Array;
        protected _weights: Uint8Array;
        protected _normals: number[];
        protected _blocks: TerrainBlock[];
        protected _sharedIndexBuffer: GFXBuffer | null;
        constructor();
        set _asset(value: TerrainAsset | null);
        get _asset(): TerrainAsset | null;
        /**
         * @en Terrain effect asset
         * @zh 地形特效资源
         */
        set effectAsset(value: EffectAsset | null);
        get effectAsset(): EffectAsset | null;
        /**
         * @en get terrain size
         * @zh 获得地形大小
         */
        get size(): Size;
        /**
         * @en get tile size
         * @zh 获得栅格大小
         */
        get tileSize(): number;
        /**
         * @en get tile count
         * @zh 获得栅格数量
         */
        get tileCount(): number[];
        /**
         * @en get vertex count
         * @zh 获得顶点数量
         */
        get vertexCount(): number[];
        /**
         * @en get block count
         * @zh 获得地形块数量
         */
        get blockCount(): number[];
        /**
         * @en get light map size
         * @zh 获得光照图大小
         */
        get lightMapSize(): number;
        /**
         * @en get weight map size
         * @zh 获得权重图大小
         */
        get weightMapSize(): number;
        /**
         * @en get height buffer
         * @zh 获得高度缓存
         */
        get heights(): Uint16Array;
        /**
         * @en get weight buffer
         * @zh 获得权重缓存
         */
        get weights(): Uint8Array;
        /**
         * @en check valid
         * @zh 检测是否有效
         */
        get valid(): boolean;
        /**
         * @en get terrain info
         * @zh 获得地形信息
         */
        get info(): TerrainInfo;
        /**
         * @en build
         * @zh 构建地形
         */
        build(info: TerrainInfo): boolean | undefined;
        /**
         * @en rebuild
         * @zh 重建地形
         */
        rebuild(info: TerrainInfo): void;
        /**
         * @en import height field
         * @zh 导入高度图
         */
        importHeightField(hf: HeightField, heightScale: number): void;
        /**
         * @en export height field
         * @zh 导出高度图
         */
        exportHeightField(hf: HeightField, heightScale: number): void;
        exportAsset(): TerrainAsset;
        getEffectAsset(): any;
        onLoad(): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        onRestore(): void;
        update(deltaTime: number): void;
        /**
         * @en add layer
         * @zh 添加纹理层
         */
        addLayer(layer: TerrainLayer): number;
        /**
         * @en set layer
         * @zh 设置纹理层
         */
        setLayer(i: number, layer: TerrainLayer): void;
        /**
         * @en remove layer
         * @zh 移除纹理层
         */
        removeLayer(id: number): void;
        /**
         * @en get layer
         * @zh 获得纹理层
         */
        getLayer(id: number): TerrainLayer | null;
        /**
         * @en get position
         * @zh 获得地形上的位置
         */
        getPosition(i: number, j: number): Vec3;
        getHeightField(): Uint16Array;
        /**
         * @en set height
         * @zh 设置地形上的高度
         */
        setHeight(i: number, j: number, h: number): void;
        /**
         * @en get height
         * @zh 获得地形上的高度
         */
        getHeight(i: number, j: number): number;
        /**
         * @en set height
         * @zh 设置高度
         */
        getHeightClamp(i: number, j: number): number;
        /**
         * @en get height by point
         * @zh 根据点的坐标获得高度
         */
        getHeightAt(x: number, y: number): number | null;
        _setNormal(i: number, j: number, n: Vec3): void;
        /**
         * @en get normal
         * @zh 获得法线
         */
        getNormal(i: number, j: number): Vec3;
        /**
         * @en get normal by point
         * @zh 根据点的坐标获得法线
         */
        getNormalAt(x: number, y: number): Vec3 | null;
        /**
         * @en set weight
         * @zh 设置权重
         */
        setWeight(i: number, j: number, w: Vec4): void;
        /**
         * @en get weight
         * @zh 获得权重
         */
        getWeight(i: number, j: number): Vec4;
        /**
         * @en get normal by point
         * @zh 根据点的坐标获得权重
         */
        getWeightAt(x: number, y: number): Vec4 | null;
        /**
         * @en get block info
         * @zh 获得地形块信息
         */
        getBlockInfo(i: number, j: number): TerrainBlockInfo;
        /**
         * @en get block
         * @zh 获得地形块对象
         */
        getBlock(i: number, j: number): TerrainBlock;
        /**
         * @en get all blocks
         * @zh 获得地形块缓存
         */
        getBlocks(): TerrainBlock[];
        /**
         * @en ray check
         * @param start ray start
         * @param dir ray direction
         * @param step ray step
         * @param worldSpace is world space
         * @zh 射线检测
         * @param start 射线原点
         * @param dir 射线方向
         * @param step 射线步长
         * @param worldSpace 是否在世界空间
         */
        rayCheck(start: Vec3, dir: Vec3, step: number, worldSpace?: boolean): Vec3 | null;
        _getSharedIndexBuffer(): GFXBuffer | null;
        _resetLightmap(enble: boolean): void;
        _updateLightmap(blockId: number, tex: Texture2D | null, uOff: number, vOff: number, uScale: number, vScale: number): void;
        _getLightmapInfo(i: number, j: number): TerrainBlockLightmapInfo | null;
        _calcNormal(x: number, z: number): Vec3;
        _buildNormals(): void;
        private _buildImp;
        private _rebuildHeights;
        private _rebuildWeights;
    }
}
declare module "cocos/terrain/index" {
    /**
     * @hidden
     */
    export * from "cocos/terrain/height-field";
    export * from "cocos/terrain/terrain";
    export * from "cocos/terrain/terrain-asset";
}
declare module "exports/terrain" {
    /**
     * @hidden
     */
    export * from "cocos/terrain/index";
}
declare module "cocos/tween/actions/action" {
    /**
     * @hidden
     */
    import { Node } from "cocos/core/index";
    /**
     * !#en Base classAction for action classes.
     * !#zh Action 类是所有动作类型的基类。
     * @class Action
     */
    export class Action {
        /**
         * !#en Default Action tag.
         * !#zh 默认动作标签。
         * @constant
         * @static
         * @default -1
         */
        static TAG_INVALID: number;
        protected originalTarget: Node | null;
        protected target: Node | null;
        protected tag: number;
        /**
         * !#en
         * to copy object with deep copy.
         * returns a clone of action.
         * !#zh 返回一个克隆的动作。
         * @method clone
         * @return {Action}
         */
        clone(): Action;
        /**
         * !#en
         * return true if the action has finished.
         * !#zh 如果动作已完成就返回 true。
         * @method isDone
         * @return {Boolean}
         */
        isDone(): boolean;
        startWithTarget(target: any): void;
        stop(): void;
        step(dt: number): void;
        update(dt: number): void;
        /**
         * !#en get the target.
         * !#zh 获取当前目标节点。
         * @method getTarget
         * @return {object}
         */
        getTarget(): Node | null;
        /**
         * !#en The action will modify the target properties.
         * !#zh 设置目标节点。
         * @method setTarget
         * @param {object} target
         */
        setTarget(target: Node): void;
        /**
         * !#en get the original target.
         * !#zh 获取原始目标节点。
         * @method getOriginalTarget
         * @return {object}
         */
        getOriginalTarget(): Node | null;
        setOriginalTarget(originalTarget: any): void;
        /**
         * !#en get tag number.
         * !#zh 获取用于识别动作的标签。
         * @method getTag
         * @return {Number}
         */
        getTag(): number;
        /**
         * !#en set tag number.
         * !#zh 设置标签，用于识别动作。
         * @method setTag
         * @param {Number} tag
         */
        setTag(tag: number): void;
        /**
         * !#en
         * Returns a reversed action. <br />
         * For example: <br />
         * - The action will be x coordinates of 0 move to 100. <br />
         * - The reversed action will be x of 100 move to 0.
         * - Will be rewritten
         * !#zh 返回一个新的动作，执行与原动作完全相反的动作。
         * @method reverse
         * @return {Action | null}
         */
        reverse(): Action | null;
        retain(): void;
        release(): void;
    }
    /**
     * !#en
     * Base class actions that do have a finite time duration. <br/>
     * Possible actions: <br/>
     * - An action with a duration of 0 seconds. <br/>
     * - An action with a duration of 35.5 seconds.
     *
     * Infinite time actions are valid
     * !#zh 有限时间动作，这种动作拥有时长 duration 属性。
     * @class FiniteTimeAction
     * @extends Action
     */
    export class FiniteTimeAction extends Action {
        _duration: number;
        _timesForRepeat: number;
        /**
         * !#en get duration of the action. (seconds).
         * !#zh 获取动作以秒为单位的持续时间。
         * @method getDuration
         * @return {Number}
         */
        getDuration(): number;
        /**
         * !#en set duration of the action. (seconds).
         * !#zh 设置动作以秒为单位的持续时间。
         * @method setDuration
         * @param {Number} duration
         */
        setDuration(duration: number): void;
        /**
         * !#en
         * to copy object with deep copy.
         * returns a clone of action.
         * !#zh 返回一个克隆的动作。
         * @method clone
         * @return {FiniteTimeAction}
         */
        clone(): FiniteTimeAction;
    }
    export class Speed extends Action {
        protected _speed: number;
        protected _innerAction: Action | null;
        /**
         * @warning This action can't be `Sequence-able` because it is not an `IntervalAction`
         */
        constructor(action?: Action, speed?: number);
        getSpeed(): number;
        setSpeed(speed: number): void;
        initWithAction(action: Action, speed: number): boolean;
        clone(): Speed;
        startWithTarget(target: any): void;
        stop(): void;
        step(dt: number): void;
        isDone(): boolean;
        reverse(): Speed;
        setInnerAction(action: any): void;
        getInnerAction(): Action | null;
    }
}
declare module "cocos/tween/actions/action-manager" {
    import { Action } from "cocos/tween/actions/action";
    import { Node } from "cocos/core/index";
    /**
     * !#en
     * `ActionManager` is a class that can manage actions.<br/>
     * Normally you won't need to use this class directly. 99% of the cases you will use the CCNode interface,
     * which uses this class's singleton object.
     * But there are some cases where you might need to use this class. <br/>
     * Examples:<br/>
     * - When you want to run an action where the target is different from a CCNode.<br/>
     * - When you want to pause / resume the actions<br/>
     * !#zh
     * `ActionManager` 是可以管理动作的单例类。<br/>
     * 通常你并不需要直接使用这个类，99%的情况您将使用 CCNode 的接口。<br/>
     * 但也有一些情况下，您可能需要使用这个类。 <br/>
     * 例如：
     *  - 当你想要运行一个动作，但目标不是 CCNode 类型时。 <br/>
     *  - 当你想要暂停/恢复动作时。 <br/>
     * @class ActionManager
     * @example {@link cocos2d/core/CCActionManager/ActionManager.js}
     */
    export class ActionManager {
        private _hashTargets;
        private _arrayTargets;
        private _currentTarget;
        private _elementPool;
        private _searchElementByTarget;
        private _getElement;
        private _putElement;
        /**
         * !#en
         * Adds an action with a target.<br/>
         * If the target is already present, then the action will be added to the existing target.
         * If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
         * When the target is paused, the queued actions won't be 'ticked'.
         * !#zh
         * 增加一个动作，同时还需要提供动作的目标对象，目标对象是否暂停作为参数。<br/>
         * 如果目标已存在，动作将会被直接添加到现有的节点中。<br/>
         * 如果目标不存在，将为这一目标创建一个新的实例，并将动作添加进去。<br/>
         * 当目标状态的 paused 为 true，动作将不会被执行
         *
         * @method addAction
         * @param {Action} action
         * @param {object} target
         * @param {Boolean} paused
         */
        addAction(action: Action, target: Node, paused: boolean): void;
        /**
         * !#en Removes all actions from all the targets.
         * !#zh 移除所有对象的所有动作。
         * @method removeAllActions
         */
        removeAllActions(): void;
        /**
         * !#en
         * Removes all actions from a certain target. <br/>
         * All the actions that belongs to the target will be removed.
         * !#zh
         * 移除指定对象上的所有动作。<br/>
         * 属于该目标的所有的动作将被删除。
         * @method removeAllActionsFromTarget
         * @param {Node} target
         */
        removeAllActionsFromTarget(target: Node): void;
        /**
         * !#en Removes an action given an action reference.
         * !#zh 移除指定的动作。
         * @method removeAction
         * @param {Action} action
         */
        removeAction(action: Action): void;
        _removeActionByTag(tag: number, element: any, target?: Node): void;
        /**
         * !#en Removes an action given its tag and the target.
         * !#zh 删除指定对象下特定标签的一个动作，将删除首个匹配到的动作。
         * @method removeActionByTag
         * @param {Number} tag
         * @param {Node} target
         */
        removeActionByTag(tag: number, target?: Node): void;
        /**
         * !#en Gets an action given its tag an a target.
         * !#zh 通过目标对象和标签获取一个动作。
         * @method getActionByTag
         * @param {Number} tag
         * @param {Node} target
         * @return {Action|null}  return the Action with the given tag on success
         */
        getActionByTag(tag: number, target: Node): Action | null;
        /**
         * !#en
         * Returns the numbers of actions that are running in a certain target. <br/>
         * Composable actions are counted as 1 action. <br/>
         * Example: <br/>
         * - If you are running 1 Sequence of 7 actions, it will return 1. <br/>
         * - If you are running 7 Sequences of 2 actions, it will return 7.
         * !#zh
         * 返回指定对象下所有正在运行的动作数量。 <br/>
         * 组合动作被算作一个动作。<br/>
         * 例如：<br/>
         *  - 如果您正在运行 7 个动作组成的序列动作（Sequence），这个函数将返回 1。<br/>
         *  - 如果你正在运行 2 个序列动作（Sequence）和 5 个普通动作，这个函数将返回 7。<br/>
         *
         * @method getNumberOfRunningActionsInTarget
         * @param {Node} target
         * @return {Number}
         */
        getNumberOfRunningActionsInTarget(target: Node): number;
        /**
         * !#en Pauses the target: all running actions and newly added actions will be paused.
         * !#zh 暂停指定对象：所有正在运行的动作和新添加的动作都将会暂停。
         * @method pauseTarget
         * @param {Node} target
         */
        pauseTarget(target: Node): void;
        /**
         * !#en Resumes the target. All queued actions will be resumed.
         * !#zh 让指定目标恢复运行。在执行序列中所有被暂停的动作将重新恢复运行。
         * @method resumeTarget
         * @param {Node} target
         */
        resumeTarget(target: Node): void;
        /**
         * !#en Pauses all running actions, returning a list of targets whose actions were paused.
         * !#zh 暂停所有正在运行的动作，返回一个包含了那些动作被暂停了的目标对象的列表。
         * @method pauseAllRunningActions
         * @return {Array}  a list of targets whose actions were paused.
         */
        pauseAllRunningActions(): Array<any>;
        /**
         * !#en Resume a set of targets (convenience function to reverse a pauseAllRunningActions or pauseTargets call).
         * !#zh 让一组指定对象恢复运行（用来逆转 pauseAllRunningActions 效果的便捷函数）。
         * @method resumeTargets
         * @param {Array} targetsToResume
         */
        resumeTargets(targetsToResume: Array<any>): void;
        /**
         * !#en Pause a set of targets.
         * !#zh 暂停一组指定对象。
         * @method pauseTargets
         * @param {Array} targetsToPause
         */
        pauseTargets(targetsToPause: Array<any>): void;
        /**
         * !#en
         * purges the shared action manager. It releases the retained instance. <br/>
         * because it uses this, so it can not be static.
         * !#zh
         * 清除共用的动作管理器。它释放了持有的实例。 <br/>
         * 因为它使用 this，因此它不能是静态的。
         * @method purgeSharedManager
         */
        purgeSharedManager(): void;
        private _removeActionAtIndex;
        private _deleteHashElement;
        /**
         * !#en The ActionManager update。
         * !#zh ActionManager 主循环。
         * @method update
         * @param {Number} dt delta time in seconds
         */
        update(dt: number): void;
    }
}
declare module "cocos/tween/tween-system" {
    /**
     * @category tween
     */
    import { System } from "cocos/core/index";
    import { ActionManager } from "cocos/tween/actions/action-manager";
    /**
     * @en
     * Tween system.
     * @zh
     * 缓动系统。
     */
    export class TweenSystem extends System {
        /**
         * @en
         * The ID flag of the system.
         * @zh
         * 此系统的 ID 标记。
         */
        static readonly ID = "TWEEN";
        /**
         * @en
         * Gets the instance of the tween system.
         * @zh
         * 获取缓动系统的实例。
         */
        static readonly instance: TweenSystem;
        /**
         * @en
         * Gets the action manager.
         * @zh
         * 获取动作管理器。
         */
        get ActionManager(): ActionManager;
        private readonly actionMgr;
        /**
         * @en
         * The postUpdate will auto execute after all compnents update and lateUpdate.
         * @zh
         * 此方法会在组件 lateUpdate 之后自动执行。
         * @param dt 间隔时间
         */
        postUpdate(dt: number): void;
    }
}
declare module "cocos/tween/actions/action-instant" {
    /**
     * @hidden
     */
    import { FiniteTimeAction, Action } from "cocos/tween/actions/action";
    /**
     * !#en Instant actions are immediate actions. They don't have a duration like the ActionInterval actions.
     * !#zh 即时动作，这种动作立即就会执行，继承自 FiniteTimeAction。
     * @class ActionInstant
     * @extends FiniteTimeAction
     */
    export class ActionInstant extends FiniteTimeAction {
        isDone(): boolean;
        step(dt: any): void;
        update(dt: number): void;
        /**
         * returns a reversed action. <br />
         * For example: <br />
         * - The action is x coordinates of 0 move to 100. <br />
         * - The reversed action will be x of 100 move to 0.
         * @returns {Action}
         */
        reverse(): Action;
        clone(): ActionInstant;
    }
    export class Show extends ActionInstant {
        update(dt: any): void;
        reverse(): Hide;
        clone(): Show;
    }
    /**
     * !#en Show the Node.
     * !#zh 立即显示。
     * @method show
     * @return {ActionInstant}
     * @example
     * // example
     * var showAction = show();
     */
    export function show(): ActionInstant;
    export class Hide extends ActionInstant {
        update(dt: any): void;
        reverse(): Show;
        clone(): Hide;
    }
    /**
     * !#en Hide the node.
     * !#zh 立即隐藏。
     * @method hide
     * @return {ActionInstant}
     * @example
     * // example
     * var hideAction = hide();
     */
    export function hide(): ActionInstant;
    export class ToggleVisibility extends ActionInstant {
        update(dt: any): void;
        reverse(): ToggleVisibility;
        clone(): ToggleVisibility;
    }
    /**
     * !#en Toggles the visibility of a node.
     * !#zh 显隐状态切换。
     * @method toggleVisibility
     * @return {ActionInstant}
     * @example
     * // example
     * var toggleVisibilityAction = toggleVisibility();
     */
    export function toggleVisibility(): ActionInstant;
    export class RemoveSelf extends ActionInstant {
        protected _isNeedCleanUp: boolean;
        constructor(isNeedCleanUp?: boolean);
        update(dt: any): void;
        init(isNeedCleanUp: any): boolean;
        reverse(): RemoveSelf;
        clone(): RemoveSelf;
    }
    /**
     * !#en Create a RemoveSelf object with a flag indicate whether the target should be cleaned up while removing.
     * !#zh 从父节点移除自身。
     * @method removeSelf
     * @param {Boolean} [isNeedCleanUp = true]
     * @return {ActionInstant}
     *
     * @example
     * // example
     * var removeSelfAction = removeSelf();
     */
    export function removeSelf(isNeedCleanUp: boolean): ActionInstant;
    export class CallFunc extends ActionInstant {
        private _selectorTarget;
        private _function;
        private _data;
        constructor(selector?: Function, selectorTarget?: any, data?: any);
        initWithFunction(selector: any, selectorTarget?: any, data?: any): boolean;
        execute(): void;
        update(dt: any): void;
        getTargetCallback(): null;
        setTargetCallback(sel: any): void;
        clone(): CallFunc;
    }
    /**
     * !#en Creates the action with the callback.
     * !#zh 执行回调函数。
     * @method callFunc
     * @param {function} selector
     * @param {object} [selectorTarget=null]
     * @param {*} [data=null] - data for function, it accepts all data types.
     * @return {ActionInstant}
     * @example
     * // example
     * // CallFunc without data
     * var finish = callFunc(this.removeSprite, this);
     *
     * // CallFunc with data
     * var finish = callFunc(this.removeFromParentAndCleanup, this._grossini,  true);
     */
    export function callFunc(selector: Function, selectorTarget?: any, data?: any): ActionInstant;
}
declare module "cocos/tween/actions/action-interval" {
    /**
     * @hidden
     */
    import { FiniteTimeAction, Action } from "cocos/tween/actions/action";
    /**
     * !#en
     * <p> An interval action is an action that takes place within a certain period of time. <br/>
     * It has an start time, and a finish time. The finish time is the parameter<br/>
     * duration plus the start time.</p>
     *
     * <p>These CCActionInterval actions have some interesting properties, like:<br/>
     * - They can run normally (default)  <br/>
     * - They can run reversed with the reverse method   <br/>
     * - They can run with the time altered with the Accelerate, AccelDeccel and Speed actions. </p>
     *
     * <p>For example, you can simulate a Ping Pong effect running the action normally and<br/>
     * then running it again in Reverse mode. </p>
     * !#zh 时间间隔动作，这种动作在已定时间内完成，继承 FiniteTimeAction。
     * @class ActionInterval
     * @extends FiniteTimeAction
     * @param {Number} d duration in seconds
     */
    export class ActionInterval extends FiniteTimeAction {
        protected MAX_VALUE: number;
        protected _elapsed: number;
        protected _firstTick: boolean;
        protected _easeList: Function[];
        protected _speed: number;
        protected _repeatForever: boolean;
        _repeatMethod: boolean;
        protected _speedMethod: boolean;
        constructor(d?: number);
        getElapsed(): number;
        initWithDuration(d: number): boolean;
        isDone(): boolean;
        _cloneDecoration(action: ActionInterval): void;
        _reverseEaseList(action: ActionInterval): void;
        clone(): ActionInterval;
        /**
         * !#en Implementation of ease motion.
         * !#zh 缓动运动。
         * @method easing
         * @param {Object} easeObj
         * @returns {ActionInterval}
         * @example
         * import { easeIn } from 'cc';
         * action.easing(easeIn(3.0));
         */
        easing(easeObj: any): ActionInterval;
        _computeEaseTime(dt: any): any;
        step(dt: number): void;
        startWithTarget(target: any): void;
        reverse(): this;
        setAmplitudeRate(amp: any): void;
        getAmplitudeRate(): number;
        /**
         * !#en
         * Changes the speed of an action, making it take longer (speed>1)
         * or less (speed<1) time. <br/>
         * Useful to simulate 'slow motion' or 'fast forward' effect.
         * !#zh
         * 改变一个动作的速度，使它的执行使用更长的时间（speed > 1）<br/>
         * 或更少（speed < 1）可以有效得模拟“慢动作”或“快进”的效果。
         * @param {Number} speed
         * @returns {Action}
         */
        speed(speed: number): Action;
        /**
         * Get this action speed.
         * @return {Number}
         */
        getSpeed(): number;
        /**
         * Set this action speed.
         * @param {Number} speed
         * @returns {ActionInterval}
         */
        setSpeed(speed: number): ActionInterval;
        /**
         * !#en
         * Repeats an action a number of times.
         * To repeat an action forever use the CCRepeatForever action.
         * !#zh 重复动作可以按一定次数重复一个动作，使用 RepeatForever 动作来永远重复一个动作。
         * @method repeat
         * @param {Number} times
         * @returns {ActionInterval}
         */
        repeat(times: number): ActionInterval;
        /**
         * !#en
         * Repeats an action for ever.  <br/>
         * To repeat the an action for a limited number of times use the Repeat action. <br/>
         * !#zh 永远地重复一个动作，有限次数内重复一个动作请使用 Repeat 动作。
         * @method repeatForever
         * @returns {ActionInterval}
         */
        repeatForever(): ActionInterval;
    }
    export class Sequence extends ActionInterval {
        static _actionOneTwo: (actionOne: ActionInterval, actionTwo: ActionInterval) => Sequence;
        private _actions;
        private _split;
        private _last;
        private _reversed;
        /**
         * @example
         * import { Sequence } from 'cc';
         *
         * // create sequence with actions
         * const seq = new Sequence(act1, act2);
         *
         * // create sequence with array
         * const seq = new Sequence(actArray);
         */
        constructor(...actions: FiniteTimeAction[]);
        initWithTwoActions(actionOne: any, actionTwo: any): boolean;
        clone(): any;
        startWithTarget(target: any): void;
        stop(): void;
        update(dt: number): void;
        reverse(): any;
    }
    /**
     * !#en
     * Helper constructor to create an array of sequenceable actions
     * The created action will run actions sequentially, one after another.
     * !#zh 顺序执行动作，创建的动作将按顺序依次运行。
     * @method sequence
     * @param {FiniteTimeAction|FiniteTimeAction[]} actionOrActionArray
     * @param {FiniteTimeAction} ...tempArray
     * @return {ActionInterval}
     * @example
     * import { sequence } from 'cc';
     *
     * // Create sequence with actions
     * const seq = sequence(act1, act2);
     *
     * // Create sequence with array
     * const seq = sequence(actArray);
     */
    export function sequence(/*Multiple Arguments*/ tempArray: any): ActionInterval;
    export class Repeat extends ActionInterval {
        private _times;
        private _total;
        private _nextDt;
        private _actionInstant;
        private _innerAction;
        constructor(action?: any, times?: any);
        initWithAction(action: FiniteTimeAction, times: number): boolean;
        clone(): Repeat;
        startWithTarget(target: any): void;
        stop(): void;
        update(dt: number): void;
        isDone(): boolean;
        reverse(): any;
        setInnerAction(action: any): void;
        getInnerAction(): FiniteTimeAction | null;
    }
    /**
     * !#en Creates a Repeat action. Times is an unsigned integer between 1 and pow(2,30)
     * !#zh 重复动作，可以按一定次数重复一个动，如果想永远重复一个动作请使用 repeatForever 动作来完成。
     * @method repeat
     * @param {FiniteTimeAction} action
     * @param {Number} times
     * @return {Action}
     * @example
     * import { repeat, sequence } from 'cc';
     * const rep = repeat(sequence(jump2, jump1), 5);
     */
    export function repeat(action: any, times: any): Action;
    export class RepeatForever extends ActionInterval {
        private _innerAction;
        constructor(action?: ActionInterval);
        initWithAction(action: ActionInterval): boolean;
        clone(): RepeatForever;
        startWithTarget(target: any): void;
        step(dt: any): void;
        isDone(): boolean;
        reverse(): any;
        setInnerAction(action: any): void;
        getInnerAction(): ActionInterval | null;
    }
    /**
     * !#en Create a acton which repeat forever, as it runs forever, it can't be added into `sequence` and `spawn`.
     * !#zh 永远地重复一个动作，有限次数内重复一个动作请使用 repeat 动作，由于这个动作不会停止，所以不能被添加到 `sequence` 或 `spawn` 中。
     * @method repeatForever
     * @param {FiniteTimeAction} action
     * @return {ActionInterval}
     * @example
     * import { repeatForever, rotateBy } from 'cc';
     * var repeat = repeatForever(rotateBy(1.0, 360));
     */
    export function repeatForever(action?: ActionInterval): ActionInterval;
    export class Spawn extends ActionInterval {
        static _actionOneTwo: (action1: any, action2: any) => Spawn;
        private _one;
        private _two;
        constructor(tempArray?: any);
        initWithTwoActions(action1: any, action2: any): boolean;
        clone(): Spawn;
        startWithTarget(target: any): void;
        stop(): void;
        update(dt: any): void;
        reverse(): any;
    }
    /**
     * !#en Create a spawn action which runs several actions in parallel.
     * !#zh 同步执行动作，同步执行一组动作。
     * @method spawn
     * @param {FiniteTimeAction|FiniteTimeAction[]} actionOrActionArray
     * @param {FiniteTimeAction} ...tempArray
     * @return {FiniteTimeAction}
     * @example
     * import { spawn, jumpBy, rotateBy, Vec2 } from 'cc';
     * const action = spawn(jumpBy(2, new Vec2(300, 0), 50, 4), rotateBy(2, 720));
     * todo:It should be the direct use new
     */
    export function spawn(/*Multiple Arguments*/ tempArray: any): FiniteTimeAction;
    /**
     * !#en Delays the action a certain amount of seconds.
     * !#zh 延迟指定的时间量。
     * @method delayTime
     * @param {Number} d duration in seconds
     * @return {ActionInterval}
     * @example
     * import { delayTime } from 'cc';
     * const delay = delayTime(1);
     */
    export function delayTime(d: number): ActionInterval;
    /**
     * <p>
     * Executes an action in reverse order, from time=duration to time=0                                     <br/>
     * @warning Use this action carefully. This action is not sequenceable.                                 <br/>
     * Use it as the default "reversed" method of your own actions, but using it outside the "reversed"      <br/>
     * scope is not recommended.
     * </p>
     * @class ReverseTime
     * @extends ActionInterval
     * @param {FiniteTimeAction} action
     * @example
     * import ReverseTime from 'cc';
     * var reverse = new ReverseTime(this);
     */
    export class ReverseTime extends ActionInterval {
        private _other;
        constructor(action?: any);
        initWithAction(action: ActionInterval): boolean;
        clone(): ReverseTime;
        startWithTarget(target: any): void;
        update(dt: number): void;
        reverse(): any;
        stop(): void;
    }
    /**
     * !#en Executes an action in reverse order, from time=duration to time=0.
     * !#zh 反转目标动作的时间轴。
     * @method reverseTime
     * @param {FiniteTimeAction} action
     * @return {ActionInterval}
     * @example
     * import { reverseTime } from 'cc';
     * const reverse = reverseTime(this);
     */
    export function reverseTime(action: any): ActionInterval;
}
declare module "cocos/tween/export-api" {
    /**
     * @category tween
     */
    /**
     * @en
     * Built-in string value definition for the cache function.
     * @zh
     * 内置缓动函数的字符串值定义。
     */
    export type TweenEasing = 'linear' | 'smooth' | 'fade' | 'quadIn' | 'quadOut' | 'quadInOut' | 'quadOutIn' | 'cubicIn' | 'cubicOut' | 'cubicInOut' | 'cubicOutIn' | 'quartIn' | 'quartOut' | 'quartInOut' | 'quartOutIn' | 'quintIn' | 'quintOut' | 'quintInOut' | 'quintOutIn' | 'sineIn' | 'sineOut' | 'sineInOut' | 'sineOutIn' | 'expoIn' | 'expoOut' | 'expoInOut' | 'expoOutIn' | 'circIn' | 'circOut' | 'circInOut' | 'circOutIn' | 'elasticIn' | 'elasticOut' | 'elasticInOut' | 'elasticOutIn' | 'backIn' | 'backOut' | 'backInOut' | 'backOutIn' | 'bounceIn' | 'bounceOut' | 'bounceInOut' | 'bounceOutIn';
    /**
     * @en
     * The interface of optional property.
     * @zh
     * 缓动的可选属性的接口定义。
     */
    export interface ITweenOption {
        /**
         * @en
         * Easing function, you can pass in a string or custom function.
         * @zh
         * 缓动函数，可以使用已有的，也可以传入自定义的函数。
         */
        easing?: TweenEasing | ((k: number) => number);
        /**
         * @en
         * Interpolation functin, you can pass in a custom function.
         * @zh
         * 插值函数，参数的意义 start:起始值，end:目标值，current:当前值，ratio:当前进度
         */
        progress?: (start: number, end: number, current: number, ratio: number) => number;
        /**
         * @en
         * A callback that is triggered when a tween action is started.
         * @zh
         * 回调，当缓动动作启动时触发。
         */
        onStart?: (target?: object) => void;
        /**
         * @en
         * A callback that is triggered when a tween action is update.
         * @zh
         * 回调，当缓动动作更新时触发。
         */
        onUpdate?: (target?: object, ratio?: number) => void;
        /**
         * @en
         * A callback that is triggered when a tween action is completed.
         * @zh
         * 回调，当缓动动作完成时触发。
         */
        onComplete?: (target?: object) => void;
    }
}
declare module "cocos/tween/tween-action" {
    import { ActionInterval } from "cocos/tween/actions/action-interval";
    import { ITweenOption } from "cocos/tween/export-api";
    export class TweenAction extends ActionInterval {
        private _opts;
        private _props;
        private _originProps;
        constructor(duration: number, props: any, opts?: ITweenOption);
        clone(): TweenAction;
        startWithTarget(target: {}): void;
        update(t: number): void;
        progress(start: any, end: any, current: any, t: number): any;
    }
}
declare module "cocos/tween/set-action" {
    /**
     * @hidden
     */
    import { ActionInstant } from "cocos/tween/actions/action-instant";
    export class SetAction extends ActionInstant {
        private _props;
        constructor(props?: any);
        init(props: any): boolean;
        update(): void;
        clone(): SetAction;
    }
}
declare module "cocos/tween/tween" {
    import { ITweenOption } from "cocos/tween/export-api";
    /**
     * @en
     * Tween provide a simple and flexible way to action, It's transplanted from cocos creator。
     * @zh
     * Tween 提供了一个简单灵活的方法来缓动目标，从 creator 移植而来。
     * @class Tween
     * @param {Object} [target]
     * @example
     * tween(this.node)
     *   .to(1, {scale: new Vec3(2, 2, 2), position: new Vec3(5, 5, 5)})
     *   .call(() => { console.log('This is a callback'); })
     *   .by(1, {scale: new Vec3(-1, -1, -1), position: new Vec3(-5, -5, -5)}, {easing: 'sineOutIn'})
     *   .start()
     */
    export class Tween {
        private _actions;
        private _finalAction;
        private _target;
        private _tag;
        constructor(target?: object | null);
        /**
         * @en Sets tween tag
         * @zh 设置缓动的标签
         */
        tag(tag: number): this;
        /**
         * @en
         * Insert an action or tween to this sequence.
         * @zh
         * 插入一个 tween 到队列中。
         * @method then
         * @param {Tween} other
         * @return {Tween}
         */
        then(other: Tween): Tween;
        /**
         * @en
         * Sets tween target.
         * @zh
         * 设置 tween 的 target。
         * @method target
         * @param {Object} target
         * @return {Tween}
         */
        target(target: object | null): Tween;
        /**
         * @en
         * Start this tween.
         * @zh
         * 运行当前 tween。
         * @method start
         * @return {Tween}
         */
        start(): Tween;
        /**
         * @en
         * Stop this tween.
         * @zh
         * 停止当前 tween。
         * @method stop
         * @return {Tween}
         */
        stop(): Tween;
        /**
         * @en
         * Clone a tween.
         * @zh
         * 克隆当前 tween。
         * @method clone
         * @param {Object} [target]
         * @return {Tween}
         */
        clone(target: object): Tween;
        /**
         * @en
         * Integrate all previous actions to an action.
         * @zh
         * 将之前所有的 action 整合为一个 action。
         * @method union
         * @return {Tween}
         */
        union(): Tween;
        /**
         * @en
         * Add an action which calculate with absolute value.
         * @zh
         * 添加一个对属性进行绝对值计算的 action。
         * @method to
         * @param {number} duration 缓动时间，单位为秒
         * @param {Object} props 缓动的属性列表
         * @param {Object} [opts] 可选的缓动功能
         * @param {Function} [opts.progress]
         * @param {Function|String} [opts.easing]
         * @return {Tween}
         */
        to(duration: number, props: object, opts?: ITweenOption): Tween;
        /**
         * @en
         * Add an action which calculate with relative value.
         * @zh
         * 添加一个对属性进行相对值计算的 action。
         * @method by
         * @param {number} duration 缓动时间，单位为秒
         * @param {Object} props 缓动的属性列表
         * @param {Object} [opts] 可选的缓动功能
         * @param {Function} [opts.progress]
         * @param {Function|String} [opts.easing]
         * @return {Tween}
         */
        by(duration: number, props: object, opts?: ITweenOption): Tween;
        /**
         * @en
         * Directly set target properties.
         * @zh
         * 直接设置 target 的属性。
         * @method set
         * @param {Object} props
         * @return {Tween}
         */
        set(props: object): Tween;
        /**
         * @en
         * Add an delay action.
         * @zh
         * 添加一个延时 action。
         * @method delay
         * @param {number} duration
         * @return {Tween}
         */
        delay(duration: number): Tween;
        /**
         * @en
         * Add an callback action.
         * @zh
         * 添加一个回调 action。
         * @method call
         * @param {Function} callback
         * @return {Tween}
         */
        call(callback: Function): Tween;
        /**
         * @en
         * Add an sequence action.
         * @zh
         * 添加一个队列 action。
         * @method sequence
         * @param {Tween} action
         * @param {Tween} ...actions
         * @return {Tween}
         */
        sequence(...args: Tween[]): Tween;
        /**
         * @en
         * Add an parallel action.
         * @zh
         * 添加一个并行 action。
         * @method parallel
         * @param {Tween} action
         * @param {Tween} ...actions
         * @return {Tween}
         */
        parallel(...args: Tween[]): Tween;
        /**
         * @en
         * Add an repeat action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个重复 action，这个 action 会将前一个动作作为他的参数。
         * @method repeat
         * @param {number} repeatTimes 重复次数
         * @param {Tween} embedTween 可选，嵌入 Tween
         * @return {Tween}
         */
        repeat(repeatTimes: number, embedTween?: Tween): Tween;
        /**
         * @en
         * Add an repeat forever action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个永久重复 action，这个 action 会将前一个动作作为他的参数。
         * @method repeatForever
         * @param {Tween} embedTween 可选，嵌入 Tween
         * @return {Tween}
         */
        repeatForever(embedTween?: Tween): Tween;
        /**
         * @en
         * Add an reverse time action.
         * This action will integrate before actions to a sequence action as their parameters.
         * @zh
         * 添加一个倒置时间 action，这个 action 会将前一个动作作为他的参数。
         * @method reverseTime
         * @param {Tween} embedTween 可选，嵌入 Tween
         * @return {Tween}
         */
        reverseTime(embedTween?: Tween): Tween;
        /**
         * @en
         * Add an hide action, only for node target.
         * @zh
         * 添加一个隐藏 action，只适用于 target 是节点类型的。
         * @method hide
         * @return {Tween}
         */
        hide(): Tween;
        /**
         * @en
         * Add an show action, only for node target.
         * @zh
         * 添加一个显示 action，只适用于 target 是节点类型的。
         * @method show
         * @return {Tween}
         */
        show(): Tween;
        /**
         * @en
         * Add an removeSelf action, only for node target.
         * @zh
         * 添加一个移除自己 action，只适用于 target 是节点类型的。
         * @method removeSelf
         * @return {Tween}
         */
        removeSelf(): Tween;
        /**
         * @en
         * Stop all tweens
         * @zh
         * 停止所有缓动
         */
        static stopAll(): void;
        /**
         * @en
         * Stop all tweens by tag
         * @zh
         * 停止所有指定标签的缓动
         */
        static stopAllByTag(tag: number, target?: object): void;
        /**
         * @en
         * Stop all tweens by target
         * @zh
         * 停止所有指定对象的缓动
         */
        static stopAllByTarget(target: any): void;
        private _union;
        private _destroy;
        private static readonly _tmp_args;
        private static _wrappedSequence;
        private static _wrappedParallel;
    }
    /**
     * @en
     * tween is a utility function that helps instantiate Tween instances.
     * @zh
     * tween 是一个工具函数，帮助实例化 Tween 实例。
     * @param target 缓动的目标
     * @returns Tween 实例
     * @example
     * tween(this.node)
     *   .to(1, {scale: new Vec3(2, 2, 2), position: new Vec3(5, 5, 5)})
     *   .call(() => { console.log('This is a callback'); })
     *   .by(1, {scale: new Vec3(-1, -1, -1)}, {easing: 'sineOutIn'})
     *   .start()
     */
    export function tween(target?: object): Tween;
    /**
     * @en
     * tweenUtil is a utility function that helps instantiate Tween instances.
     * @zh
     * tweenUtil 是一个工具函数，帮助实例化 Tween 实例。
     * @deprecated please use `tween` instead.
     */
    export function tweenUtil(target?: object): Tween;
}
declare module "cocos/tween/index" {
    /**
     * @hidden
     */
    export { TweenSystem } from "cocos/tween/tween-system";
    export { tween, tweenUtil, Tween } from "cocos/tween/tween";
    export * from "cocos/tween/export-api";
}
declare module "exports/tween" {
    /**
     * @hidden
     */
    export * from "cocos/tween/index";
}
declare module "exports/ui" {
    /**
     * @hidden
     */
    export * from "cocos/core/components/ui-base/index";
    export * from "cocos/ui/index";
}
declare module "exports/wait-for-ammo-instantiation" {
    export { waitForAmmoInstantiation as default } from "cocos/physics/ammo/ammo-instantiated";
}
declare module "index" {
    /**
     * @hidden
     */
    export * from "exports/base";
    export * from "exports/gfx-webgl";
    export * from "exports/gfx-webgl2";
    export * from "exports/audio";
    export * from "exports/particle";
    export * from "exports/ui";
    export * from "exports/tween";
    export * from "exports/terrain";
    export * from "exports/physics-framework";
    export * from "exports/physics-builtin";
    export * from "exports/physics-cannon";
    export * from "exports/physics-ammo";
}
